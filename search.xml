<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信二维码闪退，深扒源码后发现不止一处bug</title>
      <link href="/2024/05/15/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%97%AA%E9%80%80%EF%BC%8C%E6%B7%B1%E6%89%92%E6%BA%90%E7%A0%81%E5%90%8E%E5%8F%91%E7%8E%B0%E4%B8%8D%E6%AD%A2%E4%B8%80%E5%A4%84bug/"/>
      <url>/2024/05/15/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%97%AA%E9%80%80%EF%BC%8C%E6%B7%B1%E6%89%92%E6%BA%90%E7%A0%81%E5%90%8E%E5%8F%91%E7%8E%B0%E4%B8%8D%E6%AD%A2%E4%B8%80%E5%A4%84bug/</url>
      
        <content type="html"><![CDATA[<p>2023年4月24日微信在扫描某些特殊二维码时会出现崩溃，这部分正好是微信开源的模块，可以分析其问题源码以确定其bug并了解C++的常见坑点。</p><p>问题源码位置:<code>opencv_contrib/modules/wechat_qrcode/src/zxing/qrcode/decoder/decoded_bit_stream_parser.cpp</code>。</p><h2 id="整数除法结果会舍弃小数部分">整数除法结果会舍弃小数部分</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525110519.jpg" alt=""></p><p><code>count = (available + 7 / 8)</code>中的<code>7 / 8</code>运算结果为0，也就是等价于<code>count = available</code>。当<code>count</code>不为0而<code>available</code>为0时，<code>count</code>会被赋值为0，这会导致下面的<code>bytes_</code>是一个大小为0的空数组且<code>readBytes</code>是空指针，一旦解引用空指针就会发生崩溃！</p><p><code>count = (available 7 / 8)</code>这里应该是希望当<code>count</code>个字节占据的比特位数大于<code>available</code>时应该根据<code>available</code>向上扩容，那就应该进行如下修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(count * <span class="number">8</span> &gt; available)&#123;</span><br><span class="line">    cout = (available + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有个很明显的问题，最上面<code>int nBytes = count;</code>，而当<code>count</code>值改变后那会造成其与<code>nBytes</code>变量的值会不一致，这是否符合预期？应该尽可能避免冗余的无效变量，就算有必要这里也最好使用引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; nBytes = count;</span><br></pre></td></tr></table></figure><h2 id="漏写return">漏写return</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525112547.jpg" alt=""></p><p>这里很明显应该是漏掉一个<code>return</code>，否则没有任何意义，代码中还有其它好几处均漏掉了<code>return</code>。</p><h2 id="内存泄露">内存泄露</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525113142.jpg" alt=""></p><p><code>while</code>循环中当<code>if(err_handler.ErrCode())</code>为真时直接<code>return</code>了，并没有<code>delete[] buffer</code>，这会造成内存泄露！</p><p>C++工程实践中应遵循RAII的思想：不要直接用<code>new</code>、<code>delete</code>动态分配内存，而应该是用对象管理资源，这样当对象离开作用域时，会自动调用析构函数释放资源。对应这里应该直接使用智能指针<code>unique_ptr</code>，这样<code>return</code>时就无需担心忘记<code>delete[] buffer</code>了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">char</span>[]&gt; <span class="title">buffer</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[nBytes])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">append</span>(result, buffer.<span class="built_in">get</span>(), nBytes, err_handler);</span><br></pre></td></tr></table></figure><p>或者直接使用<code>vector</code>容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(nBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">append</span>(result, buffer.<span class="built_in">data</span>(), nBytes, err_handler);</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525151133.jpg" alt=""></p><p>这里<code>cd = iconv_open(StringUtils::UTF8, src)</code>应该是打开了某个资源，函数结束前<code>iconv_close(cd)</code>会释放该资源，但中间某些情况<code>return</code>时却忘了释放该资源<code>iconv_close(cd)</code>，这会造成资源泄露！</p><p>解决该问题也是要遵守RAII的原则，可以使用智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Del</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">iconv_t</span>* p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">iconv_close</span>(*p);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">iconv_t</span>, Del&gt; <span class="title">cd</span><span class="params">(<span class="keyword">new</span> <span class="type">iconv_t</span>(iconv_open(StringUtils::UTF8, src)))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="要善于使用lambda表达式">要善于使用lambda表达式</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525120017.jpg" alt=""></p><p>如果变量<code>nBytes</code>值会一直是<code>count</code>的两倍，那么这里最好使用lambda表达式，需要时直接调用<code>nBytes()</code>，避免每次<code>count</code>值变动后原来的<code>nBytes</code>值失效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> nBytes = [&amp;]&#123;<span class="keyword">return</span> <span class="number">2</span> * count;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(nBytes())</span></span>;</span><br></pre></td></tr></table></figure><p>还是应当尽可能避免冗余的无效变量，这样逻辑简介且更不容易出错。</p><h2 id="数组索引为负时越界">数组索引为负时越界</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525152824.jpg" alt=""></p><p>这里是通过查表法来给<code>bytes</code>数组相应位置上写入字符，但浪费时间和空间，没有必要，应该直接通过ACSII码加上偏移量就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes[i++] = <span class="string">&#x27;0&#x27;</span> + threeDigitsBits / <span class="number">100</span>;</span><br><span class="line">bytes[i++] = <span class="string">&#x27;0&#x27;</span> + (threeDigitsBits / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">bytes[i++] = <span class="string">&#x27;0&#x27;</span> + threeDigitsBits % <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>原来的查表法还存在一个明显的隐患，索引中的<code>threeDigitsBits</code>的类型是有符号整型<code>int</code>，当它值为负数时对数组<code>ALPHANUMERIC_CHARS</code>的访问会越界！数组索引下标应该是无符号类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> threeDigitsBits = bits-&gt;<span class="built_in">readBits</span>(<span class="number">10</span>, err_handler);</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525155640.jpg" alt=""></p><p>而且<code>readBits()</code>的实现可读性太差，各种左移右移还有<code>mask</code>，还要特别注意有符号数算术右移时会扩展符号位！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11测试代码性能(执行时间)的正确姿势</title>
      <link href="/2024/03/06/C++11%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD(%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4)%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>/2024/03/06/C++11%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD(%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4)%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>本文总结性能测试的常用方法，这里以测试遍历<code>vector</code>容器不同方法的性能为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ScopeProfiler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">vec[i] = i % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为性能测试</span></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;下标遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">sum += vec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;Range遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> <span class="type">const</span>&amp; a : vec)</span><br><span class="line">sum += a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;迭代器遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">sum += *it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;指针遍历&quot;</span>);</span><br><span class="line"><span class="type">int</span>* p = vec.<span class="built_in">data</span>(), *endp = p + vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(p != endp)&#123;</span><br><span class="line">sum += *p;</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printScopeProfiler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ScopeProfiler.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeProfiler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ClockType = std::chrono::high_resolution_clock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tag;</span><br><span class="line">        <span class="type">int</span> us;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">thread_local</span> <span class="type">static</span> std::vector&lt;Record&gt; records;</span><br><span class="line"></span><br><span class="line">    ClockType::time_point beg;</span><br><span class="line">    ClockType::time_point end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">ScopeProfiler</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *tag, ClockType::time_point beg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">onDestroy</span><span class="params">(ClockType::time_point end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopeProfiler</span>(<span class="type">const</span> <span class="type">char</span> *tag_) : <span class="built_in">ScopeProfiler</span>(tag_, ClockType::<span class="built_in">now</span>()) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ScopeProfiler</span>() &#123; <span class="built_in">onDestroy</span>(ClockType::<span class="built_in">now</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::vector&lt;Record&gt; <span class="type">const</span> &amp;<span class="title">getRecords</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> records; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">printLog</span><span class="params">(std::ostream &amp;out = std::cout)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ScopeProfiler::<span class="built_in">ScopeProfiler</span>(<span class="type">const</span> <span class="type">char</span> *tag_, ScopeProfiler::ClockType::time_point beg_)</span><br><span class="line">    : <span class="built_in">beg</span>(beg_), <span class="built_in">tag</span>(tag_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScopeProfiler::onDestroy</span><span class="params">(ScopeProfiler::ClockType::time_point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> diff = end - beg;</span><br><span class="line">    <span class="type">int</span> us = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(diff).<span class="built_in">count</span>();</span><br><span class="line">    records.<span class="built_in">push_back</span>(&#123;tag, us&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScopeProfiler::printLog</span><span class="params">(std::ostream &amp;out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (records.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Statistic</span> &#123;</span><br><span class="line">        <span class="type">int</span> max_us = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_us = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total_us = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count_rec = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tag = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::map&lt;std::string_view, Statistic&gt; stats;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[tag, us]: records) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;stat = stats[tag];</span><br><span class="line">        stat.total_us += us;</span><br><span class="line">        stat.max_us = std::<span class="built_in">max</span>(stat.max_us, us);</span><br><span class="line">        stat.min_us = !stat.count_rec ? us : std::<span class="built_in">min</span>(stat.min_us, us);</span><br><span class="line">        stat.count_rec++;</span><br><span class="line">        stat.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StatisticCompare</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> value_type = std::pair&lt;std::string_view, Statistic&gt;;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(value_type <span class="type">const</span> &amp;lhs, value_type <span class="type">const</span> &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second.total_us &gt; rhs.second.total_us;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::multiset&lt;std::pair&lt;std::string_view, Statistic&gt;, StatisticCompare&gt; <span class="built_in">sortstats</span>(stats.<span class="built_in">begin</span>(), stats.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dump = [&amp;out] (<span class="type">int</span> val, <span class="type">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tpwv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w - <span class="number">1</span>; i++) tpwv *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; tpwv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val / <span class="number">1000</span> &gt; tpwv / <span class="number">10</span>) &#123;</span><br><span class="line">                out &lt;&lt; std::<span class="built_in">setw</span>(w - <span class="number">1</span>) &lt;&lt; val / <span class="number">1000000</span> &lt;&lt; <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out &lt;&lt; std::<span class="built_in">setw</span>(w - <span class="number">1</span>) &lt;&lt; val / <span class="number">1000</span> &lt;&lt; <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out &lt;&lt; std::<span class="built_in">setw</span>(w) &lt;&lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="string">&quot;   avg   |   min   |   max   |  total  | cnt | tag\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[tag, stat]: sortstats) &#123;</span><br><span class="line">        <span class="built_in">dump</span>(stat.total_us / stat.count_rec, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.min_us, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.max_us, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.total_us, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.count_rec, <span class="number">5</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; tag &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printScopeProfiler</span><span class="params">(std::ostream &amp;out = std::cout)</span> </span>&#123;</span><br><span class="line">    ScopeProfiler::<span class="built_in">printLog</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScopeProfiler</code>在构造时会记录当前时间，当它析构时会计算当前时间与之前记录的构造时间之差，并将其转换为微妙，并将本次执行时间记录写入到<code>records</code>中。注意<code>records</code>是线程局域的，有多个线程时会分别记录。<code>ScopeProfiler::printLog()</code>会打印性能测试的所有记录。</p><h2 id="编译优化选项">编译优化选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ main.cpp -std=c++2a -o main &amp;&amp; ./main</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">    13012|    13012|    13012|    13012|    1| 迭代器遍历</span><br><span class="line">     9354|     9354|     9354|     9354|    1| Range遍历</span><br><span class="line">     4360|     4360|     4360|     4360|    1| 下标遍历</span><br><span class="line">     1919|     1919|     1919|     1919|    1| 指针遍历</span><br></pre></td></tr></table></figure><p>看起来迭代器和C++11的Range遍历效率很低？注意这是因为编译时如果不带优化选项会默认<code>O0</code>参数，此时不会开启任何优化，即上面的编译命令等价于<code>g++ -O0 main.cpp -std=c++2a -o main &amp;&amp; ./main</code>。迭代器是一个类，它其中重载了解引用、++等运算符，如果不开启优化这些重载的运算符都是一个个的成员函数，<code>O0</code>是不会内联任何函数的，此时<code>++it</code>和<code>sum += *it</code>会有函数调用<code>call</code>的明显开销：</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240428122132.jpg" alt=""></p><p>gcc的优化开关主要分为3个等级：<code>-O1</code>、<code>-O2</code>和<code>-O3</code>，还有<code>-Oz</code>、<code>-Os</code>和<code>-Ofast</code>等暂且不论。</p><p><code>-O1</code>会开启一部分汇编程度的优化，它包含内联优化的操作，示例代码的执行时间明显会快很多，4种遍历方法的性能没有显著区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ -O1 main.cpp -std=c++2a -o main1 &amp;&amp; ./main1</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">      420|      420|      420|      420|    1| 指针遍历</span><br><span class="line">      334|      334|      334|      334|    1| Range遍历</span><br><span class="line">      312|      312|      312|      312|    1| 下标遍历</span><br><span class="line">      312|      312|      312|      312|    1| 迭代器遍历</span><br></pre></td></tr></table></figure><p><code>-O2</code>相比<code>-O1</code>会开启进一步优化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ -O2 main.cpp -std=c++2a -o main2 &amp;&amp; ./main2</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">        0|        0|        0|        0|    1| Range遍历</span><br><span class="line">        0|        0|        0|        0|    1| 下标遍历</span><br><span class="line">        0|        0|        0|        0|    1| 指针遍历</span><br><span class="line">        0|        0|        0|        0|    1| 迭代器遍历</span><br></pre></td></tr></table></figure><p>开启<code>-O2</code>后这4种遍历方式的执行时间都变为0了？这是因为开启<code>-O2</code>优化后编译器会把所有没有实际效果的代码通通删除，示例代码中的<code>sum</code>计算出<code>vector</code>中所有元素之和后并未被使用，因此它会将4个<code>&#123;&#125;</code>作用域中的计算<code>vector</code>中所有元素之和的代码全部删除。为了避免这个问题，加上<code>print(sum)</code>，这样编译器会认为<code>sum</code>变量会被使用就不会把求和代码删掉了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fake.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ScopeProfiler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数的意义在于避免编译器在O2优化时在&#123;&#125;块中看到sum未使用而将块中求和代码全部删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">vec[i] = i % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为性能测试</span></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;下标遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">sum += vec[i];</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;Range遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> <span class="type">const</span>&amp; a : vec)</span><br><span class="line">sum += a;</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;迭代器遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">sum += *it;</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;指针遍历&quot;</span>);</span><br><span class="line"><span class="type">int</span>* p = vec.<span class="built_in">data</span>(), *endp = p + vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(p != endp)&#123;</span><br><span class="line">sum += *p;</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printScopeProfiler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ -O2 main.cpp fake.cpp -std=c++2a -o main2 &amp;&amp; ./main2</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">     1813|     1813|     1813|     1813|    1| 下标遍历</span><br><span class="line">     1812|     1812|     1812|     1812|    1| 指针遍历</span><br><span class="line">     1755|     1755|     1755|     1755|    1| 迭代器遍历</span><br><span class="line">     1700|     1700|     1700|     1700|    1| Range遍历</span><br></pre></td></tr></table></figure><p><code>-O3</code>会开启一个矢量化的优化，性能会更快。</p><h2 id="系统性能分析工具perf">系统性能分析工具perf</h2><p>perf 是Linux的一款性能分析工具，能够进行函数级和指令级的热点查找，可以用来分析程序中热点函数的CPU占用率，从而定位性能瓶颈。</p><h3 id="perf的原理">perf的原理</h3><p>Linux性能计数器是一个基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU（Performance Monitoring Unit））功能和软件（软件计数器、tracepoint）功能。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/20210116001918115.png" alt=""></p><p>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。</p><p>Perf 可以对程序进行函数级别的采样，从而了解程序的性能瓶颈在哪里。其基本原理是：每隔一个固定时间，就是CPU上产生一个中断，看当前是哪个进程、哪个函数，然后给对应的进程和函数加一个统计值，这样就知道CPU有多少时间在某个进程或某个函数上了。</p><h3 id="perf的使用">perf的使用</h3><p>使用 perf 进行性能分析，主要使用下面两个命令：</p><ul><li><code>perf record</code>：保存perf追踪的内容，文件名为perf.data</li><li><code>perf report</code>：解析perf.data的内容</li></ul><p>比如要分析进程 xxx，启动该进程后，首先启动使用下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -a --call-graph dwarf -p `ps aux | grep <span class="string">&quot;xxx&quot;</span> | grep -v grep | <span class="built_in">cut</span> -c 9-15` -d 1 -b</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>-a</code>：表示对所有CPU采样</li><li><code>--call-graph dward</code>：表示分析调用栈的关系</li><li><code>-p</code>：表示分析指定的进程</li></ul><p>通过 Ctrl + C 结束后，会生成 perf.data 文件，然后通过 report 导出报告，即可以查看 main 函数和子函数的CPU平均占用率。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><h3 id="perf使用示例">perf使用示例</h3><p>有如下示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_loop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">sin</span>(i) + <span class="built_in">cos</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_small</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">for_loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_big</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">for_loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">loop_big</span>();</span><br><span class="line"><span class="built_in">loop_small</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>for_loop()</code>是一个两层循环，每次都要计算正弦和余弦的和，这是一个比较耗时的函数；<code>loop_small()</code>把<code>for_loop()</code>循环10次；<code>loop_big()</code>把<code>for_loop()</code>循环100次。</p><p>可以明显看出<code>main()</code>函数中<code>loop_big()</code>函数会占大部分CPU，下面通过 perf 命令验证下：</p><p>1）假设指定可执行文件的名称为perf_for</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ perf_for.cpp -o perf_for</span><br></pre></td></tr></table></figure><p>2）运行 perf_for 之后，启动 <code>perf record</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -a --call-graph dwarf -p `ps -ef | grep perf_for | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br></pre></td></tr></table></figure><p>3）结束后，通过<code>perf report</code>导出报告</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><p>如下图所示，可以看出main函数92%的CPU都花在<code>loop_big()</code>函数上：</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240428140143.jpg" alt=""></p><h2 id="benchmark">BENCHMARK</h2><p>未完待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 3 资源管理</title>
      <link href="/2023/03/13/Effective-C-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/13/Effective-C-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>C++程序中最常使用的资源就是动态内存（如果分配内存却从来不曾归还它，会导致内存泄露），但内存只是程序员必须管理的众多资源之一。其它常见的资源还包括文件描述符、互斥锁、图形界面中的字型和笔刷、数据库连接以及网络套接字<code>socket</code>。不论哪一种资源，重要的是当你不再使用它时，必须将它归还系统。</p><h2 id="条款13：以对象管理资源">条款13：以对象管理资源</h2><p>以对象管理资源的两个关键点：</p><ol><li><p>获得资源后立刻放进管理对象内</p><p>“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”(<em>Resource Acquisition Is Initialization, RAII</em>)，因为程序员几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象。有时获得的资源被拿来赋值（而非初始化）某个管理对象，但不论哪一种做法，每一笔资源都在获得的同时立刻被放进管理对象中。</p></li><li><p>管理对象运用析构函数确保资源被释放</p><p>不论控制流如何离开区块，一旦对象被销毁（例如当对象离开作用域）其析构函数自然会被自动调用，于是资源被释放。</p></li></ol><p>一句话概括就是：为防止资源泄露，请使用<em>RAII</em>对象，它们在构造函数中获得资源并在析构函数中释放资源。</p><h2 id="条款14：在资源管理类中小心拷贝行为">条款14：在资源管理类中小心拷贝行为</h2><p>当一个<em>RAII</em>对象被复制时，程序员一般有两种策略可供选择：</p><ol><li><p><strong>禁止复制</strong></p><p>许多时候允许<em>RAII</em>对象被复制并不合理，如果复制动作对<em>RAII</em>类并不合理，程序员便应该禁止它。将拷贝操作声明为<code>private</code>但故意不实现它，或者将拷贝操作声明为<code>=delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> UnCopyable&#123;<span class="comment">// 禁止复制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对底层资源使用引用计数法</strong></p><p>有时程序员希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制<em>RAII</em>对象时，应将该资源的“被引用数”递增。</p></li></ol><h2 id="条款15：在资源管理类中提供对原始资源的访问">条款15：在资源管理类中提供对原始资源的访问</h2><p>APIs往往要求访问原始资源，所以每一个RAII类应该提供一个“取得其所管理之资源”的方法。对原始资源的访问可能经由显示转换<code>get()</code>或隐式转换（类型转换运算符），一般而言显示转换比较安全，但隐式转换对客户比较方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> f;&#125;<span class="comment">// 显示转换函数</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">// 隐式转换函数</span></span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款16：成对使用new和delete时要采用相同形式">条款16：成对使用new和delete时要采用相同形式</h2><p>当程序员使用<code>new</code>，也就是通过<code>new</code>动态生成一个对象时，有两件事发生：第一，内存被分配出来（通过<code>operator new</code>函数）；第二，针对此内存会有一个或多个构造函数被调用。</p><p>当使用<code>delete</code>时，也有两件事发生：针对此内存会有一个或更多析构函数被调用，然后内存才被释放（通过<code>operator delete</code>函数）。<code>delete</code>的最大问题在于：即将被删除的内存之内究竟有多少个对象？这个问题的答案决定了有多少个析构函数必须被调用起来。</p><p>这个问题的本质在于：即将被删除的那个指针，所指的是单一对象或对象数组？单一对象的内存布局一般而言不同于数组的内存布局，因为数组所用的内存通常还包括“数组大小”的记录，以便<code>delete</code>知道需要调用多少次析构函数；而单一对象的内存则没有这笔记录。</p><p>当程序员对着一个指针使用<code>delete</code>，唯一能让<code>delete</code>知道内存中是否存在一个“数组大小记录”的办法就是由程序员告诉它。如果使用<code>delete</code>时加上方括号，<code>delete</code>便认定指针指向一个数组，否则它便认定指针指向单一对象。</p><p>因此：如果在<code>new</code>表达式中使用<code>[]</code>，必须在相应的<code>delete</code>表达式中也使用<code>[]</code>。如果在<code>new</code>表达式中不使用<code>[]</code>，一定不要在相应的<code>delete</code>表达式中使用<code>[]</code>。</p><h2 id="条款17：以独立语句将newed对象置入智能指针">条款17：以独立语句将newed对象置入智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>编译器产出一个<code>processWidget</code>调用码之前，必须首先核算即将被传递的实参。上述第二实参只是单纯地对<code>priority</code>函数的调用，但第一实参<code>std::shared_ptr&lt;Widget&gt;(new Widget)</code>由两部分组成：</p><ol><li>执行<code>new Widget</code>表达式</li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>于是在调用<code>processWidget</code>之前，编译器必须创建代码来做以下三件事：</p><ol><li>调用<code>priority</code></li><li>执行<code>new Widget</code></li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>但是C++编译器可以以非常弹性的次序完成这些事情，可以确定是<code>new Widget</code>一定执行于<code>std::shared_ptr</code>构造函数调用之前，因为这个表达式的结果还要被传递作为<code>std::shared_ptr</code>构造函数的一个实参，但对<code>priority</code>的调用可以排在第一或第二或第三执行。如果编译器因为生成了更高效的代码而以第二顺位执行它，最终获得这样的操作序列：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority</code></li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>此时，一旦对<code>priority</code>的调用发生异常，那么<code>new Widget</code>返回的指针将会遗失，因为它还尚未被置入<code>std::shared_ptr</code>内！即在对<code>processWidget</code>的调用过程中可能引发资源泄露，因为在“资源创建（<code>new Widget</code>）”和“资源被转换为资源管理对象”两个时间点之间可能发生异常干扰。</p><p>由于编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度），避免这类问题的方法很简单：使用分离语句分别写出1.创建<code>Widget</code>；2.将它置入一个智能指针内，然后再把那个智能指针传给<code>processWidget</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>在上述修订后的代码内，“<code>new Widget</code>”表达式以及“对<code>std::shared_ptr</code>构造函数的调用”这两个动作，和“对<code>priority</code>的调用”是分隔开的，位于不同语句内，所以编译器不得在它们之间任意选择执行次序。</p><p>因此，以独立语句将<code>newed</code>对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 2.构造、析构和赋值运算</title>
      <link href="/2023/03/07/Effective-C-2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
      <url>/2023/03/07/Effective-C-2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="条款05：-了解c-默默编写并调用哪些函数">条款05： 了解C++默默编写并调用哪些函数</h2><p>如果程序员没有声明，编译器就会为它声明（编译器版本的）一个拷贝构造函数、一个拷贝赋值运算符和一个析构函数。此外，如果没有声明任何构造函数，编译器也会为你声明一个默认构造函数。所有这些函数都是<code>public</code>且<code>inline</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此，如果写下:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就好像你写下这样的代码:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>()&#123;...&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Empty</span>()&#123;...&#125;<span class="comment">// 析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>惟有当这些函数被需要（被调用），它们才会被编译器创建出来。</p><p>需要特别注意：编译器产出的析构函数是非<code>virtual</code>的，除非这个类的基类自身声明有<code>virtual</code>析构函数！</p><p>至于拷贝构造函数和拷贝赋值运算符，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。</p><p>如果打算在一个内含引用成员的类内支持赋值操作，那必须自己定义拷贝赋值运算符；面对内含<code>const</code>成员的类，编译器会拒绝编译那一行赋值动作，因为更改<code>const</code>成员是不合法的；如果某个基类将拷贝赋值运算符声明为<code>private</code>，那么编译器将拒绝为其派生类生成一个拷贝赋值运算符。</p><h2 id="条款06：若不想使用编译器自动生成的函数-就该明确拒绝">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>在C++ 11标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为<code>=delete</code>来阻止拷贝。删除的函数就是虽然程序员声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上<code>=delete</code>来指出希望将它定义为删除的。</p><p>为了阻止拷贝构造函数和拷贝赋值运算符被编译器自动生成，得程序员自行声明它们，可以将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>，这样阻止人们调用它。**Tips：**可以将成员函数声明为<code>private</code>而且故意不实现它们。</p><p>也可以设计一个专门阻止拷贝动作的基类，基类中将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;<span class="comment">// 允许派生类对象构造和析构</span></span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);<span class="comment">// 声明为private但故意不实现就是为了阻止拷贝 </span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了阻止HomeForSale对象被拷贝，唯一需要做的就是继承Uncopyable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款07：为多态基类声明virtual析构函数">条款07：为多态基类声明virtual析构函数</h2><p>C++明白指出，当派生类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，其结果未有定义——实际执行时通常发生的是对象的派生类成分没被销毁，即派生类的析构函数未能执行起来导致派生类成员很可能没被销毁，然后其基类成分通常会被销毁，于是造成一个诡异的“局部销毁”对象，造成内存泄露。</p><p>消除该问题的做法是：给基类一个虚析构函数，此后删除派生类对象就会正常，它会销毁整个对象，包括派生类成分。</p><p>虚表指针<em>vptr</em>指向一个由函数指针构成的数组，称为虚函数表<em>vtbl</em>：每一个带有虚函数的类都有一个相应的虚函数表。当对象调用某一虚函数时，实际被调用的函数取决于该对象的虚表指针所指的那个虚表——编译器在其中寻找适当的函数指针。</p><p>无端地将所有类的析构函数声明为<code>virtual</code>，就像从未声明它们为<code>virtual</code>一样，都是错误的。最佳工程实践是：只有当类内含至少一个虚函数，程序员才为它声明虚析构函数。</p><p>析构函数的运作方式是，最深层派生的那个类其析构函数最先被调用，然后是其每一个基类的析构函数被调用。</p><h2 id="条款08：别让异常逃离析构函数">条款08：别让异常逃离析构函数</h2><p>只要析构函数吐出异常，即使并非使用容器或<code>arrays</code>，程序也可能过早结束或出现不明确行为。C++不喜欢析构函数吐出异常！</p><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作。</p><h2 id="条款09：绝不在构造和析构过程中调用虚函数">条款09：绝不在构造和析构过程中调用虚函数</h2><p>基类构造期间虚函数绝不会下降到派生类阶层，取而代之的是，对象的行为就像隶属于基类类型一样。即在基类构造期间，虚函数不是虚函数。因此程序员应确定类的构造函数和析构函数都没有（在对象被创建和被销毁期间）调用虚函数，而它们中调用的所有函数也都服从同一约束。</p><h2 id="条款10：令operator-返回一个-this的引用">条款10：令<code>operator=</code>返回一个<code>*this</code>的引用</h2><p>为了实现“连锁赋值”，所有赋值相关的操作符必须返回一个引用指向操作符的左侧实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款11：在operator-中处理-自我赋值">条款11：在<code>operator=</code>中处理“自我赋值”</h2><p>“自我赋值”发生在对象被赋值给自己时，虽然这看起来有点愚蠢，但它合法，而且潜在的自我赋值可能不容易被一眼辨识出来。</p><p>一般而言如果某段代码操作指针或引用而它们被用来“指向多个相同类型的对象”，就需考虑这些对象是否为同一个！</p><p>为了阻止“自我赋值”的不安全性错误，传统做法是在<code>operator=</code>最前面安插一个“证同测试”来检验是否“自我赋值”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bimap* bp;<span class="comment">// 指向一个从堆分配而得的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="comment">// 如果是自我赋值，就不做任何事</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12：复制对象时勿忘其每一个成分">条款12：复制对象时勿忘其每一个成分</h2><p>当程序员编写一个拷贝函数时，要确保复制所有局部成员变量，并调用基类中合适的拷贝函数来复制所有基类成分！</p><p>不要尝试以某个拷贝函数实现另一个拷贝函数，应将相同部分放进第三个函数中，并由两个拷贝函数 共同调用。比如发现拷贝构造函数和拷贝赋值运算符有相近的代码，消除重复代码的做法是建立一个新的成员函数给两者调用。这样的函数往往是<code>private</code>而且常被命名为<code>init</code>。这个策略可以安全消除拷贝构造函数和拷贝赋值运算符之间的代码重复问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 1.让自己习惯C++</title>
      <link href="/2023/03/01/Effective-C-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/"/>
      <url>/2023/03/01/Effective-C-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/</url>
      
        <content type="html"><![CDATA[<h2 id="条款01：视c-为一个语言联邦">条款01：视C++为一个语言联邦</h2><p>将C++视为一个由相关语言组成的联邦而非单一语言，在其某个次语言中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然后当从一个次语言移往另一个次语言时，守则可能改变，C++总共有4个次语言：C语言；C++面向对象；C++模板；标准模板库STL。</p><p>因此，C++并不是一个带有一组守则的一体语言，它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言就会发现C++容易了解得多。</p><h2 id="条款02：尽量以const-enum-inline替换-define">条款02：尽量以const, enum, inline替换#define</h2><ul><li>对于单纯常量，最好以<code>const</code>对象或<code>enums</code>替换<code>#defines</code></li><li>对于形似函数的宏，最好改用<code>template inline</code>函数替换<code>#defines</code></li></ul><h2 id="条款03：尽可能使用const">条款03：尽可能使用const</h2><p>注意：如果被指物是常量，程序员可将关键字<code>const</code>写在类型之前或者类型之后星号之前，两种写法意义相同，所以下列两个函数接受的参数类型是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;<span class="comment">// f1获得一个指针，指向一个常量的(不变的)Widget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>;<span class="comment">// f2也是</span></span><br></pre></td></tr></table></figure><p>两种形式都有人用，应该试着习惯它们。</p><p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。例如将<code>operator*</code>重载函数的返回值声明为<code>const</code>可以预防“没意思的赋值动作”。</p><h3 id="const成员函数">const成员函数</h3><p><code>const</code>作用于成员函数可以使得<code>class</code>接口比较容易理解，因为这样可以得知哪个函数可以改动对象内容而哪个函数不行；它还使“操作<code>const</code>”对象成为可能。改善C++程序效率的一个根本办法是以<em>pass by reference-to-const</em>方式传递对象，此技术的前提是有<code>const</code>成员函数可用来处理取得（并经修饰而成）的<code>const</code>对象。</p><p>注意：两个成员函数如果只是常量性不同（即一个带<code>const</code>而另一个不带），可以被重载。</p><p>真实程序中<code>const</code>对象大多用于<code>passed by pointer-to-const</code>或<code>passed by reference-to-const</code>的传递结果</p><p>当程序员希望能修改类的某个数据成员，即使是在一个<code>const</code>成员函数内，可以通过在成员变量的声明中加入<code>mutable</code>关键字来做到这一点！借助<code>mutable</code>可以释放掉非静态成员变量的<code>bitwise constness</code>约束。</p><h3 id="在const和non-const成员函数中避免重复">在const和non-const成员函数中避免重复</h3><p>为了避免<code>const</code>和<code>non-const operator[]</code>产生代码重复以及伴随的编译时间、维护、代码膨胀等，应该实现<code>operator[]</code>的功能一次并使用它两次。即必须令其中一个<code>non-const operator[]</code>调用另一个<code>const</code>兄弟，这就是<strong>常量性转除</strong>。</p><p>换而言之，当<code>const</code>和非<code>const</code>成员函数有着实质等价的实现时，令非<code>const</code>版本调用<code>const</code>版本可以避免代码重复：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>&#123;<span class="comment">// 一如既往</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)&#123;</span><br><span class="line">        <span class="comment">// 先为*this加上const以调用const op[]，再将const op[]返回值的const转除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面示例代码共有两次转型：第一次用来为<code>*this</code>添加<code>const</code>，这使得接下来调用<code>operator[]</code>时得以调用<code>const</code>版本；第二次则是从<code>const operator[]</code>的返回值中移除<code>const</code>。</p><p>注意：<code>const</code>成员函数调用非<code>const</code>成员函数是一种错误行为，因为对象会因此有可能被改动！</p><h2 id="条款04：确定对象被使用前已先被初始化">条款04：确定对象被使用前已先被初始化</h2><p>读取未初始化的值会导致不明确的行为。因此，永远在使用对象之前先将它初始化。</p><p>要为内置类型对象进行手工初始化，因为C++不保证初始化它们。至于内置类型以外的任何其它东西，初始化责任落在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p><p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，即尽量在初始化列表替换赋值动作，这样通常效率更高。因为对大多数类型而言，比起先调用默认构造函数然后再调用拷贝赋值运算符，单只调用一次拷贝构造函数是比较高效的，有时甚至高效得多。初始化列表中列出的成员变量的排列次序应该和它们在<code>class</code>中声明的次序相同。并且，如果成员变量是<code>const</code>或<code>references</code>，它们就一定需要初值，不能被赋值。</p><p>C++有着十分固定的“成员初始化次序”：基类更早于其派生类被初始化，而类的成员变量总是以其声明次序被初始化，即使它们在初始化列表中以不同的次序出现也不会有任何影响。</p><p>为免除“跨编译单元之初始化次序”问题，请以<code>local static</code>对象替换<code>non-local static</code>对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 导读</title>
      <link href="/2022/12/26/Effective-C-%E5%AF%BC%E8%AF%BB/"/>
      <url>/2022/12/26/Effective-C-%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="术语-terminology">术语(Terminology)</h2><p>​所谓声明式(<em>declaration</em>)是告诉编译器某个东西的名称和类型，但略去细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;<span class="comment">// 对象声明式</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDigits</span><span class="params">(<span class="type">int</span> number)</span></span>;<span class="comment">// 函数声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;<span class="comment">// 类声明式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// 模板声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span>;<span class="comment">// &quot;typename&quot;的使用见条款42</span></span><br></pre></td></tr></table></figure><p>​<code>size_t</code>只是一个<code>typedef</code>，是C++计算个数（例如<code>char*-based</code>字符串内的字符个数或STL容器内的元素个数等等）时用的某种不带正负号（<code>unsigned</code>）类型。它也是<code>vector</code>，<code>deque</code>和<code>string</code>内的<code>operator[]</code>函数接受的参数类型。条款3阐述当我们定义自己的<code>operator[]</code>函数时应该遵循的协议。</p><hr><p>​每个函数的声明揭示其签名式(<em>signature</em>)，也就是参数和返回类型。一个函数的签名等同于该函数的类型。</p><p>​定义式(<em>definition</em>)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此对象拨发内存的地点。对于函数或函数模板而言，定义式提供了代码本体。对于类或类模板而言，定义式列出它们的成员。</p><p>​初始化(<em>initialization</em>)是“给予对象初值”的过程。对用户自定义类型的对象而言，初始化由构造函数执行。所谓默认构造函数是一个可被调用而不带任何实参者。这样的构造函数要不没有参数，要不就是每个参数都有缺省值。</p><p>​当类的构造函数被声明为<code>explicit</code>时，这可阻止它们被用来执行隐式类型转换，但它们仍可被用来进行显式类型转换。被声明为<code>explicit</code>的构造函数通常比其<code>non-explicit</code>版本更受欢迎，因为它禁止编译器执行非预期（往往也不被期望）的类型转换。除非有一个好理由允许构造函数被用于隐式类型转换，否则一般将它声明为<code>explicit</code>。</p><p>​拷贝构造函数被用来“以同型对象初始化自我对象”，拷贝赋值运算符被用来“从另一个同型对象中拷贝其值到自我对象”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1;<span class="comment">// 调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">w1 = w2;<span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：当看到赋值符号时请小心，因为<code>=</code>语法也可用来调用拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3 = w2;<span class="comment">// 调用拷贝构造函数！</span></span><br></pre></td></tr></table></figure><p>​拷贝构造很容易和拷贝赋值有所区别：如果一个新对象被定义（例如以上语句中的<code>w3</code>），一定会有个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的<code>w1 = w2</code>语句），就不会有构造函数被调用，那么当然就是赋值操作被调用。</p><p>​拷贝构造函数是一个尤其重要的函数，因为它定义一个对象如何以值传递(<em>passed by value</em>)。以值传递意味着“调用拷贝构造函数”。<strong>注意</strong>：以值传递用户自定义类型通常是个坏主意，以引用传递(<em>passed-by-reference-to-const</em>)往往是比较好的选择，详见条款20。</p><hr><p>​<strong>不明确行为</strong>(<em>undefined behavior</em>)：由于各种因素，某些C++构件的行为没有定义，程序员无法稳定预估运行期会发生什么事。下面两个代码片段就带有“不明确的行为”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="number">0</span>;<span class="comment">// p是个null指针</span></span><br><span class="line">std::cout &lt;&lt; *p;<span class="comment">// 对一个null指针取值会导致不明确行为</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;Darla&quot;</span>;<span class="comment">// name是个数组，大小为6(别忘记最尾端的null)</span></span><br><span class="line"><span class="type">char</span> c = name[<span class="number">10</span>];<span class="comment">// 指针涉及一个无效的数组索引，这将导致不明确行为</span></span><br></pre></td></tr></table></figure><p>​不明确（未定义）行为的结果是不可预期的，很可能让人不愉快！程序会有时执行正常，有时会造成崩坏，有时更产出不正确的结果。应尽量避免不明确行为！</p><p>​程序批注中提到构造函数和析构函数时，有时会使用缩写<em>ctor</em>和<em>dtor</em>。</p><h2 id="命名习惯-naming-conventions">命名习惯(Naming Conventions)</h2><p>​参数<code>lhs</code>和<code>rhs</code>它们分别代表左手端和右手端，常常以它们作为二元操作符函数如<code>operator==</code>和<code>operator*</code>的参数名称。对于成员函数，左侧实参由<code>this</code>指针表现出来，所以有时单独使用参数名称<code>rhs</code>。</p><p>​常将“指向一个<code>T</code>型对象”的指针命名为<code>pt</code>，意思是“pointer to <code>T</code>”。</p><p>​对于引用使用类似习惯：<code>rw</code>可能是个<code>Widget</code>类型的引用，<code>ra</code>则是个<code>Airplane</code>类型的引用。</p><h2 id="关于线程-threading-consideration">关于线程(Threading Consideration)</h2><p>​<strong>线程安全性</strong>(<em>thread safety</em>)是许多程序员要面对的主题！</p><h2 id="tr1和boost">TR1和Boost</h2><p>​TR1(“Technical Report 1”)是一份规范，描述加入C++标准程序库的诸多新机能。这些机能以新的class templates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有的TR1组件都被置于命名空间tr1内，后者嵌套于命名空间std内。</p><p>​Boost是个组织，亦是一个网站(<a href="http://boost.org">http://boost.org</a>)，提供可移植、同行复审、源码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言，Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何得了解它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础教程</title>
      <link href="/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="git基本概念">git基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本</li></ul><h2 id="git常用命令">git常用命令</h2><ol><li><p><code>git config --global user.name zhanghua</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中，其中<code>HEAD</code>头指针指向<code>master</code>分支的一个节点</p></li><li><p><code>git add XX</code>：将XX文件添加到暂存区</p><p><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</p></li><li><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</p></li><li><p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将暂存区的内容提交到当前分支，并将<code>HEAD</code>指针指向该分支最新版本，注意每次<code>commit</code>后暂存区会清空</p></li><li><p><code>git status</code>：查看仓库状态</p></li><li><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p></li><li><p><code>git log</code>：查看当前分支的所有版本（截止到<code>HEAD</code>指针指向的版本）</p><p><code>git log --pretty=oneline</code>：更简洁地查看当前分支的所有版本</p></li><li><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p></li><li><p><code>git reset --hard HEAD^</code> 或<code> git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p><p><code>git reset --hard 版本号</code>：回滚到某一特定版本（使用版本号的前7个字母即可）</p></li><li><p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销（注意：<code>git restore</code>并不是恢复至上一个历史版本，而是恢复至暂存区里存的内容）</p><p><code>git restore --staged XX</code>：将XX文件从暂存区中删除</p></li><li><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p></li><li><p><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p></li><li><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</p></li><li><p><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</p><p>注意：暂存区跟分支完全独立，切换分支是不会有多个暂存区的。因此不管在哪个分支上用的都是一个暂存区和工作目录</p></li><li><p><code>git branch</code>：查看所有分支和当前所处分支</p></li><li><p><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</p></li><li><p><code>git merge branch_name</code>：将分支<code>branch_name</code>快速合并到当前分支上</p></li><li><p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p></li><li><p><code>git branch branch_name</code>：创建新分支</p></li><li><p><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><p><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</p></li><li><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</p></li><li><p><code>git checkout -t origin/branch_name</code> 将远程的<code>branch_name</code>分支拉取到本地</p></li><li><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p></li><li><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p></li><li><p><code>git stash drop</code>：删除栈顶存储的修改</p></li><li><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p></li><li><p><code>git stash list</code>：查看栈中所有元素</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-213 Data Lab</title>
      <link href="/2022/08/26/CMU15-213-Data-Lab/"/>
      <url>/2022/08/26/CMU15-213-Data-Lab/</url>
      
        <content type="html"><![CDATA[<p>Lab开始前需仔细阅读<code>bits.c</code>注释中的<code>INTEGER CODING RULES</code>内容和<code>FLOATING POINT CODING RULES</code>内容！</p><h1 id="the-puzzles">The Puzzles</h1><h2 id="bitxor">bitXor</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * bitXor - x^y using only ~ and &amp; </span><br><span class="line"> *   Example: bitXor(4, 5) = 1</span><br><span class="line"> *   Legal ops: ~ &amp;</span><br><span class="line"> *   Max ops: 14</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先介绍<strong>德摩根定律</strong>，德摩根定律在离散数学的很多场景里都出现过，它一共有两个关系：</p><ul><li><p>在命题逻辑里，可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∨</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\lor Q) \Leftrightarrow (\lnot P) \wedge (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\wedge Q) \Leftrightarrow (\lnot P) \lor (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>在集合里可以这样表示：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋃</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋂</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcup B} = \overline{A} \bigcap \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋂</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋃</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcap B} = \overline{A} \bigcup \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><ul><li><p>在布尔代数里可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x \cdot y} = \overline{x} + \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.71389em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x + y} = \overline{x} \cdot \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9777700000000003em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7833300000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.7033300000000002em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p></li></ul><p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi><mo>+</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">x \oplus y = \overline{x} \cdot y + x \cdot \overline{y} = \overline{\overline{\overline{x} \cdot y} \cdot \overline{x \cdot \overline{y}}} = \overline{(x + \overline{y}) \cdot (\overline{x} + y)} = \overline{x \cdot y + \overline{x} \cdot \overline{y}} = \overline{x \cdot y} \cdot \overline{\overline{x} \cdot \overline{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.225em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.9505600000000003em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9500000000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-3.87em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin">tmin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 4</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>将最高有效位（即符号位）置为1且其余位置为0时为补码表示下的最小整数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="istmax">isTmax</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="line"> *     and 0 otherwise </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="line"> *   Max ops: 10</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的符号位为0且其余位全为1时为补码表示的最大值，此时观察可以发现对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>加1并取反等于自己。但同时需要注意-1（补码表示为全1）加1取反后也等于自己，这种情况需要排除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alloddbits">allOddBits</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>先做一个32位的掩码<code>t32</code>，并使其每个字节均为<code>0xAA</code>，即所有奇数位bit均为1。然后先通过<code>x &amp; t32</code>取出<code>x</code>的所有奇数bit位，然后与<code>t32</code>进行异或来判断取出来的结果是否等同<code>t32</code>，等同则说明<code>x</code>的所有奇数位bit均为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t8 = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">int</span> t16 = (t8 &lt;&lt; <span class="number">8</span>) | t8;</span><br><span class="line">    <span class="type">int</span> t32 = (t16 &lt;&lt; <span class="number">16</span>) | t16;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; t32) ^ t32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate">negate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>在C语言中，对于任意整数值<code>x</code>，计算表达式<code>-x</code>和<code>~x+1</code>得到的结果完全一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isasciidigit">isAsciiDigit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="line"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="line"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="line"> *            isAsciiDigit(0x05) = 0.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 15</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先<code>0x30</code>的二进制表示为<code>0b11 0000</code>，<code>0x39</code>的二进制表示为<code>0b11 1001 </code>。</p><p>用<code>cond1</code>判断<code>x</code>的高28位是否为<code>0x0000003</code>，同时也排除掉负数情况；再用<code>cond2</code>判断将<code>x</code>加6（<code>0b0110</code>）之后第5位bit是否会因为进位由1变为0，即判断<code>x</code>的最低4位是否小于等于<code>0b1001</code>。当且仅当<code>cond1</code>和<code>cond2</code>均为1时<code>isAsciiDigit</code>返回1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0x3</span>);</span><br><span class="line">    <span class="type">int</span> cond2 = ((x + <span class="number">0x6</span>) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 &amp; cond2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="conditional">conditional</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * conditional - same as x ? y : z </span><br><span class="line"> *   Example: conditional(2,4,5) = 4</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 16</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>可以想到<code>y + z + a + b</code>的形式，当<code>x</code>为真时让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">b=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>；当<code>x</code>为假时，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">a=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。由于不用<code>-</code>负号，因此可以用<code>~y + 1</code>代替<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，剩下的问题在于如何根据<code>x</code>的真假（即最低bit位为0或1）将所有bit位置为全1或全0。第一种方法是借助算术右移的机制，此时需要先将最低bit位左移至最高符号位，但是这种方式的移位数取决于整型类型具体有多少bit位，不具有普适性。另一种方法则更巧妙，<code>!x</code>的值只有0或1两种取值，再对它取负（即按位取反再加1）后就得到0和-1，而0和-1的补码表示不正是全0和全1嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mask1 = (!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> mask2 = (!!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> a = (~y + <span class="number">1</span>) &amp; mask1;</span><br><span class="line">    <span class="type">int</span> b = (~z + <span class="number">1</span>) &amp; mask2;</span><br><span class="line">    <span class="keyword">return</span> y + z + a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = (~y + <span class="number">1</span>) &amp; b;</span><br><span class="line">    <span class="type">int</span> d = (~z + <span class="number">1</span>) &amp; ~b;</span><br><span class="line">    <span class="keyword">return</span>  y + z + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于允许使用<code>|</code>位或运算操作，因此还有简洁的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>  (y &amp; ~b) | (z &amp; b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="islessorequal">isLessOrEqual</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="line"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 24</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ol><li>首先判断<code>x</code>与<code>y</code>是否相等，它们若相等则可以直接返回1，若<code>x</code>与<code>y</code>不等，则分别取<code>x</code>和<code>y</code>的符号位<code>signX</code>和<code>signY</code>；</li><li>若<code>x</code>正且<code>y</code>负，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定不成立，因此返回0；</li><li>若<code>x</code>负且<code>y</code>正，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定成立，因此返回1；</li><li>若<code>x</code>与<code>y</code>同号，则当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>结果为负（符号位为1）时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>成立。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !(x ^ y);       <span class="comment">// x == y</span></span><br><span class="line">    <span class="type">int</span> signX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cond2 = (!signX) &amp; signY;       <span class="comment">// x正y负</span></span><br><span class="line">    <span class="type">int</span> cond3 = (signX) &amp; (!signY);     <span class="comment">// x负y正</span></span><br><span class="line">    <span class="type">int</span> res = x + (~y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;       <span class="comment">// x与y同号</span></span><br><span class="line">    <span class="type">int</span> flag = res &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 | (!cond2 &amp; (cond3 | flag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalneg">logicalNeg</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * logicalNeg - implement the ! operator, using all of </span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4 </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>不等于<code>0</code>的数字有正负的区别，若<code>x</code>不为0时，则<code>x</code>与<code>-x</code>的符号位必然异号；当<code>x</code>为0时，<code>x</code>与<code>-x</code>的符号位均为0。因此可将<code>x</code>与<code>-x</code>进行与运算，若<code>x</code>不为0，则结果的符号位为1，否则为0，再通过算术右移31位可得到全1或全0。最后再对结果加<code>1</code>正好可将全1的二进制表示转为<code>0b0</code>，将全0的二进制表示转为<code>0b1</code>，非常巧妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> negX = ~x +<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sign = (x | negX) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> sign + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howmanybits">howManyBits</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> CMU15-213 Introduction to Computer Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-213 </tag>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2300 咒语和药水的成功对数</title>
      <link href="/2022/07/26/Leetcode-2300/"/>
      <url>/2022/07/26/Leetcode-2300/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="排序-二分-o-m-n-logm">（排序+二分）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>将表示药水能量强度的数组<code>potions</code>从小到大排序；</li><li>对于每个<code>spells[i]</code>，在<code>potions</code>中二分查找到第一个大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil success / spells[i] \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">⌉</span></span></span></span>的位置，然后记录答案。</li></ol><h2 id="时间复杂度">时间复杂度</h2><p>对<code>potions</code>数组排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>；对每个咒语的能量强度<code>spells[i]</code>均需要在<code>potions</code>数组中做一次二分，二分时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，故总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h2 id="空间复杂度">空间复杂度</h2><p><code>sort</code>排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的系统栈空间。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = spells.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = success / spells[i];</span><br><span class="line">            <span class="keyword">if</span> (success % spells[i]) t++;</span><br><span class="line">            res[i] = potions.<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 873 最长的斐波那契子序列的长度</title>
      <link href="/2022/07/09/Leetcode-873/"/>
      <url>/2022/07/09/Leetcode-873/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="线性dp-o-n-2">（线性DP）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>本题是最长上升子序列问题的变形。<br>由于斐波那契序列要求新加入的数是前两个数之和，假设新加入斐波那契数列的数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且其前两项分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，因此动态规划的状态定义仅需两维。</p><ol><li>状态定义：用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示最后一个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且倒数第二个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的最长斐波那契式的子序列长度；</li><li>状态计算：根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>可计算出斐波那契序列中倒数第三项的预期值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>已在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>之前出现过，则更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = max(f[i][j], f[j][k] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ol><p>注意如果最后不存在斐波那契式的子序列需要返回0。</p><p>状态定义为两维，状态转移的计算开销为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，算法总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            pos[arr[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> x = arr[i] - arr[j];</span><br><span class="line">                f[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; arr[j] &amp;&amp; pos.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                    <span class="type">int</span> k = pos[x];</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[j][k] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">3</span> ? res : <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1217 玩筹码</title>
      <link href="/2022/07/08/Leetcode-1217/"/>
      <url>/2022/07/08/Leetcode-1217/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/">1217. 玩筹码 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="找规律-o-n">（找规律）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4><p>筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，而筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此可总结出三条性质：</p><ol><li>筹码在偶数位置间移动无需代价；</li><li>筹码在奇数位置间移动也无需代价；</li><li>将一个筹码在偶数位置与奇数位置间转移的代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ol><p>所以针对本题，首先需要分别统计位于奇数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>和位于偶数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>，而最终只有两种情况：</p><ol><li>将所有筹码全部放置在某个偶数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>；</li><li>将所有筹码全部放置在某个奇数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>。</li></ol><p>两种情况最小值即为将所有筹码移动到同一位置上所需要的最小代价。</p><p>算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : position)</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span>) odd++;</span><br><span class="line">            <span class="keyword">else</span> even++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 4 寻找两个正序数组中的中位数</title>
      <link href="/2022/05/08/Leetcode-4/"/>
      <url>/2022/05/08/Leetcode-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组中的中位数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="递归-o-log-m-n">（递归）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></h4><p>问题的本质是在两个有序数组中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>小数，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时即可找出中位数。<br>为了便于后续分析，首先假定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素的数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素的数量。分别从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中各自取出前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个元素进行比较：</p><ol><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &gt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过多，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过少，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数;</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &lt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过少，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过多，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数。当出现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列中元素数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>的边界情况时，记得数组访问不能越界<code>si = min(i + k / 2, int(nums1.size()))</code>。</li></ol><h4 id="时间复杂度">时间复杂度</h4><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>即可找出中位数，并且每次递归时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的规模都会减半，因此总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() - i &gt; nums2.<span class="built_in">size</span>() - j)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span> (i == nums1.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">        <span class="type">int</span> si = <span class="built_in">min</span>(i + k / <span class="number">2</span>, <span class="built_in">int</span>(nums1.<span class="built_in">size</span>())), sj = j + k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[si - <span class="number">1</span>] &gt; nums2[sj - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, i, nums2, sj, k - k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, si, nums2, j, k - (si - i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 52 N皇后 II</title>
      <link href="/2022/05/04/Leetcode-52/"/>
      <url>/2022/05/04/Leetcode-52/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案数。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u - i + depth] &amp;&amp; !udg[u + i])&#123;</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">                res += <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 51 N皇后</title>
      <link href="/2022/05/04/Leetcode-51/"/>
      <url>/2022/05/04/Leetcode-51/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">51. N皇后 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后<code>path[u][i]='Q'</code>，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg, path</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg; </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        path = <span class="built_in">vector</span>&lt;string&gt;(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[i - u + depth] &amp;&amp; !udg[i + u])&#123;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">true</span>;</span><br><span class="line">                path[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 恢复现场</span></span><br><span class="line">                path[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 59 螺旋矩阵 II</title>
      <link href="/2022/05/04/Leetcode-59/"/>
      <url>/2022/05/04/Leetcode-59/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-n-2">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>矩阵中每个位置仅遍历一次，所以总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++)&#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n || res[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 54 螺旋矩阵</title>
      <link href="/2022/05/04/Leetcode-54/"/>
      <url>/2022/05/04/Leetcode-54/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-nm">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>定义二维bool数组<code>st</code>表示该位置是否被访问过;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>每个位置仅遍历一次，且寻找方向的时间复杂度是常数，故总时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度">空间复杂度</h4><p>需要额外<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的空间存储<code>st</code>数组。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || st[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span> ) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 191 位1的个数</title>
      <link href="/2022/05/03/Leetcode-191/"/>
      <url>/2022/05/03/Leetcode-191/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="位运算-o-1">（位运算）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>在整数的补码表示中，<code>-x</code>等价于<code>~x+1</code>，<code>lowbit(x)=x &amp; -x </code>可以返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>二进制表示下的最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此可以每次减掉<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>二进制表示下最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>减到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>为止。</p><p>时间复杂度分析：总共最多进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>次操作，每次操作的计算量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            n -= <span class="built_in">lowbit</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">lowbit</span><span class="params">(<span class="type">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/01/hello-world/"/>
      <url>/2022/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
