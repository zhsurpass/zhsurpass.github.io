<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《计算机架构性能评估方法》第四章 分析性能建模</title>
      <link href="/2024/11/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E3%80%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E5%BB%BA%E6%A8%A1/"/>
      <url>/2024/11/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E3%80%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机架构性能评估方法-第四章-分析性能建模">《计算机架构性能评估方法》第四章 分析性能建模</h1><blockquote><p>Copyright © 2010 by Morgan &amp; Claypool<br>All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in<br>any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations in<br>printed reviews, without the prior permission of the publisher.<br>Computer Architecture Performance Evaluation Methods<br>Lieven Eeckhout<br><a href="http://www.morganclaypool.com">www.morganclaypool.com</a><br>ISBN: 9781608454679 paperback<br>ISBN: 9781608454686 ebook<br>DOI 10.2200/S00273ED1V01Y201006CAC010<br>A Publication in the Morgan &amp; Claypool Publishers series<br>SYNTHESIS LECTURES ON COMPUTER ARCHITECTURE<br>Lecture #10<br>Series Editor: Mark D. Hill, University of Wisconsin<br>Series ISSN<br>Synthesis Lectures on Computer Architecture<br>Print 1935-3235 Electronic 1935-3243</p></blockquote><p>分析性能建模是一种重要的性能评估方法，在过去几年中得到了越来越多的关注。与流行的仿真方法相比，分析建模可能不太准确，但它比仿真快好几个数量级：甚至可以立即获得性能估计结果，因为这就是一个计算有限数量公式的问题，最多几秒钟或者几分钟内就可以完成。仿真则很可能花费数小时、数天甚至数周的时间。</p><p>由于其巨大的速度优势，分析建模可以非常快速地探索巨大的架构设计空间，这使其在设计周期的早期阶段非常有用，甚至可以探索难以通过仿真探索的巨大设计空间。换句话说，分析建模可用于快速识别感兴趣的区域，然后通过仿真对其进行更详细的探索。<em>Lee</em>和<em>Brooks</em>所做的一项研究说明了分析建模在探索大型设计空间方面的力量，该研究探索了自适应微架构的潜力，它同时改变了微架构的适应性和适应的时间粒度——这是一项通过详细的周期精确的仿真无法实现的研究。</p><p>此外，分析建模提供了更多基本的洞察力。虽然仿真也提供了有价值的见解，但它需要许多仿真来理解性能对设计参数的敏感性。相反，在分析建模中，灵敏度可以从公式本身看出来。比如<em>Hill</em>和<em>Marty</em>将<em>Amdahl</em>定律扩展到多核处理器。他们用一个简单的硬件<em>cost model</em>增强了<em>Amdahl</em>定律，并探讨了对称(同质)、非对称(异构)和动态多核处理的影响。尽管它很简单，但它提供了基本的见解，并揭示了多核时代的各种重要后果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机架构性能评估方法》第五章 仿真</title>
      <link href="/2024/11/06/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/11/06/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机架构性能评估方法-第五章-仿真">《计算机架构性能评估方法》第五章 仿真</h1><blockquote><p>Copyright © 2010 by Morgan &amp; Claypool<br>All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in<br>any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations in<br>printed reviews, without the prior permission of the publisher.<br>Computer Architecture Performance Evaluation Methods<br>Lieven Eeckhout<br><a href="http://www.morganclaypool.com">www.morganclaypool.com</a><br>ISBN: 9781608454679 paperback<br>ISBN: 9781608454686 ebook<br>DOI 10.2200/S00273ED1V01Y201006CAC010<br>A Publication in the Morgan &amp; Claypool Publishers series<br>SYNTHESIS LECTURES ON COMPUTER ARCHITECTURE<br>Lecture #10<br>Series Editor: Mark D. Hill, University of Wisconsin<br>Series ISSN<br>Synthesis Lectures on Computer Architecture<br>Print 1935-3235 Electronic 1935-3243</p></blockquote><p>仿真是计算机体系结构中普遍使用的性能评估方法。它被广泛使用有以下几个原因：</p><ol><li>分析建模方法尽管评估速度非常快，并且提供了深刻的洞察力，但对于架构师需要做出很多的设计决策而言引入了太多的不准确性。分析建模对于制定高层次设计决策和在庞大设计空间中识别感兴趣的区域非常有价值，然后使用分析建模方法很难评估各种设计方法导致的细微性能变化。</li><li>另一方面，硬件原型虽然非常准确，但开发起来非常耗时且昂贵。</li></ol><p>仿真器<em>sinmulator</em>是处理器体系架构的性能模型软件。仿真器所建模的处理器架构称为目标架构，在物理机器上运行仿真器就能得到性能结果。相较于构建硬件原型相比仿真有着非常重大优势，它开发相对便宜，并且通常比分析建模要准确得多。此外，仿真器非常灵活且易于参数化，这样便于探索架构设计空间，评估一个新颖的设计想法，这对于计算机架构师设计一个处理器和相关的研究者而言是非常重要的特性。比如，可以通过参数化，比如改变仿真器某些参数并在各种<em>benchmark</em>上跑仿真就能评估<em>cache</em>大小、延迟、处理器带宽和分支预测器的影响，评估出一个架构特性所带来的影响。仿真甚至能对当今非常不同的体系架构进行评估。</p><h2 id="5-1-计算机架构师的工具箱">5.1 计算机架构师的工具箱</h2><p>仿真有很多方法，每种方法代表了在准确性、评估时间、开发时间和覆盖范围间进行取舍。精度是指仿真模型相较于真实硬件的保真度，评估时间是指跑一次仿真需要多长时间，开发时间是指开发仿真器的所需时间，最后覆盖范围是指仿真器能探索的设计空间大小，例如一个<em>cache</em>仿真器仅能被用于评估计算机<em>cache</em>性能，而不是处理器的整体性能。</p><p>仿真器的权衡/取舍可以描述为图5.1所示的菱形，每种仿真方法或者一般的建模工作都可以按照这四个维度进行表征描述。这些维度不是彼此相互独立的，事实上它们是相互矛盾的。例如，通过建模附加特性可以对真实硬件进行更忠实地建模，这样增加了仿真器的覆盖范围，提高了仿真的准确度，但同时也增加了仿真器的开发时间和评估时间，因为仿真器将构建得更加复杂，并且由于增加的复杂度，会导致仿真跑得更慢执行时间更长。相反，如果一个仿真器仅对整个系统的一个组件进行建模，比如针对分支预测器或者<em>cache</em>，虽然相较于整个系统覆盖范围有限，但由于其相对简单且跑起来很快，开发时间和评估时间就会短，对于研究的组件的准确度就会很高非常有价值。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20241106014117.jpg" alt=""></p><p>后续部分会描述计算架构师工具箱中常用的几种仿真技术，每种仿真技术代表了在准确性、覆盖率、开发时间和评估时间方面的不同权衡取舍。表5-1总结了四个维度上不同的仿真技术。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241110-210115.jpg" alt=""></p><h2 id="5-2-功能性仿真">5.2 功能性仿真</h2><p>功能性仿真只对一个指令集架构<em>ISA</em>的功能特性进行建模，它不提供任何的时间估计。即任何一时刻仅仿真一个指令，获得输入值然后计算输出值。因此，功能性仿真器也被称为指令集模拟器。这些工具通常对于验证设计的正确性非常有用，而不适用于评估它的性能特征。所以，关于性能和实现细节的准确度和覆盖率是不适用的。然而，功能性仿真在开发时效方面很优秀，因为在硬件项目开发时通常已经就存在了功能仿真器，除非处理器实现了一套全新的指令集。功能仿真器具有很长的生命周期，它可以跨越许多开发项目。功能性仿真在评估时间方面很快，因为不需要对微架构特性进行建模。功能仿真器的例子是<em>sim-safe</em>和<em>sim-fast</em>。</p><h3 id="插桩">插桩</h3><p>功能仿真的另一种选择是插桩，也被称作直接执行。检测获取一个二进制文件并向其中添加代码，以便在实际硬件上运行经过插桩的二进制文件时收集感兴趣的属性。例如，如果目标是生成内存地址的追踪，则只需对可执行二进制文件中引用内存的每个指令进行检测，然后在本机硬件上运行经过插桩的二进制可执行文件就能得到对内存地址的追踪。插桩相较于功能性仿真的优势在于它带来的开销更小。插桩在真实硬件上本地执行所有指令，相反功能性仿真模拟所有指令因此每条目标指令会执行更多的主机指令。存在两种检测类型：静态插桩只静态地插桩二进制文件；动态插桩在运行时动态地插桩运行的二进制机器指令。静态插桩的例子是<em>Atom</em>和<em>EEL</em>，而<em>Embra</em>、<em>Shade</em>和<em>Pin</em>支持动态插桩。与功能性仿真相比，插桩的局限性在于目标指令集架构通常与主机的指令集架构相同，因此插桩框架不容易移植。就像<em>Shader</em>框架中所做的那样，动态插桩二进制翻译器可以将主机指令集架构的指令翻译成目标指令集架构的指令来解决这个问题。但是，仿真器只能在实现了目标指令集架构的机器上运行。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241110-214436.jpg" alt=""></p><p><em>Burtscher</em>和<em>Ganusov</em>提出了一种将插桩的速度和功能性仿真的可移植性相结合的方法，参见图5.2。他们提出一个功能性仿真器合成器，它将一个二进制可执行文件以及一个包含所有支持指令的C定义代码片段的文件作为输入，然后合成器将二进制指令翻译成C语句。如果需要，用户可以添加模拟代码来收集比如指令或地址的追踪。编译合成后C代码生成定制的功能仿真器。</p><h3 id="操作系统的影响">操作系统的影响</h3><p>功能性仿真通常仅限于用户级代码，比如应用程序和系统库代码，然而它并不能仿真模拟操作系统调用或中断时发生的情况。为了获得功能正确的执行，需要仿真模拟影响应用代码的操作系统影响。一种常见的方法是忽略中断并模拟操作系统调用的效果。仿真模拟系统调用通常是通过手动识别系统调用的输入寄存器、输出寄存器和内存状态，并本地调用系统调用来完成。对于每个系统调用都需要这么做，这是一项繁琐且费力的工作，特别是当希望将一个仿真器移植到新版本的操作系统或者非常不一样的操作系统上。</p><p><em>Narayanasamy</em>等人提出了一种自动捕捉操作系统交互副作用的技术，一个插桩的二进制代码收集每个执行的系统调用、中断和DMA传输，记录它如何改变寄存器状态和内存状态。只有当内存位置稍后被一个<em>load</em>操作读时才会记录内存状态的改变。具体是按如何方式做的：插桩的二进制代码维护应用程序地址空间的一份用户级副本。操作系统的影响诸如系统调用、中断和DMA传输，只会影响应用程序的地址空间，而不是用户级的副本。应用程序的写操作更新了应用程序的地址空间和用户级的副本。应用程序的读操作会验证在应用程序地址空间读到数据是否与用户级副本中读到的数据匹配，如果不匹配仿真器就判定是由于操作系统的影响导致应用程序状态的改变，因此它知道需要记录应用程序地址空间中的负载值，这些状态变化存储在一个称为操作系统影响的日志中。在功能性仿真期间，当触发一个系统调用时会读取操作系统影响日志，日志中记录的状态改变会重放一遍，即修改仿真模拟的寄存器和内存状态以模拟系统调用带来的影响。因为这个过程不依赖于系统调用的语义，它是完全自动的，这就简化了开发和移植用户级仿真器。这个技术的副作用是它支持确定性的仿真，即操作系统的影响在运行时是相同的。虽然这样有助于比较不同的设计方案，但它也有缺陷，将在5.6.2节中讨论。</p><h2 id="5-3-全系统仿真">5.3 全系统仿真</h2><p>用户级仿真对于一些工作负载<em>workload</em>已经足够准确了，比如<em>SPEC CPU benchmarks</em>花费很少时间执行系统级代码，因此将仿真模拟限制为用户级代码就足矣了。然而对于其它的工作负载<em>workload</em>，比如商业工作负载数据库服务器、web服务器、电子邮件服务器等等，对它们仅仅仿真模拟用户级代码是明显不够的，因为这些工作负载<em>workload</em>花费了相当多的时间执行系统级代码，因此这些工作负载<em>workload</em>需要全系统仿真模拟。此外，多核硬件的激增增加了全系统仿真的重要性，因为多线程负载<em>workload</em>性能会收到操作系统调度决策的影响，不对操作系统进行仿真模拟可能导致不准确的性能指标，因为这样没有考虑操作系统的影响。</p><p>全系统仿真是指仿真模拟整个计算机系统，这样使得完整的软件栈能跑在仿真模拟器上。软件栈包括应用程序以及未修改的商业操作系统，这样仿真包括IO和操作系统活动，其次是处理器和内存活动。换言之，全系统仿真可以被看做是一个系统仿真模拟器或者一个系统虚拟机，它对用户来说就是虚拟硬件，它给全系统仿真模拟器的用户提供了就像跑在真实硬件上的假象。比较知名的全系统仿真模拟器例子有<em>SimOS</em>、<em>SimICs</em>、<em>SimNow</em>、<em>M5</em>、<em>Bochs</em>、<em>QEMU</em>和<em>Mambo</em>。</p><p>全系统仿真模拟器提供的功能与用户级功能仿真模拟器基本相同，两者都是提供对动态执行指令的追踪，唯一的区别是功能仿真模拟器只仿真用户级代码指令，而全系统仿真模拟器要同时仿真模拟用户级和系统级代码。因此与用户级仿真相比，全系统仿真实现了更大的覆盖范围，然而开发一个全系统仿真器远非易事。</p><h2 id="5-4-专门追踪驱动仿真">5.4 专门追踪驱动仿真</h2><p>专门追踪驱动的仿真采用指令和地址跟踪，这些追踪可能只包括用户级指令，也可能同时包括用户级和系统级指令，来孤立地仿真目标架构的特定组件，比如<em>cache</em>或者分支预测器。性能表现通常以未命中率来评估。有很多被广泛使用的工具，特别是对于<em>cache</em>仿真有<em>Dinero IV</em>。此外，针对在一次仿真模拟运行中仿真多个<em>cache</em>配置已经提出了几条建议。虽然开发时间和评估时间都很好，但覆盖范围比较有限，因为只对一个处理器的特定组件进行了建模。而且虽然未命中率指标的准确性很好，但由于许多其它因素的影响，处理器整体性能仅与这些未命中率大致相关。专门的跟踪驱动仿真在工具箱中仍占有一席之地，因为它提供了一种评估处理器特定层面的一种轻松方法。</p><h2 id="5-5-追踪驱动仿真">5.5 追踪驱动仿真</h2><p>完整的追踪驱动仿真，或者简称未追踪驱动仿真，采用程序指令和地址追踪，并将完整的<em>benchmark</em>追踪提供给详细的微架构时序仿真模拟器。一个追踪驱动仿真器将功能仿真与时序仿真分离开来。这通常很有用，因为功能仿真只需要执行一次，而在评估不同微架构时详细的时序仿真要执行很多次。这种分离一定程度上减少了评估时间。总的来说，完整的追踪驱动仿真需要很长的开发时间，也需要很长的仿真执行时间，但它在准确性和覆盖率上都非常好。</p><p>这种方法的一个明显缺点是需要存储追踪文件，对于当前的基准测试和运行时间合唱的计算机程序而言，追踪文件可能非常大。虽然现在磁盘空间已经非常便宜，但是可以使用追踪压缩来解决这个问题，针对计算机追踪压缩已经提出了几种方法。</p><p>现代超标量处理器的另一个缺点是它们预测分支并推测地执行很多指令，沿着错误预测的推测执行指令后续将被取消。这些无效的指令不会显示在通过功能性仿真生成的追踪文件中，尽管它们可能影响<em>cache</em>或预测器的内容。因此追踪驱动仿真并不能准确地仿真模拟出沿着错误预测路径的影响。</p><p>模拟多线程工作负载<em>workload</em>时的另一个限制是追踪驱动仿真不能对线程间次序和目标微架构进行建模。原因是追踪是固定的，并且施加了特定的顺序。对于一些研究，这种影响可能是有限的，然而对于其它研究来说，这可能是重要的。这一切都取决于优化的类型和评估的工作负载。关键问题是某些微架构的变化，例如分支预测器、<em>cache</em>、预取器等，甚至是很小的变化就可能导致线程以不同的顺序获取锁。这可能会导致共享资源，比如缓存、内存、互联网络等出现不同的冲突和争用行为，进而影响线程的交错并行。因此，即使是微体系结构中的微小变化也可能导致非常不同的性能数字，并且这些变化可能对于特定的基准测试出现巨大差异，所以一个特定基准测试的大变化可能不能代表其它工作负载。由于追踪驱动仿真模拟的时单个线程次序，它并不能捕捉这些影响。此外，追踪可能反映甚至可能不会出现在目标微体系结构上的特定次序。</p><h2 id="5-6-执行驱动仿真">5.6 执行驱动仿真</h2><p>与追踪驱动仿真相比，执行驱动仿真结合了功能仿真和时序仿真。为了做到这一点，它消除了追踪驱动仿真的缺点，即不需要存储追踪文件，可以准确地模拟推测执行的指令，并且可以准确地建模多线程工作负载。由于以上这些原因，执行驱动仿真已经成为实际上常用的仿真方法。执行驱动的仿真器有<em>SimpleScalar</em>、<em>RSIM</em>、<em>Asim</em>、<em>M5</em>、<em>GEMS</em>、<em>Flexus</em>和<em>PLTSim</em>。尽管执行驱动仿真相比于追踪驱动仿真实现了更高的准确度，但它是以增加开发时间和评估时间为代价的。</p><h3 id="5-6-1-分类">5.6.1 分类</h3><p><em>Manuer</em>等人针对执行驱动仿真器提出了一种有用的分类方法，参见图5.3。该分类方法反映了四种不同的方式来耦合功能和时序组件，以管理仿真器的复杂性和开发时间。一个紧密集成功能和时序组件的执行驱动仿真器，因此被称为集成的执行驱动仿真器(见图5.3a)，显然更难以开发和维护。一个集成仿真器并不灵活，难以扩展(比如在评估新的体系架构时)，并且存在潜在的风险就是修改时序组件可能意外地往功能组件中引入错误。此外，如前所述，功能模型往往变化很小，然而，在架构探索的过程中时序模型可能会发生很大的变化。因此，从仿真器的复杂性和开发的角度来看，将功能部分与时序部分解耦开是可取的。现在讨论的解耦方法有很多种：</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241117-223327.jpg" alt=""></p><p><strong>时序驱动仿真</strong></p><p>时序驱动仿真器允许时序仿真器驱动功能仿真器去沿着错误预测的路径获取指令，并选择特定的线程交错(图5.3b)。<em>Asim</em>就是一个时序驱动的仿真器。功能模型跟踪体系结构的状态，比如寄存器和内存值。时序模型没有值的概念，相反它从功能模型中获取有效地址，并使用它来确定缓存是否命中，访问分支预测器等。功能模型可以被视为时序模型调用的一系列函数调用，以便在精确的模拟时间执行特定的功能任务。需要组织功能模型以使其能够部分地模拟指令。特别是功能仿真器需要解码、执行、执行内存操作(访存)、终止和提交指令的能力。然后时序模型会调用功能模型来在正确的时间以正确的顺序执行特定的任务。例如，当仿真在一个加载单元上执行<code>load</code>指令时，时序模型会要求功能模型计算<code>load</code>的有效地址。然后将这个地址发送回时序模型，该模型随后会确定这个<code>load</code>指令是否会发生一次<em>cache</em>未命中。根据时序模型，只有当<em>cache</em>命中访问返回或者<em>cache</em>未命中从内存返回时，功能仿真器才会从内存读取该值。这确保<code>load</code>指令读取到与目标体系结构完全相同的数据。当<code>load</code>提交进目标体系架构时，指令也同样提交进功能模型中。功能模型还跟踪足够的内部状态，以便在发现指令沿着错误预测路径执行时可以在功能模型中终止该指令。</p><p><strong>功能优先仿真</strong></p><p>在功能优先仿真模型(图5.3c)中，功能仿真器将指令追踪输入时序仿真器。这类似于追踪驱动仿真，不同之处在于追踪不需要存储在磁盘上；追踪可以通过Unix管道从功能仿真器传送到时序仿真器。</p><p>为了能够沿着错误预测路径进行仿真，并对时序相关的线程间顺序和依赖关系进行建模，功能模型提供了回滚来恢复之前的状态。特别是在执行分支时，功能模型不知道分支是否被错误预测——只有时序仿真器知道——因此，它将只执行正确路径的指令。当时时序仿真器在取指阶段检测到错误预测分支时，功能仿真器需要重定向去沿着错误预测分支获取指令。这要求功能仿真器回滚到分支之前的状态，并沿着错误预测的分支路径向时序仿真器提供指令。在时序模型中解决了错误预测的分支后，功能模型需要再次回滚，然后开始向时序模型提供正确路径的指令。换言之，功能模型正在推测分支分支将采取的路径，即它推测该分支将被时序模型正确地预测。</p><p>如前所述，线程间依赖肯呢个取决于时序，也就是说时序的微小变化可能会改变线程获取锁的顺序，从而可能改变功能和性能。这也适用于功能优先的仿真器：功能模型和时序模型之间的计时可能不同，因此功能模型获取锁的顺序不一定与时序模型中观察到的顺序相同。这个排序问题基本上归结为<code>load</code>是否在功能和时序模型中读取相同的数据。因此，功能优先仿真可以通过跟踪功能模型和时序模型中读取到的数据来处理这个顺序问题。仿真器让功能模型提前运行，但是当时序模型检测到在目标体系结构中读取的数据将与和功能模型中读取的数据不同时，它会回滚模型，并请求功能模型使用正确的数据重新执行<code>load</code>指令，这称为推测功能优先仿真。解决顺序问题的代价是在时序仿真器中跟踪目标内存状态，并比较功能仿真器和时序仿真器的数据。</p><p><em>Argollo</em>等人提出了<em>COTSon</em>仿真基架，该设施采用AMD的<code>SimNow</code>功能仿真器将指令跟踪发送至时序仿真器。<em>COTSon</em>的主要重点是去模拟复杂的基准测试，比如商用操作系统和多层应用，以及向外扩展和仿真模拟大核心数。为了管理仿真器复杂度并提高仿真速度，<em>COTSon</em>不提供回滚功能，而是实现时序反馈，这使得时序仿真器可以调整功能仿真器的速度以反映时序估计。</p><p>综上所述，功能优先仿真的关键优势在于它允许功能仿真器在时序仿真器之前运行，并利用并行性，即并行运行功能和时序仿真器。相较于时序驱动仿真(时序模型在每个指令/周期驱动功能模型)，功能优先仿真提高了仿真器的性能，比如减少了评估时间，并降低了整个仿真器的复杂性。</p><p><strong>时序优先仿真</strong></p><p>时序优先仿真使时序模型先于功能模型运行，见图5.3。除了微体系结构状态之外，时序仿真器还对体系结构的特性(寄存器和内存状态)进行了建模，大部分都是正确的。这允许沿着错误预测的分支准确地建模推测性执行，以及线程间事件的顺序。当时序模型提交指令时，即当指令变为非推测性时，功能模型验证时序仿真器是否偏离了功能模型。当时序仿真器出现偏差时，由功能仿真器进行修复。这意味着在重新启动时序仿真器之前，体系结构状态将被重新加载，微体系结构状态将被重置。换句话说，时序优先仿真由一个几乎正确集成了的执行驱动仿真器(时序仿真器)组成，该仿真器由一个功能正确的功能仿真器检查。</p><p>时序优先仿真器比完全集成的仿真器更容易开发，因为时序仿真器不需要实现所有指令。指令子集对性能很重要，并且很好地涵盖动态执行的指令就足够了。与时序驱动仿真相比，时序优先仿真对功能仿真器的要求较少，而对时序仿真器的要求较多。</p><h3 id="5-6-2-处理非确定性">5.6.2 处理非确定性</h3><p>在执行驱动仿真器上模拟多线程工作负载时，必须处理的一个重要挑战是不确定性——<em>Alameldeen</em>和<em>Wood</em>对不确定性进行了全面的评估。不确定性指的是这样一个事实，即很小的时间变化可能导致从相同初始状态开始的执行遵循了不同的执行路径。非确定性在真实硬件和仿真中都存在。在实际硬件上，时序变化有各种来源，例如中断、I/O、与直接内存访问(DMA)的总线争用、DRAM刷新等。在比较体系架构设计方案时，还可以在仿真过程中观察到非确定性。例如，可能有雨多种原因，某些设计参数的更改(例如缓存大小、缓存延迟、分支预测器配置、处理器宽度等)可能导致不确定性。</p><ul><li>操作系统可能在不同的运行过程中做出不同的调度决策。例如，调度量可能在一次运行中在I/O事件之前结束，而在另一次运行中则不会结束。</li><li>线程可能以不同的顺序获得锁。这可能导致执行自旋锁循环指令所花费的周期和指令数在不同的体系结构中有所不同。</li><li>以不同相对速度运行的线程可能会导致不同的缓存一致性流量以及共享资源中的冲突行为。例如，共享多核缓存中的冲突行为在不同的架构设计中可能是不同的；同样，互连网络中的争用也可能不同。</li></ul><p>在架构探索过程中，不确定性使得比较不同设计方案变得非常复杂。时间差异可能导致仿真的<em>workload</em>由不同的性能特征采取不同的执行路径。因此很难比较不同的设计方案。如果执行路径的变化差异很重要，比较仿真就变得不可靠了，因为在不同的执行中完成的工作量和类型是不同的。最基本的问题是，在不同的设计方案之间观察到的性能差异是由于设计方案差异还是由于执行<em>workload</em>差异导致的。不解决这个问题可能会导致不正确的结论。</p><p><em>Alameldeen</em>和<em>Wood</em>提出了一个简单的实验，清晰地说明了在仿真中处理不确定性的必要性。他们考虑OLTP工作负载<em>workload</em>，并观察到性能随着内存访问时间的增加而增加，例如84-ns DRAM的性能比81-ns DRAM的性能提高7%。当然，这是没有意义的——没有一个计算机架构师会得出内存越慢性能越好的结论。尽管这个结论在这个简单的实验中是明显的，但在更复杂、更不直观的设计研究中可能不那么明显。对于如何处理不确定性，有三种可能的解决方案。</p><p><strong>长时间跑仿真</strong></p><p>一种解决方案是仿真足够长的时间，比如仿真模拟几分钟而不是几秒钟。不确定性可能在长期仿真模拟实验中基本被消除，然而考虑到计算机架构仿真非常缓慢，这个方法在实践中并不可行。</p><p><strong>消除不确定性</strong></p><p>第二种方法就是消除不确定性。<em>Lepak</em>等人和<em>Pereira</em>等人提出了在执行驱动仿真器上仿真不同架构配置时提供多线程程序可再现行为的方法；<em>Lepak</em>等人考虑的是全系统仿真，而<em>Pereira</em>等人关注的是用户级仿真。这些方法通过保证执行相同的执行路径来消除不确定性：它们通过引入人工熄火(突然中断)来强制跨仿真的共享内存访问顺序相同；此外，在仿真过程中，中断被强制触发在特定的点上。<em>Lepak</em>等人和<em>Pereira</em>等人的方法都提出了一个度量指标和方法来量化执行在多大程度上被迫是确定性的。引入熄火意味着在每个仿真中要完成相同数量的工作；因此，可以基于单个仿真比较不同的设计方案。强制确定性的缺陷在于它可能导致在真实系统中可能永远不会发生的执行。换句话说，对于易受不确定性影响的工作负载<em>workload</em>，这个方法可能没有用处。因此，正如<em>Lepak</em>等人所承认的那样，必须谨慎使用确定性仿真。</p><p>注意，跟踪驱动的仿真还完全消除了不确定性，因为跟踪中的指令在不同的系统中是完全相同的。然而，跟踪驱动的仿真也受到同样的限制：它不能恰当地评估影响线程交互的体系结构设计。</p><p><strong>统计方法</strong></p><p>第三种方法是使用(经典的)统计方法得出有效确凿的结论。<em>Alameldeen</em>和<em>Wood</em>提出在仿真过程中人为地注入小的时间变化。更具体地说，他们通过在DRAM访问延迟中添加0到4 ns之间的均匀分布随机数，以在内存系统定时中注入微小的变化。这些随机注入的扰动产生了从相同初始条件开始的一系列可能的执行——注意，仿真器是确定性的并且将总是产生相同的时间，因此需要引入随机扰动。然后他们多次运行仿真，并计算这些运行的平均值及其置信区间。</p><p>这种方法的一个明显缺点是它需要多次运行仿真，这延长了总仿真时间。与消除不确定性的方法相比，这个方法更加耗时。但是，这是通过仿真获得可靠性能数值的最佳方法。此外，运行多个(小型)仿真可能比执行一个长时间仿真更节省时间。</p><h2 id="5-7-模块化仿真基架">5.7 模块化仿真基架</h2><p>周期精确的仿真器是极其复杂的软件，与它们所建模的微架构相当。与任何其他大型软件项目一样，确保良好的软件结构对于保持开发过程的可管理性至关重要。模块化和可复用性是提高模型开发的可管理性和速度的两个关键目标。模块化指的是将性能建模问题分解为可以单独建模的更小的部分。可复用性是指在不同的应用环境中复用不利的组件。模块化和可复用性提供了很多好处，它提高了建模效率和性能模型的保真度(因为单个组件可能已经在不同的上下文中使用和验证过)；它允许跨项目共享单个组件，甚至在生产环境中跨产品和代际；它促进了体系架构实验，比如可以很容易地交换组件同时保持其余的性能模型不变。有所的这些好处都会缩短整体的开发时间。</p><p>一些仿真基础设施实践了模块化原则，例如<em>Asim</em>，<em>Liberty</em>，<em>MicroLib</em>，<em>UNISIM</em>和<em>M5</em>。模块化仿真基础设施通常提供一个仿真器基础设施，用于创建多个性能模型而不是仅有一个性能模型。<em>Asim</em>特别考虑了作为基础软件组件的模块。模块代表目标设计的物理组件(例如，缓存，分支预测器等)或硬件算法的操作(例如，缓存替换策略)。每个模块提供一个良好定义的接口，支持模块复用。开发人员可以为仿真基础设施贡献新的模块，只要他们实现模块接口，比如分支预测器应该实现分支预测器的三种方法：获得分支预测，更新分支预测器和处理错误预测的分支。<em>Asim</em>附带了架构师工作台，允许通过选择和连接模块来组装性能模型。</p><h2 id="5-8-仿真加速的需要">5.8 仿真加速的需要</h2><p>周期精确的仿真非常缓慢，这是当今架构研究和研发中的一个关键问题。最根本的原因是正在建模的微架构非常复杂。今天的处理器由数亿甚至数十亿个晶体管组成，它们实现了复杂的功能，如内存层次结构、推测执行、乱序执行、预取等。此外，多核处理的趋势进一步加剧了这个问题，因为现在需要模拟多核以及它们在共享资源中的相互作用。如此庞大的晶体管数量导致了一个非常大而复杂的设计空间，需要在新的微架构的设计周期中进行探索。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241121-013208.jpg" alt=""></p><p>虽然直觉和分析建模可以帮助指导设计过程，但最终架构师必须依赖详细的周期精确仿真，以便在这个复杂的设计空间中做出正确的设计决策。微体系结构的复杂性明显地反映在性能模型的复杂性和速度上。周期精确的仿真模型非常慢。<em>Chiou</em>等人概述了当今仿真器的典型仿真速度，参见表5.2。学术界的仿真器的速度范围在69 KIPS和740 KIPS之间，它们通常比在1 KHz到200 KIPS速度范围内运行的工业界仿真器更快。换句话说，仅仿真(目标系统的)一秒钟的实时时间可能会耗费数小时甚至数天的仿真时间，即使是在当今最快的机器上运行的最快的仿真器上也是如此。这只是仿真一个设计点。架构师通常会运行许多仿真，以便深入了解设计空间。考虑到设计空间是巨大的，需要运行的仿真数量可能非常大，这可能会使得探索设计空间很快变得不可行的。</p><p>更糟糕的是，正在仿真的基准测试的复杂性也在增长。鉴于处理器变得越来越强大，基准测试需要变得更加复杂。在过去，在多核时代之前虽然单线程性能呈指数级增长，但基准测试需要执行更多指令并访问更多数据，以便以有意义的方式给当前和未来的处理器施加负载压力。比如SPEC CPU基准测试的复杂性大幅提高：动态指令数量从CPU89的平均25亿个动态执行指令增加到CPU2000的2300亿个指令，CPU2006的平均2.5亿条指令。现在在多核时代，为了强调设计中的多核处理器，基准测试将需要越来越多线程化。</p><p>周期精确仿真速度慢是一个众所周知且长期存在的问题，研究人员提出了各种解决方案来解决这一重要问题。由于其重要性，本书的其余部分致力于讲解提高仿真速度的技术。采样仿真将在第6章中介绍，它可能是最广泛使用的仿真加速技术，通过只仿真长时间运行基准中的一小段代码来减少仿真时间。我们将在第7章中重新讨论统计仿真，它采用不同的方法提高仿真速度，主要是通过生成代表长时间运行基准测试的小型工作负载<em>workload</em>，并且同时降低仿真器的复杂性。统计仿真的目的仅仅是作为一种快速探索设计空间的技术，与详细的周期精确模拟相补充。最后在第8章中描述了利用并行性来加速仿真的三种方法：(i)在并行机器上分布式运行仿真；(ii)并行化仿真器以在主机器的并行性中受益；(iii)通过将仿真器映射到可重构硬件(即fpga)上来利用细粒度并行性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库打桩机制</title>
      <link href="/2024/09/02/%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/09/02/%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近做内存仿真相关研发时用到了打桩机制，相关总结如下：</p><p>Linux链接器支持一个很强大的技术，称为库打桩，它允许程序员截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。</p><p>下面是它的基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。</p><p>打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。要研究这些不同的机制，后面会一个示例程序作为运行例子。它调用C标准库(<code>libc.so</code>)中的<code>malloc</code>和<code>free</code>函数，对<code>malloc</code>的调用从堆中分配一个32字节的块，并返回指向该块的指针；对<code>free</code>的调用把块还给堆，供后续的<code>malloc</code>调用使用。目标就是用打桩来追踪程序运行时对<code>malloc</code>和<code>free</code>的调用。</p><h2 id="编译时打桩">编译时打桩</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiletime/int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiletime/malloc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfree</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiletime/mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILETIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d)=%p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfree</span><span class="params">(<span class="type">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的代码展示了如何使用C预处理在编译时打桩，<code>mymalloc.c</code>中的包装函数调用目标函数，打印追踪记录并返回。本地的<code>malloc.h</code>头文件指示预处理器用对相应包装函数的调用替换掉对目标函数的调用。像下面这样编译和链接这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -DCOMPILETIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -I. -o intc int.c mymalloc.o</span></span><br></pre></td></tr></table></figure><p>由于有<code>-I.</code>参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找<code>malloc.h</code>。注意，<code>mymalloc.c</code>中的包装函数是使用标准<code>mallo.h</code>头文件编译的。</p><p>运行这个程序会得到如下的追踪信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">./intc</span> </span><br><span class="line">malloc(32)=0x55718fd292a0</span><br><span class="line">free(0x55718fd292a0)</span><br></pre></td></tr></table></figure><h2 id="链接时打桩">链接时打桩</h2><p>Linux静态链接器支持用<code>--wrap f</code>标志进行链接时打桩。这个标志告诉链接器，把对符号<code>f</code>的引用解析城<code>__wrap f</code>，还要把对符号<code>__real_f</code>的引用解析为<code>f</code>。以下是示例程序的包装函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linktime/int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linktime/mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* __real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span>* ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="type">void</span>* __wrap_malloc(<span class="type">size_t</span> size)&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = __real_malloc(size);        <span class="comment">/* call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span>* ptr)&#123;</span><br><span class="line">    __real_free(ptr);                       <span class="comment">/* call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>用下述方法把这些源文件编译成可重定位目标文件，并把目标文件链接成可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -DLINKTIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -c int.c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o</span></span><br></pre></td></tr></table></figure><p><code>-Wl,option</code>标志把<code>option</code>传递给链接器。<code>option</code>中的每个逗号都要替换为一个空格，所以<code>-Wl,--wrap,malloc</code>就把<code>--wrap malloc</code>传递给链接器，以类似的方式传递<code>-Wl,--wrap,free</code>。</p><p>运行该程序会得到如下追踪信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">./intl</span> </span><br><span class="line">malloc(32) = 0x55d5164c02a0</span><br><span class="line">free(0x55d5164c02a0)</span><br></pre></td></tr></table></figure><h2 id="运行时打桩">运行时打桩</h2><p>编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制基于动态链接器的<code>LD_PRELOAD</code>环境变量。</p><p>如果<code>LD_PRELOAD</code>环境变量被设置为一个共享库路径名的列表(以空格或分号分隔)，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(<code>LD-LINUX.SO</code>)会先搜索<code>LD_PRELOAD</code>库，然后才搜索任何其它的库。有了这个机制，当你加载和执行任意可执行文件时，可以对任何共享库中的任何函数打桩，包括<code>libc.so</code>。</p><p>以下展示了<code>malloc</code>和<code>free</code>的包装函数，每个包装函数中，对<code>dlsym</code>的调用返回指向目标<code>libc</code>函数的指针。然后包装函数调用目标函数，打印追踪记录，再返回：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line"></span><br><span class="line">    mallocp = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);   <span class="comment">/* Get address of libc malloc */</span></span><br><span class="line">    <span class="keyword">if</span>((error = <span class="built_in">dlerror</span>()) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, stderr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">char</span>* ptr = <span class="built_in">mallocp</span>(size);              <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*freep)(<span class="type">void</span>*) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line">    <span class="keyword">if</span>(!ptr) <span class="keyword">return</span>;</span><br><span class="line">    freep = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);       <span class="comment">/* Get address of libc free */</span></span><br><span class="line">    <span class="keyword">if</span>((error = <span class="built_in">dlerror</span>()) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, stderr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">freep</span>(ptr);                             <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>下面是如何构建包含这些包装函数的共享库的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span></span><br></pre></td></tr></table></figure><p>然后编译主程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -o intr int.c</span></span><br></pre></td></tr></table></figure><p>从bash shell中运行这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">LD_PRELOAD=<span class="string">&quot;./mymalloc.so&quot;</span> ./intr</span></span><br><span class="line">malloc(32) = 0x1bf7010</span><br><span class="line">free(0x1bf7010)</span><br></pre></td></tr></table></figure><p>注意，可以用<code>LD_PRELOAD</code>对任何可执行程序的库函数调用打桩！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信二维码闪退，深扒源码后发现不止一处bug</title>
      <link href="/2024/05/15/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%97%AA%E9%80%80%EF%BC%8C%E6%B7%B1%E6%89%92%E6%BA%90%E7%A0%81%E5%90%8E%E5%8F%91%E7%8E%B0%E4%B8%8D%E6%AD%A2%E4%B8%80%E5%A4%84bug/"/>
      <url>/2024/05/15/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%97%AA%E9%80%80%EF%BC%8C%E6%B7%B1%E6%89%92%E6%BA%90%E7%A0%81%E5%90%8E%E5%8F%91%E7%8E%B0%E4%B8%8D%E6%AD%A2%E4%B8%80%E5%A4%84bug/</url>
      
        <content type="html"><![CDATA[<p>2023年4月24日微信在扫描某些特殊二维码时会出现崩溃，这部分正好是微信开源的模块，可以分析其问题源码以确定其bug并了解C++的常见坑点。</p><p>问题源码位置:<code>opencv_contrib/modules/wechat_qrcode/src/zxing/qrcode/decoder/decoded_bit_stream_parser.cpp</code>。</p><p>微信扫描二维码模块源码详见：<a href="https://github.com/opencv/opencv_contrib/tree/4.x/modules/wechat_qrcode">https://github.com/opencv/opencv_contrib/tree/4.x/modules/wechat_qrcode</a></p><p>开源社区修复方案详见：<a href="https://github.com/opencv/opencv_contrib/pull/3480/files">https://github.com/opencv/opencv_contrib/pull/3480/files</a></p><h2 id="整数除法结果会舍弃小数部分">整数除法结果会舍弃小数部分</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525110519.jpg" alt=""></p><p><code>count = (available + 7 / 8)</code>中的<code>7 / 8</code>运算结果为0，也就是等价于<code>count = available</code>。当<code>count</code>不为0而<code>available</code>为0时，<code>count</code>会被赋值为0，这会导致下面的<code>bytes_</code>是一个大小为0的空数组且<code>readBytes</code>是空指针，一旦解引用空指针就会发生崩溃！</p><p><code>count = (available 7 / 8)</code>这里应该是希望当<code>count</code>个字节占据的比特位数大于<code>available</code>时应该根据<code>available</code>向上扩容，那就应该进行如下修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(count * <span class="number">8</span> &gt; available)&#123;</span><br><span class="line">    cout = (available + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有个很明显的问题，最上面<code>int nBytes = count;</code>，而当<code>count</code>值改变后那会造成其与<code>nBytes</code>变量的值会不一致，这是否符合预期？应该尽可能避免冗余的无效变量，就算有必要这里也最好使用引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; nBytes = count;</span><br></pre></td></tr></table></figure><h2 id="漏写return">漏写return</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525112547.jpg" alt=""></p><p>这里很明显应该是漏掉一个<code>return</code>，否则没有任何意义，代码中还有其它好几处均漏掉了<code>return</code>。</p><h2 id="内存泄露">内存泄露</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525113142.jpg" alt=""></p><p><code>while</code>循环中当<code>if(err_handler.ErrCode())</code>为真时直接<code>return</code>了，并没有<code>delete[] buffer</code>，这会造成内存泄露！</p><p>C++工程实践中应遵循RAII的思想：不要直接用<code>new</code>、<code>delete</code>动态分配内存，而应该是用对象管理资源，这样当对象离开作用域时，会自动调用析构函数释放资源。对应这里应该直接使用智能指针<code>unique_ptr</code>，这样<code>return</code>时就无需担心忘记<code>delete[] buffer</code>了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">char</span>[]&gt; <span class="title">buffer</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[nBytes])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">append</span>(result, buffer.<span class="built_in">get</span>(), nBytes, err_handler);</span><br></pre></td></tr></table></figure><p>或者直接使用<code>vector</code>容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(nBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">append</span>(result, buffer.<span class="built_in">data</span>(), nBytes, err_handler);</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525151133.jpg" alt=""></p><p>这里<code>cd = iconv_open(StringUtils::UTF8, src)</code>应该是打开了某个资源，函数结束前<code>iconv_close(cd)</code>会释放该资源，但中间某些情况<code>return</code>时却忘了释放该资源<code>iconv_close(cd)</code>，这会造成资源泄露！</p><p>解决该问题也是要遵守RAII的原则，可以使用智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Del</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">iconv_t</span>* p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">iconv_close</span>(*p);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">iconv_t</span>, Del&gt; <span class="title">cd</span><span class="params">(<span class="keyword">new</span> <span class="type">iconv_t</span>(iconv_open(StringUtils::UTF8, src)))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="要善于使用lambda表达式">要善于使用lambda表达式</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525120017.jpg" alt=""></p><p>如果变量<code>nBytes</code>值会一直是<code>count</code>的两倍，那么这里最好使用lambda表达式，需要时直接调用<code>nBytes()</code>，避免每次<code>count</code>值变动后原来的<code>nBytes</code>值失效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> nBytes = [&amp;]&#123;<span class="keyword">return</span> <span class="number">2</span> * count;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(nBytes())</span></span>;</span><br></pre></td></tr></table></figure><p>还是应当尽可能避免冗余的无效变量，这样逻辑简介且更不容易出错。</p><h2 id="数组索引为负时越界">数组索引为负时越界</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525152824.jpg" alt=""></p><p>这里是通过查表法来给<code>bytes</code>数组相应位置上写入字符，但浪费时间和空间，没有必要，应该直接通过ACSII码加上偏移量就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes[i++] = <span class="string">&#x27;0&#x27;</span> + threeDigitsBits / <span class="number">100</span>;</span><br><span class="line">bytes[i++] = <span class="string">&#x27;0&#x27;</span> + (threeDigitsBits / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">bytes[i++] = <span class="string">&#x27;0&#x27;</span> + threeDigitsBits % <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>原来的查表法还存在一个明显的隐患，索引中的<code>threeDigitsBits</code>的类型是有符号整型<code>int</code>，当它值为负数时对数组<code>ALPHANUMERIC_CHARS</code>的访问会越界！数组索引下标应该是无符号类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> threeDigitsBits = bits-&gt;<span class="built_in">readBits</span>(<span class="number">10</span>, err_handler);</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240525155640.jpg" alt=""></p><p>而且<code>readBits()</code>的实现可读性太差，各种左移右移还有<code>mask</code>，还要特别注意有符号数算术右移时会扩展符号位！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 146 LRU缓存机制</title>
      <link href="/2024/04/01/Leetcode-146/"/>
      <url>/2024/04/01/Leetcode-146/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU缓存 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="双链表-哈希表-o-1">(双链表+哈希表) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>可以使用哈希表来维护整个缓存，哈希表增删改查时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的，这样使得<code>put</code>和<code>get</code>操作的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。为了实现最近最少使用的缓存淘汰机制，还得使用双链表作为一个队列，每次用到一个节点就先将它从双链表中删掉，然后再将它插入到双链表最左侧，如果缓存不够时就将最右侧节点淘汰掉即可。为了方便，双链表的头尾使用虚拟节点，每个节点中除了前后指针外存储<code>key</code>和<code>value</code>，哈希表用于将<code>key</code>映射至双链表中对应节点地址。<br><code>put(key,valye)</code>：首先用哈希表判断<code>key</code>是否存在：如果<code>key</code>存在，则修改对应的<code>value</code>，同时将<code>key</code>对应的节点放到双链表的最左侧；如果<code>key</code>不存在且缓存已满，则删除双链表最右侧的节点(上次使用时间最老的节点)并更新哈希表，然后在双链表最左侧插入<code>(key,value)</code>节点并更新哈希表；否则<code>key</code>不存在且缓存未满，此时直接在双链表最左侧插入<code>(key, value)</code>节点，同时更新哈希表。<br><code>get(key)</code>：首先用哈希表判断<code>key</code>是否存在：如果<code>key</code>存在，则返回对应的<code>value</code>，同时将<code>key</code>对应的节点放到双链表的最左侧；如果<code>key</code>不存在，则返回<code>-1</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>双链表和哈希表的增删改查操作的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以<code>put</code>和<code>get</code>操作的时间复杂度也都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度">空间复杂度</h4><p>使用了双链表和哈希表，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key, val;</span><br><span class="line">        Node* left, *right;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">val</span>(v), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;*L, *R;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; hash;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* p)</span></span>&#123;</span><br><span class="line">        p-&gt;left-&gt;right = p-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node* p)</span></span>&#123;</span><br><span class="line">        p-&gt;left = L;</span><br><span class="line">        p-&gt;right = L-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left = p;</span><br><span class="line">        L-&gt;right = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        n = capacity;</span><br><span class="line">        L = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>), R = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        L-&gt;right = R, R-&gt;left = L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* p = hash[key];</span><br><span class="line">        <span class="built_in">remove</span>(p);</span><br><span class="line">        <span class="built_in">insert</span>(p);</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">count</span>(key))&#123;</span><br><span class="line">            Node* p = hash[key];</span><br><span class="line">            p-&gt;val = value;</span><br><span class="line">            <span class="built_in">remove</span>(p);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">size</span>() == n)&#123;</span><br><span class="line">                Node* p = R-&gt;left;</span><br><span class="line">                <span class="built_in">remove</span>(p);</span><br><span class="line">                hash.<span class="built_in">erase</span>(p-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* t = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            <span class="built_in">insert</span>(t);</span><br><span class="line">            hash[key] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11测试代码性能(执行时间)的正确姿势</title>
      <link href="/2024/03/06/C++11%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD(%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4)%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>/2024/03/06/C++11%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD(%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4)%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>本文总结性能测试的常用方法，这里以测试遍历<code>vector</code>容器不同方法的性能为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ScopeProfiler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">vec[i] = i % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为性能测试</span></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;下标遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">sum += vec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;Range遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> <span class="type">const</span>&amp; a : vec)</span><br><span class="line">sum += a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;迭代器遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">sum += *it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;指针遍历&quot;</span>);</span><br><span class="line"><span class="type">int</span>* p = vec.<span class="built_in">data</span>(), *endp = p + vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(p != endp)&#123;</span><br><span class="line">sum += *p;</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printScopeProfiler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ScopeProfiler.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeProfiler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ClockType = std::chrono::high_resolution_clock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tag;</span><br><span class="line">        <span class="type">int</span> us;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">thread_local</span> <span class="type">static</span> std::vector&lt;Record&gt; records;</span><br><span class="line"></span><br><span class="line">    ClockType::time_point beg;</span><br><span class="line">    ClockType::time_point end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">ScopeProfiler</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *tag, ClockType::time_point beg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">onDestroy</span><span class="params">(ClockType::time_point end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopeProfiler</span>(<span class="type">const</span> <span class="type">char</span> *tag_) : <span class="built_in">ScopeProfiler</span>(tag_, ClockType::<span class="built_in">now</span>()) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ScopeProfiler</span>() &#123; <span class="built_in">onDestroy</span>(ClockType::<span class="built_in">now</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::vector&lt;Record&gt; <span class="type">const</span> &amp;<span class="title">getRecords</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> records; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">printLog</span><span class="params">(std::ostream &amp;out = std::cout)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ScopeProfiler::<span class="built_in">ScopeProfiler</span>(<span class="type">const</span> <span class="type">char</span> *tag_, ScopeProfiler::ClockType::time_point beg_)</span><br><span class="line">    : <span class="built_in">beg</span>(beg_), <span class="built_in">tag</span>(tag_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScopeProfiler::onDestroy</span><span class="params">(ScopeProfiler::ClockType::time_point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> diff = end - beg;</span><br><span class="line">    <span class="type">int</span> us = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(diff).<span class="built_in">count</span>();</span><br><span class="line">    records.<span class="built_in">push_back</span>(&#123;tag, us&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScopeProfiler::printLog</span><span class="params">(std::ostream &amp;out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (records.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Statistic</span> &#123;</span><br><span class="line">        <span class="type">int</span> max_us = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_us = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total_us = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count_rec = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tag = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::map&lt;std::string_view, Statistic&gt; stats;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[tag, us]: records) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;stat = stats[tag];</span><br><span class="line">        stat.total_us += us;</span><br><span class="line">        stat.max_us = std::<span class="built_in">max</span>(stat.max_us, us);</span><br><span class="line">        stat.min_us = !stat.count_rec ? us : std::<span class="built_in">min</span>(stat.min_us, us);</span><br><span class="line">        stat.count_rec++;</span><br><span class="line">        stat.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StatisticCompare</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> value_type = std::pair&lt;std::string_view, Statistic&gt;;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(value_type <span class="type">const</span> &amp;lhs, value_type <span class="type">const</span> &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second.total_us &gt; rhs.second.total_us;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::multiset&lt;std::pair&lt;std::string_view, Statistic&gt;, StatisticCompare&gt; <span class="built_in">sortstats</span>(stats.<span class="built_in">begin</span>(), stats.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dump = [&amp;out] (<span class="type">int</span> val, <span class="type">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tpwv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w - <span class="number">1</span>; i++) tpwv *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; tpwv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val / <span class="number">1000</span> &gt; tpwv / <span class="number">10</span>) &#123;</span><br><span class="line">                out &lt;&lt; std::<span class="built_in">setw</span>(w - <span class="number">1</span>) &lt;&lt; val / <span class="number">1000000</span> &lt;&lt; <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out &lt;&lt; std::<span class="built_in">setw</span>(w - <span class="number">1</span>) &lt;&lt; val / <span class="number">1000</span> &lt;&lt; <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out &lt;&lt; std::<span class="built_in">setw</span>(w) &lt;&lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="string">&quot;   avg   |   min   |   max   |  total  | cnt | tag\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span> &amp;[tag, stat]: sortstats) &#123;</span><br><span class="line">        <span class="built_in">dump</span>(stat.total_us / stat.count_rec, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.min_us, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.max_us, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.total_us, <span class="number">9</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">dump</span>(stat.count_rec, <span class="number">5</span>); out &lt;&lt; <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; tag &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printScopeProfiler</span><span class="params">(std::ostream &amp;out = std::cout)</span> </span>&#123;</span><br><span class="line">    ScopeProfiler::<span class="built_in">printLog</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScopeProfiler</code>在构造时会记录当前时间，当它析构时会计算当前时间与之前记录的构造时间之差，并将其转换为微妙，并将本次执行时间记录写入到<code>records</code>中。注意<code>records</code>是线程局域的，有多个线程时会分别记录。<code>ScopeProfiler::printLog()</code>会打印性能测试的所有记录。</p><h2 id="编译优化选项">编译优化选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ main.cpp -std=c++2a -o main &amp;&amp; ./main</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">    13012|    13012|    13012|    13012|    1| 迭代器遍历</span><br><span class="line">     9354|     9354|     9354|     9354|    1| Range遍历</span><br><span class="line">     4360|     4360|     4360|     4360|    1| 下标遍历</span><br><span class="line">     1919|     1919|     1919|     1919|    1| 指针遍历</span><br></pre></td></tr></table></figure><p>看起来迭代器和C++11的Range遍历效率很低？注意这是因为编译时如果不带优化选项会默认<code>O0</code>参数，此时不会开启任何优化，即上面的编译命令等价于<code>g++ -O0 main.cpp -std=c++2a -o main &amp;&amp; ./main</code>。迭代器是一个类，它其中重载了解引用、++等运算符，如果不开启优化这些重载的运算符都是一个个的成员函数，<code>O0</code>是不会内联任何函数的，此时<code>++it</code>和<code>sum += *it</code>会有函数调用<code>call</code>的明显开销：</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240428122132.jpg" alt=""></p><p>gcc的优化开关主要分为3个等级：<code>-O1</code>、<code>-O2</code>和<code>-O3</code>，还有<code>-Oz</code>、<code>-Os</code>和<code>-Ofast</code>等暂且不论。</p><p><code>-O1</code>会开启一部分汇编程度的优化，它包含内联优化的操作，示例代码的执行时间明显会快很多，4种遍历方法的性能没有显著区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ -O1 main.cpp -std=c++2a -o main1 &amp;&amp; ./main1</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">      420|      420|      420|      420|    1| 指针遍历</span><br><span class="line">      334|      334|      334|      334|    1| Range遍历</span><br><span class="line">      312|      312|      312|      312|    1| 下标遍历</span><br><span class="line">      312|      312|      312|      312|    1| 迭代器遍历</span><br></pre></td></tr></table></figure><p><code>-O2</code>相比<code>-O1</code>会开启进一步优化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ -O2 main.cpp -std=c++2a -o main2 &amp;&amp; ./main2</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">        0|        0|        0|        0|    1| Range遍历</span><br><span class="line">        0|        0|        0|        0|    1| 下标遍历</span><br><span class="line">        0|        0|        0|        0|    1| 指针遍历</span><br><span class="line">        0|        0|        0|        0|    1| 迭代器遍历</span><br></pre></td></tr></table></figure><p>开启<code>-O2</code>后这4种遍历方式的执行时间都变为0了？这是因为开启<code>-O2</code>优化后编译器会把所有没有实际效果的代码通通删除，示例代码中的<code>sum</code>计算出<code>vector</code>中所有元素之和后并未被使用，因此它会将4个<code>&#123;&#125;</code>作用域中的计算<code>vector</code>中所有元素之和的代码全部删除。为了避免这个问题，加上<code>print(sum)</code>，这样编译器会认为<code>sum</code>变量会被使用就不会把求和代码删掉了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fake.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ScopeProfiler.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数的意义在于避免编译器在O2优化时在&#123;&#125;块中看到sum未使用而将块中求和代码全部删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">vec[i] = i % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为性能测试</span></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;下标遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">sum += vec[i];</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;Range遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> <span class="type">const</span>&amp; a : vec)</span><br><span class="line">sum += a;</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;迭代器遍历&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">sum += *it;</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">ScopeProfiler _(<span class="string">&quot;指针遍历&quot;</span>);</span><br><span class="line"><span class="type">int</span>* p = vec.<span class="built_in">data</span>(), *endp = p + vec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(p != endp)&#123;</span><br><span class="line">sum += *p;</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printScopeProfiler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhanghua@AliECS:~/stl$ g++ -O2 main.cpp fake.cpp -std=c++2a -o main2 &amp;&amp; ./main2</span><br><span class="line">   avg   |   min   |   max   |  total  | cnt | tag</span><br><span class="line">     1813|     1813|     1813|     1813|    1| 下标遍历</span><br><span class="line">     1812|     1812|     1812|     1812|    1| 指针遍历</span><br><span class="line">     1755|     1755|     1755|     1755|    1| 迭代器遍历</span><br><span class="line">     1700|     1700|     1700|     1700|    1| Range遍历</span><br></pre></td></tr></table></figure><p><code>-O3</code>会开启一个矢量化的优化，性能会更快。</p><h2 id="系统性能分析工具perf">系统性能分析工具perf</h2><p>perf 是Linux的一款性能分析工具，能够进行函数级和指令级的热点查找，可以用来分析程序中热点函数的CPU占用率，从而定位性能瓶颈。</p><h3 id="perf的原理">perf的原理</h3><p>Linux性能计数器是一个基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU（Performance Monitoring Unit））功能和软件（软件计数器、tracepoint）功能。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/20210116001918115.png" alt=""></p><p>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。</p><p>Perf 可以对程序进行函数级别的采样，从而了解程序的性能瓶颈在哪里。其基本原理是：每隔一个固定时间，就是CPU上产生一个中断，看当前是哪个进程、哪个函数，然后给对应的进程和函数加一个统计值，这样就知道CPU有多少时间在某个进程或某个函数上了。</p><h3 id="perf的使用">perf的使用</h3><p>使用 perf 进行性能分析，主要使用下面两个命令：</p><ul><li><code>perf record</code>：保存perf追踪的内容，文件名为perf.data</li><li><code>perf report</code>：解析perf.data的内容</li></ul><p>比如要分析进程 xxx，启动该进程后，首先启动使用下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -a --call-graph dwarf -p `ps aux | grep <span class="string">&quot;xxx&quot;</span> | grep -v grep | <span class="built_in">cut</span> -c 9-15` -d 1 -b</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>-a</code>：表示对所有CPU采样</li><li><code>--call-graph dward</code>：表示分析调用栈的关系</li><li><code>-p</code>：表示分析指定的进程</li></ul><p>通过 Ctrl + C 结束后，会生成 perf.data 文件，然后通过 report 导出报告，即可以查看 main 函数和子函数的CPU平均占用率。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><h3 id="perf使用示例">perf使用示例</h3><p>有如下示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_loop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">sin</span>(i) + <span class="built_in">cos</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_small</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">for_loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_big</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">for_loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">loop_big</span>();</span><br><span class="line"><span class="built_in">loop_small</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>for_loop()</code>是一个两层循环，每次都要计算正弦和余弦的和，这是一个比较耗时的函数；<code>loop_small()</code>把<code>for_loop()</code>循环10次；<code>loop_big()</code>把<code>for_loop()</code>循环100次。</p><p>可以明显看出<code>main()</code>函数中<code>loop_big()</code>函数会占大部分CPU，下面通过 perf 命令验证下：</p><p>1）假设指定可执行文件的名称为perf_for</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ perf_for.cpp -o perf_for</span><br></pre></td></tr></table></figure><p>2）运行 perf_for 之后，启动 <code>perf record</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -a --call-graph dwarf -p `ps -ef | grep perf_for | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br></pre></td></tr></table></figure><p>3）结束后，通过<code>perf report</code>导出报告</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><p>如下图所示，可以看出main函数92%的CPU都花在<code>loop_big()</code>函数上：</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20240428140143.jpg" alt=""></p><h2 id="benchmark">BENCHMARK</h2><p>未完待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 3 资源管理</title>
      <link href="/2023/03/13/Effective-C-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/13/Effective-C-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>C++程序中最常使用的资源就是动态内存（如果分配内存却从来不曾归还它，会导致内存泄露），但内存只是程序员必须管理的众多资源之一。其它常见的资源还包括文件描述符、互斥锁、图形界面中的字型和笔刷、数据库连接以及网络套接字<code>socket</code>。不论哪一种资源，重要的是当你不再使用它时，必须将它归还系统。</p><h2 id="条款13：以对象管理资源">条款13：以对象管理资源</h2><p>以对象管理资源的两个关键点：</p><ol><li><p>获得资源后立刻放进管理对象内</p><p>“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”(<em>Resource Acquisition Is Initialization, RAII</em>)，因为程序员几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象。有时获得的资源被拿来赋值（而非初始化）某个管理对象，但不论哪一种做法，每一笔资源都在获得的同时立刻被放进管理对象中。</p></li><li><p>管理对象运用析构函数确保资源被释放</p><p>不论控制流如何离开区块，一旦对象被销毁（例如当对象离开作用域）其析构函数自然会被自动调用，于是资源被释放。</p></li></ol><p>一句话概括就是：为防止资源泄露，请使用<em>RAII</em>对象，它们在构造函数中获得资源并在析构函数中释放资源。</p><h2 id="条款14：在资源管理类中小心拷贝行为">条款14：在资源管理类中小心拷贝行为</h2><p>当一个<em>RAII</em>对象被复制时，程序员一般有两种策略可供选择：</p><ol><li><p><strong>禁止复制</strong></p><p>许多时候允许<em>RAII</em>对象被复制并不合理，如果复制动作对<em>RAII</em>类并不合理，程序员便应该禁止它。将拷贝操作声明为<code>private</code>但故意不实现它，或者将拷贝操作声明为<code>=delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> UnCopyable&#123;<span class="comment">// 禁止复制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对底层资源使用引用计数法</strong></p><p>有时程序员希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制<em>RAII</em>对象时，应将该资源的“被引用数”递增。</p></li></ol><h2 id="条款15：在资源管理类中提供对原始资源的访问">条款15：在资源管理类中提供对原始资源的访问</h2><p>APIs往往要求访问原始资源，所以每一个RAII类应该提供一个“取得其所管理之资源”的方法。对原始资源的访问可能经由显示转换<code>get()</code>或隐式转换（类型转换运算符），一般而言显示转换比较安全，但隐式转换对客户比较方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> f;&#125;<span class="comment">// 显示转换函数</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">// 隐式转换函数</span></span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款16：成对使用new和delete时要采用相同形式">条款16：成对使用new和delete时要采用相同形式</h2><p>当程序员使用<code>new</code>，也就是通过<code>new</code>动态生成一个对象时，有两件事发生：第一，内存被分配出来（通过<code>operator new</code>函数）；第二，针对此内存会有一个或多个构造函数被调用。</p><p>当使用<code>delete</code>时，也有两件事发生：针对此内存会有一个或更多析构函数被调用，然后内存才被释放（通过<code>operator delete</code>函数）。<code>delete</code>的最大问题在于：即将被删除的内存之内究竟有多少个对象？这个问题的答案决定了有多少个析构函数必须被调用起来。</p><p>这个问题的本质在于：即将被删除的那个指针，所指的是单一对象或对象数组？单一对象的内存布局一般而言不同于数组的内存布局，因为数组所用的内存通常还包括“数组大小”的记录，以便<code>delete</code>知道需要调用多少次析构函数；而单一对象的内存则没有这笔记录。</p><p>当程序员对着一个指针使用<code>delete</code>，唯一能让<code>delete</code>知道内存中是否存在一个“数组大小记录”的办法就是由程序员告诉它。如果使用<code>delete</code>时加上方括号，<code>delete</code>便认定指针指向一个数组，否则它便认定指针指向单一对象。</p><p>因此：如果在<code>new</code>表达式中使用<code>[]</code>，必须在相应的<code>delete</code>表达式中也使用<code>[]</code>。如果在<code>new</code>表达式中不使用<code>[]</code>，一定不要在相应的<code>delete</code>表达式中使用<code>[]</code>。</p><h2 id="条款17：以独立语句将newed对象置入智能指针">条款17：以独立语句将newed对象置入智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>编译器产出一个<code>processWidget</code>调用码之前，必须首先核算即将被传递的实参。上述第二实参只是单纯地对<code>priority</code>函数的调用，但第一实参<code>std::shared_ptr&lt;Widget&gt;(new Widget)</code>由两部分组成：</p><ol><li>执行<code>new Widget</code>表达式</li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>于是在调用<code>processWidget</code>之前，编译器必须创建代码来做以下三件事：</p><ol><li>调用<code>priority</code></li><li>执行<code>new Widget</code></li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>但是C++编译器可以以非常弹性的次序完成这些事情，可以确定是<code>new Widget</code>一定执行于<code>std::shared_ptr</code>构造函数调用之前，因为这个表达式的结果还要被传递作为<code>std::shared_ptr</code>构造函数的一个实参，但对<code>priority</code>的调用可以排在第一或第二或第三执行。如果编译器因为生成了更高效的代码而以第二顺位执行它，最终获得这样的操作序列：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority</code></li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>此时，一旦对<code>priority</code>的调用发生异常，那么<code>new Widget</code>返回的指针将会遗失，因为它还尚未被置入<code>std::shared_ptr</code>内！即在对<code>processWidget</code>的调用过程中可能引发资源泄露，因为在“资源创建（<code>new Widget</code>）”和“资源被转换为资源管理对象”两个时间点之间可能发生异常干扰。</p><p>由于编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度），避免这类问题的方法很简单：使用分离语句分别写出1.创建<code>Widget</code>；2.将它置入一个智能指针内，然后再把那个智能指针传给<code>processWidget</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>在上述修订后的代码内，“<code>new Widget</code>”表达式以及“对<code>std::shared_ptr</code>构造函数的调用”这两个动作，和“对<code>priority</code>的调用”是分隔开的，位于不同语句内，所以编译器不得在它们之间任意选择执行次序。</p><p>因此，以独立语句将<code>newed</code>对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 2.构造、析构和赋值运算</title>
      <link href="/2023/03/07/Effective-C-2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
      <url>/2023/03/07/Effective-C-2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="条款05：-了解c-默默编写并调用哪些函数">条款05： 了解C++默默编写并调用哪些函数</h2><p>如果程序员没有声明，编译器就会为它声明（编译器版本的）一个拷贝构造函数、一个拷贝赋值运算符和一个析构函数。此外，如果没有声明任何构造函数，编译器也会为你声明一个默认构造函数。所有这些函数都是<code>public</code>且<code>inline</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此，如果写下:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就好像你写下这样的代码:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>()&#123;...&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Empty</span>()&#123;...&#125;<span class="comment">// 析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>惟有当这些函数被需要（被调用），它们才会被编译器创建出来。</p><p>需要特别注意：编译器产出的析构函数是非<code>virtual</code>的，除非这个类的基类自身声明有<code>virtual</code>析构函数！</p><p>至于拷贝构造函数和拷贝赋值运算符，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。</p><p>如果打算在一个内含引用成员的类内支持赋值操作，那必须自己定义拷贝赋值运算符；面对内含<code>const</code>成员的类，编译器会拒绝编译那一行赋值动作，因为更改<code>const</code>成员是不合法的；如果某个基类将拷贝赋值运算符声明为<code>private</code>，那么编译器将拒绝为其派生类生成一个拷贝赋值运算符。</p><h2 id="条款06：若不想使用编译器自动生成的函数-就该明确拒绝">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>在C++ 11标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为<code>=delete</code>来阻止拷贝。删除的函数就是虽然程序员声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上<code>=delete</code>来指出希望将它定义为删除的。</p><p>为了阻止拷贝构造函数和拷贝赋值运算符被编译器自动生成，得程序员自行声明它们，可以将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>，这样阻止人们调用它。**Tips：**可以将成员函数声明为<code>private</code>而且故意不实现它们。</p><p>也可以设计一个专门阻止拷贝动作的基类，基类中将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;<span class="comment">// 允许派生类对象构造和析构</span></span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);<span class="comment">// 声明为private但故意不实现就是为了阻止拷贝 </span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了阻止HomeForSale对象被拷贝，唯一需要做的就是继承Uncopyable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款07：为多态基类声明virtual析构函数">条款07：为多态基类声明virtual析构函数</h2><p>C++明白指出，当派生类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，其结果未有定义——实际执行时通常发生的是对象的派生类成分没被销毁，即派生类的析构函数未能执行起来导致派生类成员很可能没被销毁，然后其基类成分通常会被销毁，于是造成一个诡异的“局部销毁”对象，造成内存泄露。</p><p>消除该问题的做法是：给基类一个虚析构函数，此后删除派生类对象就会正常，它会销毁整个对象，包括派生类成分。</p><p>虚表指针<em>vptr</em>指向一个由函数指针构成的数组，称为虚函数表<em>vtbl</em>：每一个带有虚函数的类都有一个相应的虚函数表。当对象调用某一虚函数时，实际被调用的函数取决于该对象的虚表指针所指的那个虚表——编译器在其中寻找适当的函数指针。</p><p>无端地将所有类的析构函数声明为<code>virtual</code>，就像从未声明它们为<code>virtual</code>一样，都是错误的。最佳工程实践是：只有当类内含至少一个虚函数，程序员才为它声明虚析构函数。</p><p>析构函数的运作方式是，最深层派生的那个类其析构函数最先被调用，然后是其每一个基类的析构函数被调用。</p><h2 id="条款08：别让异常逃离析构函数">条款08：别让异常逃离析构函数</h2><p>只要析构函数吐出异常，即使并非使用容器或<code>arrays</code>，程序也可能过早结束或出现不明确行为。C++不喜欢析构函数吐出异常！</p><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作。</p><h2 id="条款09：绝不在构造和析构过程中调用虚函数">条款09：绝不在构造和析构过程中调用虚函数</h2><p>基类构造期间虚函数绝不会下降到派生类阶层，取而代之的是，对象的行为就像隶属于基类类型一样。即在基类构造期间，虚函数不是虚函数。因此程序员应确定类的构造函数和析构函数都没有（在对象被创建和被销毁期间）调用虚函数，而它们中调用的所有函数也都服从同一约束。</p><h2 id="条款10：令operator-返回一个-this的引用">条款10：令<code>operator=</code>返回一个<code>*this</code>的引用</h2><p>为了实现“连锁赋值”，所有赋值相关的操作符必须返回一个引用指向操作符的左侧实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款11：在operator-中处理-自我赋值">条款11：在<code>operator=</code>中处理“自我赋值”</h2><p>“自我赋值”发生在对象被赋值给自己时，虽然这看起来有点愚蠢，但它合法，而且潜在的自我赋值可能不容易被一眼辨识出来。</p><p>一般而言如果某段代码操作指针或引用而它们被用来“指向多个相同类型的对象”，就需考虑这些对象是否为同一个！</p><p>为了阻止“自我赋值”的不安全性错误，传统做法是在<code>operator=</code>最前面安插一个“证同测试”来检验是否“自我赋值”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bimap* bp;<span class="comment">// 指向一个从堆分配而得的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="comment">// 如果是自我赋值，就不做任何事</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12：复制对象时勿忘其每一个成分">条款12：复制对象时勿忘其每一个成分</h2><p>当程序员编写一个拷贝函数时，要确保复制所有局部成员变量，并调用基类中合适的拷贝函数来复制所有基类成分！</p><p>不要尝试以某个拷贝函数实现另一个拷贝函数，应将相同部分放进第三个函数中，并由两个拷贝函数 共同调用。比如发现拷贝构造函数和拷贝赋值运算符有相近的代码，消除重复代码的做法是建立一个新的成员函数给两者调用。这样的函数往往是<code>private</code>而且常被命名为<code>init</code>。这个策略可以安全消除拷贝构造函数和拷贝赋值运算符之间的代码重复问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 1.让自己习惯C++</title>
      <link href="/2023/03/01/Effective-C-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/"/>
      <url>/2023/03/01/Effective-C-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/</url>
      
        <content type="html"><![CDATA[<h2 id="条款01：视c-为一个语言联邦">条款01：视C++为一个语言联邦</h2><p>将C++视为一个由相关语言组成的联邦而非单一语言，在其某个次语言中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然后当从一个次语言移往另一个次语言时，守则可能改变，C++总共有4个次语言：C语言；C++面向对象；C++模板；标准模板库STL。</p><p>因此，C++并不是一个带有一组守则的一体语言，它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言就会发现C++容易了解得多。</p><h2 id="条款02：尽量以const-enum-inline替换-define">条款02：尽量以const, enum, inline替换#define</h2><ul><li>对于单纯常量，最好以<code>const</code>对象或<code>enums</code>替换<code>#defines</code></li><li>对于形似函数的宏，最好改用<code>template inline</code>函数替换<code>#defines</code></li></ul><h2 id="条款03：尽可能使用const">条款03：尽可能使用const</h2><p>注意：如果被指物是常量，程序员可将关键字<code>const</code>写在类型之前或者类型之后星号之前，两种写法意义相同，所以下列两个函数接受的参数类型是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;<span class="comment">// f1获得一个指针，指向一个常量的(不变的)Widget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>;<span class="comment">// f2也是</span></span><br></pre></td></tr></table></figure><p>两种形式都有人用，应该试着习惯它们。</p><p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。例如将<code>operator*</code>重载函数的返回值声明为<code>const</code>可以预防“没意思的赋值动作”。</p><h3 id="const成员函数">const成员函数</h3><p><code>const</code>作用于成员函数可以使得<code>class</code>接口比较容易理解，因为这样可以得知哪个函数可以改动对象内容而哪个函数不行；它还使“操作<code>const</code>”对象成为可能。改善C++程序效率的一个根本办法是以<em>pass by reference-to-const</em>方式传递对象，此技术的前提是有<code>const</code>成员函数可用来处理取得（并经修饰而成）的<code>const</code>对象。</p><p>注意：两个成员函数如果只是常量性不同（即一个带<code>const</code>而另一个不带），可以被重载。</p><p>真实程序中<code>const</code>对象大多用于<code>passed by pointer-to-const</code>或<code>passed by reference-to-const</code>的传递结果</p><p>当程序员希望能修改类的某个数据成员，即使是在一个<code>const</code>成员函数内，可以通过在成员变量的声明中加入<code>mutable</code>关键字来做到这一点！借助<code>mutable</code>可以释放掉非静态成员变量的<code>bitwise constness</code>约束。</p><h3 id="在const和non-const成员函数中避免重复">在const和non-const成员函数中避免重复</h3><p>为了避免<code>const</code>和<code>non-const operator[]</code>产生代码重复以及伴随的编译时间、维护、代码膨胀等，应该实现<code>operator[]</code>的功能一次并使用它两次。即必须令其中一个<code>non-const operator[]</code>调用另一个<code>const</code>兄弟，这就是<strong>常量性转除</strong>。</p><p>换而言之，当<code>const</code>和非<code>const</code>成员函数有着实质等价的实现时，令非<code>const</code>版本调用<code>const</code>版本可以避免代码重复：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>&#123;<span class="comment">// 一如既往</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)&#123;</span><br><span class="line">        <span class="comment">// 先为*this加上const以调用const op[]，再将const op[]返回值的const转除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面示例代码共有两次转型：第一次用来为<code>*this</code>添加<code>const</code>，这使得接下来调用<code>operator[]</code>时得以调用<code>const</code>版本；第二次则是从<code>const operator[]</code>的返回值中移除<code>const</code>。</p><p>注意：<code>const</code>成员函数调用非<code>const</code>成员函数是一种错误行为，因为对象会因此有可能被改动！</p><h2 id="条款04：确定对象被使用前已先被初始化">条款04：确定对象被使用前已先被初始化</h2><p>读取未初始化的值会导致不明确的行为。因此，永远在使用对象之前先将它初始化。</p><p>要为内置类型对象进行手工初始化，因为C++不保证初始化它们。至于内置类型以外的任何其它东西，初始化责任落在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p><p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，即尽量在初始化列表替换赋值动作，这样通常效率更高。因为对大多数类型而言，比起先调用默认构造函数然后再调用拷贝赋值运算符，单只调用一次拷贝构造函数是比较高效的，有时甚至高效得多。初始化列表中列出的成员变量的排列次序应该和它们在<code>class</code>中声明的次序相同。并且，如果成员变量是<code>const</code>或<code>references</code>，它们就一定需要初值，不能被赋值。</p><p>C++有着十分固定的“成员初始化次序”：基类更早于其派生类被初始化，而类的成员变量总是以其声明次序被初始化，即使它们在初始化列表中以不同的次序出现也不会有任何影响。</p><p>为免除“跨编译单元之初始化次序”问题，请以<code>local static</code>对象替换<code>non-local static</code>对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 导读</title>
      <link href="/2022/12/26/Effective-C-%E5%AF%BC%E8%AF%BB/"/>
      <url>/2022/12/26/Effective-C-%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="术语-terminology">术语(Terminology)</h2><p>​所谓声明式(<em>declaration</em>)是告诉编译器某个东西的名称和类型，但略去细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;<span class="comment">// 对象声明式</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDigits</span><span class="params">(<span class="type">int</span> number)</span></span>;<span class="comment">// 函数声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;<span class="comment">// 类声明式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// 模板声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span>;<span class="comment">// &quot;typename&quot;的使用见条款42</span></span><br></pre></td></tr></table></figure><p>​<code>size_t</code>只是一个<code>typedef</code>，是C++计算个数（例如<code>char*-based</code>字符串内的字符个数或STL容器内的元素个数等等）时用的某种不带正负号（<code>unsigned</code>）类型。它也是<code>vector</code>，<code>deque</code>和<code>string</code>内的<code>operator[]</code>函数接受的参数类型。条款3阐述当我们定义自己的<code>operator[]</code>函数时应该遵循的协议。</p><hr><p>​每个函数的声明揭示其签名式(<em>signature</em>)，也就是参数和返回类型。一个函数的签名等同于该函数的类型。</p><p>​定义式(<em>definition</em>)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此对象拨发内存的地点。对于函数或函数模板而言，定义式提供了代码本体。对于类或类模板而言，定义式列出它们的成员。</p><p>​初始化(<em>initialization</em>)是“给予对象初值”的过程。对用户自定义类型的对象而言，初始化由构造函数执行。所谓默认构造函数是一个可被调用而不带任何实参者。这样的构造函数要不没有参数，要不就是每个参数都有缺省值。</p><p>​当类的构造函数被声明为<code>explicit</code>时，这可阻止它们被用来执行隐式类型转换，但它们仍可被用来进行显式类型转换。被声明为<code>explicit</code>的构造函数通常比其<code>non-explicit</code>版本更受欢迎，因为它禁止编译器执行非预期（往往也不被期望）的类型转换。除非有一个好理由允许构造函数被用于隐式类型转换，否则一般将它声明为<code>explicit</code>。</p><p>​拷贝构造函数被用来“以同型对象初始化自我对象”，拷贝赋值运算符被用来“从另一个同型对象中拷贝其值到自我对象”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1;<span class="comment">// 调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">w1 = w2;<span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：当看到赋值符号时请小心，因为<code>=</code>语法也可用来调用拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3 = w2;<span class="comment">// 调用拷贝构造函数！</span></span><br></pre></td></tr></table></figure><p>​拷贝构造很容易和拷贝赋值有所区别：如果一个新对象被定义（例如以上语句中的<code>w3</code>），一定会有个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的<code>w1 = w2</code>语句），就不会有构造函数被调用，那么当然就是赋值操作被调用。</p><p>​拷贝构造函数是一个尤其重要的函数，因为它定义一个对象如何以值传递(<em>passed by value</em>)。以值传递意味着“调用拷贝构造函数”。<strong>注意</strong>：以值传递用户自定义类型通常是个坏主意，以引用传递(<em>passed-by-reference-to-const</em>)往往是比较好的选择，详见条款20。</p><hr><p>​<strong>不明确行为</strong>(<em>undefined behavior</em>)：由于各种因素，某些C++构件的行为没有定义，程序员无法稳定预估运行期会发生什么事。下面两个代码片段就带有“不明确的行为”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="number">0</span>;<span class="comment">// p是个null指针</span></span><br><span class="line">std::cout &lt;&lt; *p;<span class="comment">// 对一个null指针取值会导致不明确行为</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;Darla&quot;</span>;<span class="comment">// name是个数组，大小为6(别忘记最尾端的null)</span></span><br><span class="line"><span class="type">char</span> c = name[<span class="number">10</span>];<span class="comment">// 指针涉及一个无效的数组索引，这将导致不明确行为</span></span><br></pre></td></tr></table></figure><p>​不明确（未定义）行为的结果是不可预期的，很可能让人不愉快！程序会有时执行正常，有时会造成崩坏，有时更产出不正确的结果。应尽量避免不明确行为！</p><p>​程序批注中提到构造函数和析构函数时，有时会使用缩写<em>ctor</em>和<em>dtor</em>。</p><h2 id="命名习惯-naming-conventions">命名习惯(Naming Conventions)</h2><p>​参数<code>lhs</code>和<code>rhs</code>它们分别代表左手端和右手端，常常以它们作为二元操作符函数如<code>operator==</code>和<code>operator*</code>的参数名称。对于成员函数，左侧实参由<code>this</code>指针表现出来，所以有时单独使用参数名称<code>rhs</code>。</p><p>​常将“指向一个<code>T</code>型对象”的指针命名为<code>pt</code>，意思是“pointer to <code>T</code>”。</p><p>​对于引用使用类似习惯：<code>rw</code>可能是个<code>Widget</code>类型的引用，<code>ra</code>则是个<code>Airplane</code>类型的引用。</p><h2 id="关于线程-threading-consideration">关于线程(Threading Consideration)</h2><p>​<strong>线程安全性</strong>(<em>thread safety</em>)是许多程序员要面对的主题！</p><h2 id="tr1和boost">TR1和Boost</h2><p>​TR1(“Technical Report 1”)是一份规范，描述加入C++标准程序库的诸多新机能。这些机能以新的class templates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有的TR1组件都被置于命名空间tr1内，后者嵌套于命名空间std内。</p><p>​Boost是个组织，亦是一个网站(<a href="http://boost.org">http://boost.org</a>)，提供可移植、同行复审、源码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言，Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何得了解它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础教程</title>
      <link href="/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="git基本概念">git基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本</li></ul><h2 id="git常用命令">git常用命令</h2><ol><li><p><code>git config --global user.name zhanghua</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中，其中<code>HEAD</code>头指针指向<code>master</code>分支的一个节点</p></li><li><p><code>git add XX</code>：将XX文件添加到暂存区</p><p><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</p></li><li><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</p></li><li><p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将暂存区的内容提交到当前分支，并将<code>HEAD</code>指针指向该分支最新版本，注意每次<code>commit</code>后暂存区会清空</p></li><li><p><code>git status</code>：查看仓库状态</p></li><li><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p></li><li><p><code>git log</code>：查看当前分支的所有版本（截止到<code>HEAD</code>指针指向的版本）</p><p><code>git log --pretty=oneline</code>：更简洁地查看当前分支的所有版本</p></li><li><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p></li><li><p><code>git reset --hard HEAD^</code> 或<code> git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p><p><code>git reset --hard 版本号</code>：回滚到某一特定版本（使用版本号的前7个字母即可）</p></li><li><p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销（注意：<code>git restore</code>并不是恢复至上一个历史版本，而是恢复至暂存区里存的内容）</p><p><code>git restore --staged XX</code>：将XX文件从暂存区中删除</p></li><li><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p></li><li><p><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p></li><li><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</p></li><li><p><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</p><p>注意：暂存区跟分支完全独立，切换分支是不会有多个暂存区的。因此不管在哪个分支上用的都是一个暂存区和工作目录</p></li><li><p><code>git branch</code>：查看所有分支和当前所处分支</p></li><li><p><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</p></li><li><p><code>git merge branch_name</code>：将分支<code>branch_name</code>快速合并到当前分支上</p></li><li><p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p></li><li><p><code>git branch branch_name</code>：创建新分支</p></li><li><p><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><p><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</p></li><li><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</p></li><li><p><code>git checkout -t origin/branch_name</code> 将远程的<code>branch_name</code>分支拉取到本地</p></li><li><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p></li><li><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p></li><li><p><code>git stash drop</code>：删除栈顶存储的修改</p></li><li><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p></li><li><p><code>git stash list</code>：查看栈中所有元素</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-213 Data Lab</title>
      <link href="/2022/08/26/CMU15-213-Data-Lab/"/>
      <url>/2022/08/26/CMU15-213-Data-Lab/</url>
      
        <content type="html"><![CDATA[<p>Lab开始前需仔细阅读<code>bits.c</code>注释中的<code>INTEGER CODING RULES</code>内容和<code>FLOATING POINT CODING RULES</code>内容！</p><h1 id="the-puzzles">The Puzzles</h1><h2 id="bitxor">bitXor</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * bitXor - x^y using only ~ and &amp; </span><br><span class="line"> *   Example: bitXor(4, 5) = 1</span><br><span class="line"> *   Legal ops: ~ &amp;</span><br><span class="line"> *   Max ops: 14</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先介绍<strong>德摩根定律</strong>，德摩根定律在离散数学的很多场景里都出现过，它一共有两个关系：</p><ul><li><p>在命题逻辑里，可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∨</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\lor Q) \Leftrightarrow (\lnot P) \wedge (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\wedge Q) \Leftrightarrow (\lnot P) \lor (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>在集合里可以这样表示：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋃</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋂</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcup B} = \overline{A} \bigcap \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋂</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋃</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcap B} = \overline{A} \bigcup \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><ul><li><p>在布尔代数里可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x \cdot y} = \overline{x} + \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.71389em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x + y} = \overline{x} \cdot \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9777700000000003em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7833300000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.7033300000000002em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p></li></ul><p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi><mo>+</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">x \oplus y = \overline{x} \cdot y + x \cdot \overline{y} = \overline{\overline{\overline{x} \cdot y} \cdot \overline{x \cdot \overline{y}}} = \overline{(x + \overline{y}) \cdot (\overline{x} + y)} = \overline{x \cdot y + \overline{x} \cdot \overline{y}} = \overline{x \cdot y} \cdot \overline{\overline{x} \cdot \overline{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.225em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.9505600000000003em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9500000000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-3.87em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin">tmin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 4</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>将最高有效位（即符号位）置为1且其余位置为0时为补码表示下的最小整数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="istmax">isTmax</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="line"> *     and 0 otherwise </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="line"> *   Max ops: 10</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的符号位为0且其余位全为1时为补码表示的最大值，此时观察可以发现对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>加1并取反等于自己。但同时需要注意-1（补码表示为全1）加1取反后也等于自己，这种情况需要排除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alloddbits">allOddBits</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>先做一个32位的掩码<code>t32</code>，并使其每个字节均为<code>0xAA</code>，即所有奇数位bit均为1。然后先通过<code>x &amp; t32</code>取出<code>x</code>的所有奇数bit位，然后与<code>t32</code>进行异或来判断取出来的结果是否等同<code>t32</code>，等同则说明<code>x</code>的所有奇数位bit均为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t8 = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">int</span> t16 = (t8 &lt;&lt; <span class="number">8</span>) | t8;</span><br><span class="line">    <span class="type">int</span> t32 = (t16 &lt;&lt; <span class="number">16</span>) | t16;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; t32) ^ t32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate">negate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>在C语言中，对于任意整数值<code>x</code>，计算表达式<code>-x</code>和<code>~x+1</code>得到的结果完全一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isasciidigit">isAsciiDigit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="line"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="line"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="line"> *            isAsciiDigit(0x05) = 0.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 15</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先<code>0x30</code>的二进制表示为<code>0b11 0000</code>，<code>0x39</code>的二进制表示为<code>0b11 1001 </code>。</p><p>用<code>cond1</code>判断<code>x</code>的高28位是否为<code>0x0000003</code>，同时也排除掉负数情况；再用<code>cond2</code>判断将<code>x</code>加6（<code>0b0110</code>）之后第5位bit是否会因为进位由1变为0，即判断<code>x</code>的最低4位是否小于等于<code>0b1001</code>。当且仅当<code>cond1</code>和<code>cond2</code>均为1时<code>isAsciiDigit</code>返回1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0x3</span>);</span><br><span class="line">    <span class="type">int</span> cond2 = ((x + <span class="number">0x6</span>) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 &amp; cond2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="conditional">conditional</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * conditional - same as x ? y : z </span><br><span class="line"> *   Example: conditional(2,4,5) = 4</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 16</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>可以想到<code>y + z + a + b</code>的形式，当<code>x</code>为真时让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">b=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>；当<code>x</code>为假时，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">a=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。由于不用<code>-</code>负号，因此可以用<code>~y + 1</code>代替<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，剩下的问题在于如何根据<code>x</code>的真假（即最低bit位为0或1）将所有bit位置为全1或全0。第一种方法是借助算术右移的机制，此时需要先将最低bit位左移至最高符号位，但是这种方式的移位数取决于整型类型具体有多少bit位，不具有普适性。另一种方法则更巧妙，<code>!x</code>的值只有0或1两种取值，再对它取负（即按位取反再加1）后就得到0和-1，而0和-1的补码表示不正是全0和全1嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mask1 = (!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> mask2 = (!!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> a = (~y + <span class="number">1</span>) &amp; mask1;</span><br><span class="line">    <span class="type">int</span> b = (~z + <span class="number">1</span>) &amp; mask2;</span><br><span class="line">    <span class="keyword">return</span> y + z + a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = (~y + <span class="number">1</span>) &amp; b;</span><br><span class="line">    <span class="type">int</span> d = (~z + <span class="number">1</span>) &amp; ~b;</span><br><span class="line">    <span class="keyword">return</span>  y + z + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于允许使用<code>|</code>位或运算操作，因此还有简洁的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>  (y &amp; ~b) | (z &amp; b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="islessorequal">isLessOrEqual</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="line"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 24</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ol><li>首先判断<code>x</code>与<code>y</code>是否相等，它们若相等则可以直接返回1，若<code>x</code>与<code>y</code>不等，则分别取<code>x</code>和<code>y</code>的符号位<code>signX</code>和<code>signY</code>；</li><li>若<code>x</code>正且<code>y</code>负，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定不成立，因此返回0；</li><li>若<code>x</code>负且<code>y</code>正，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定成立，因此返回1；</li><li>若<code>x</code>与<code>y</code>同号，则当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>结果为负（符号位为1）时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>成立。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !(x ^ y);       <span class="comment">// x == y</span></span><br><span class="line">    <span class="type">int</span> signX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cond2 = (!signX) &amp; signY;       <span class="comment">// x正y负</span></span><br><span class="line">    <span class="type">int</span> cond3 = (signX) &amp; (!signY);     <span class="comment">// x负y正</span></span><br><span class="line">    <span class="type">int</span> res = x + (~y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;       <span class="comment">// x与y同号</span></span><br><span class="line">    <span class="type">int</span> flag = res &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 | (!cond2 &amp; (cond3 | flag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalneg">logicalNeg</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * logicalNeg - implement the ! operator, using all of </span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4 </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>不等于<code>0</code>的数字有正负的区别，若<code>x</code>不为0时，则<code>x</code>与<code>-x</code>的符号位必然异号；当<code>x</code>为0时，<code>x</code>与<code>-x</code>的符号位均为0。因此可将<code>x</code>与<code>-x</code>进行与运算，若<code>x</code>不为0，则结果的符号位为1，否则为0，再通过算术右移31位可得到全1或全0。最后再对结果加<code>1</code>正好可将全1的二进制表示转为<code>0b0</code>，将全0的二进制表示转为<code>0b1</code>，非常巧妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> negX = ~x +<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sign = (x | negX) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> sign + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howmanybits">howManyBits</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> CMU15-213 Introduction to Computer Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-213 </tag>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2300 咒语和药水的成功对数</title>
      <link href="/2022/07/26/Leetcode-2300/"/>
      <url>/2022/07/26/Leetcode-2300/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="排序-二分-o-m-n-logm">（排序+二分）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>将表示药水能量强度的数组<code>potions</code>从小到大排序；</li><li>对于每个<code>spells[i]</code>，在<code>potions</code>中二分查找到第一个大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil success / spells[i] \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">⌉</span></span></span></span>的位置，然后记录答案。</li></ol><h2 id="时间复杂度">时间复杂度</h2><p>对<code>potions</code>数组排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>；对每个咒语的能量强度<code>spells[i]</code>均需要在<code>potions</code>数组中做一次二分，二分时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，故总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h2 id="空间复杂度">空间复杂度</h2><p><code>sort</code>排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的系统栈空间。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = spells.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = success / spells[i];</span><br><span class="line">            <span class="keyword">if</span> (success % spells[i]) t++;</span><br><span class="line">            res[i] = potions.<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 873 最长的斐波那契子序列的长度</title>
      <link href="/2022/07/09/Leetcode-873/"/>
      <url>/2022/07/09/Leetcode-873/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="线性dp-o-n-2">（线性DP）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>本题是最长上升子序列问题的变形。<br>由于斐波那契序列要求新加入的数是前两个数之和，假设新加入斐波那契数列的数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且其前两项分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，因此动态规划的状态定义仅需两维。</p><ol><li>状态定义：用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示最后一个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且倒数第二个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的最长斐波那契式的子序列长度；</li><li>状态计算：根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>可计算出斐波那契序列中倒数第三项的预期值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>已在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>之前出现过，则更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = max(f[i][j], f[j][k] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ol><p>注意如果最后不存在斐波那契式的子序列需要返回0。</p><p>状态定义为两维，状态转移的计算开销为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，算法总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            pos[arr[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> x = arr[i] - arr[j];</span><br><span class="line">                f[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; arr[j] &amp;&amp; pos.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                    <span class="type">int</span> k = pos[x];</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[j][k] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">3</span> ? res : <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1217 玩筹码</title>
      <link href="/2022/07/08/Leetcode-1217/"/>
      <url>/2022/07/08/Leetcode-1217/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/">1217. 玩筹码 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="找规律-o-n">（找规律）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4><p>筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，而筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此可总结出三条性质：</p><ol><li>筹码在偶数位置间移动无需代价；</li><li>筹码在奇数位置间移动也无需代价；</li><li>将一个筹码在偶数位置与奇数位置间转移的代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ol><p>所以针对本题，首先需要分别统计位于奇数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>和位于偶数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>，而最终只有两种情况：</p><ol><li>将所有筹码全部放置在某个偶数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>；</li><li>将所有筹码全部放置在某个奇数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>。</li></ol><p>两种情况最小值即为将所有筹码移动到同一位置上所需要的最小代价。</p><p>算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : position)</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span>) odd++;</span><br><span class="line">            <span class="keyword">else</span> even++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 4 寻找两个正序数组中的中位数</title>
      <link href="/2022/05/08/Leetcode-4/"/>
      <url>/2022/05/08/Leetcode-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组中的中位数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="递归-o-log-m-n">（递归）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></h4><p>问题的本质是在两个有序数组中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>小数，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时即可找出中位数。<br>为了便于后续分析，首先假定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素的数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素的数量。分别从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中各自取出前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个元素进行比较：</p><ol><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &gt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过多，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过少，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数;</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &lt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过少，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过多，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数。当出现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列中元素数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>的边界情况时，记得数组访问不能越界<code>si = min(i + k / 2, int(nums1.size()))</code>。</li></ol><h4 id="时间复杂度">时间复杂度</h4><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>即可找出中位数，并且每次递归时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的规模都会减半，因此总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() - i &gt; nums2.<span class="built_in">size</span>() - j)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span> (i == nums1.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">        <span class="type">int</span> si = <span class="built_in">min</span>(i + k / <span class="number">2</span>, <span class="built_in">int</span>(nums1.<span class="built_in">size</span>())), sj = j + k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[si - <span class="number">1</span>] &gt; nums2[sj - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, i, nums2, sj, k - k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, si, nums2, j, k - (si - i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 52 N皇后 II</title>
      <link href="/2022/05/04/Leetcode-52/"/>
      <url>/2022/05/04/Leetcode-52/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案数。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u - i + depth] &amp;&amp; !udg[u + i])&#123;</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">                res += <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 51 N皇后</title>
      <link href="/2022/05/04/Leetcode-51/"/>
      <url>/2022/05/04/Leetcode-51/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">51. N皇后 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后<code>path[u][i]='Q'</code>，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg, path</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg; </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        path = <span class="built_in">vector</span>&lt;string&gt;(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[i - u + depth] &amp;&amp; !udg[i + u])&#123;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">true</span>;</span><br><span class="line">                path[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 恢复现场</span></span><br><span class="line">                path[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 59 螺旋矩阵 II</title>
      <link href="/2022/05/04/Leetcode-59/"/>
      <url>/2022/05/04/Leetcode-59/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-n-2">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>矩阵中每个位置仅遍历一次，所以总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++)&#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n || res[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 54 螺旋矩阵</title>
      <link href="/2022/05/04/Leetcode-54/"/>
      <url>/2022/05/04/Leetcode-54/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-nm">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>定义二维bool数组<code>st</code>表示该位置是否被访问过;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>每个位置仅遍历一次，且寻找方向的时间复杂度是常数，故总时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度">空间复杂度</h4><p>需要额外<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的空间存储<code>st</code>数组。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || st[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span> ) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 191 位1的个数</title>
      <link href="/2022/05/03/Leetcode-191/"/>
      <url>/2022/05/03/Leetcode-191/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="位运算-o-1">（位运算）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>在整数的补码表示中，<code>-x</code>等价于<code>~x+1</code>，<code>lowbit(x)=x &amp; -x </code>可以返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>二进制表示下的最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此可以每次减掉<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>二进制表示下最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>减到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>为止。</p><p>时间复杂度分析：总共最多进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>次操作，每次操作的计算量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            n -= <span class="built_in">lowbit</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">lowbit</span><span class="params">(<span class="type">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/01/hello-world/"/>
      <url>/2022/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
