<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git基础教程</title>
      <link href="/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="git基本概念">git基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本</li></ul><h2 id="git常用命令">git常用命令</h2><ol><li><p><code>git config --global user.name zhanghua</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中，其中<code>HEAD</code>头指针指向<code>master</code>分支的一个节点</p></li><li><p><code>git add XX</code>：将XX文件添加到暂存区</p><p><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</p></li><li><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</p></li><li><p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将暂存区的内容提交到当前分支，并将<code>HEAD</code>指针指向该分支最新版本，注意每次<code>commit</code>后暂存区会清空</p></li><li><p><code>git status</code>：查看仓库状态</p></li><li><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p></li><li><p><code>git log</code>：查看当前分支的所有版本（截止到<code>HEAD</code>指针指向的版本）</p><p><code>git log --pretty=oneline</code>：更简洁地查看当前分支的所有版本</p></li><li><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p></li><li><p><code>git reset --hard HEAD^</code> 或<code> git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p><p><code>git reset --hard 版本号</code>：回滚到某一特定版本（使用版本号的前7个字母即可）</p></li><li><p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销（注意：<code>git restore</code>并不是恢复至上一个历史版本，而是恢复至暂存区里存的内容）</p><p><code>git restore --staged XX</code>：将XX文件从暂存区中删除</p></li><li><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p></li><li><p><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p></li><li><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</p></li><li><p><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</p><p>注意：暂存区跟分支完全独立，切换分支是不会有多个暂存区的。因此不管在哪个分支上用的都是一个暂存区和工作目录</p></li><li><p><code>git branch</code>：查看所有分支和当前所处分支</p></li><li><p><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</p></li><li><p><code>git merge branch_name</code>：将分支<code>branch_name</code>快速合并到当前分支上</p></li><li><p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p></li><li><p><code>git branch branch_name</code>：创建新分支</p></li><li><p><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><p><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</p></li><li><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</p></li><li><p><code>git checkout -t origin/branch_name</code> 将远程的<code>branch_name</code>分支拉取到本地</p></li><li><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p></li><li><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p></li><li><p><code>git stash drop</code>：删除栈顶存储的修改</p></li><li><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p></li><li><p><code>git stash list</code>：查看栈中所有元素</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-213 Data Lab</title>
      <link href="/2022/08/26/CMU15-213-Data-Lab/"/>
      <url>/2022/08/26/CMU15-213-Data-Lab/</url>
      
        <content type="html"><![CDATA[<p>Lab开始前需仔细阅读<code>bits.c</code>注释中的<code>INTEGER CODING RULES</code>内容和<code>FLOATING POINT CODING RULES</code>内容！</p><h1 id="the-puzzles">The Puzzles</h1><h2 id="bitxor">bitXor</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * bitXor - x^y using only ~ and &amp; </span><br><span class="line"> *   Example: bitXor(4, 5) = 1</span><br><span class="line"> *   Legal ops: ~ &amp;</span><br><span class="line"> *   Max ops: 14</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先介绍<strong>德摩根定律</strong>，德摩根定律在离散数学的很多场景里都出现过，它一共有两个关系：</p><ul><li><p>在命题逻辑里，可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∨</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\lor Q) \Leftrightarrow (\lnot P) \wedge (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\wedge Q) \Leftrightarrow (\lnot P) \lor (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>在集合里可以这样表示：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋃</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋂</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcup B} = \overline{A} \bigcap \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋂</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋃</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcap B} = \overline{A} \bigcup \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><ul><li><p>在布尔代数里可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x \cdot y} = \overline{x} + \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.71389em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x + y} = \overline{x} \cdot \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9777700000000003em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7833300000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.7033300000000002em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p></li></ul><p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi><mo>+</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">x \oplus y = \overline{x} \cdot y + x \cdot \overline{y} = \overline{\overline{\overline{x} \cdot y} \cdot \overline{x \cdot \overline{y}}} = \overline{(x + \overline{y}) \cdot (\overline{x} + y)} = \overline{x \cdot y + \overline{x} \cdot \overline{y}} = \overline{x \cdot y} \cdot \overline{\overline{x} \cdot \overline{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.225em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.9505600000000003em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9500000000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-3.87em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin">tmin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 4</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>将最高有效位（即符号位）置为1且其余位置为0时为补码表示下的最小整数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="istmax">isTmax</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="line"> *     and 0 otherwise </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="line"> *   Max ops: 10</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的符号位为0且其余位全为1时为补码表示的最大值，此时观察可以发现对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>加1并取反等于自己。但同时需要注意-1（补码表示为全1）加1取反后也等于自己，这种情况需要排除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alloddbits">allOddBits</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>先做一个32位的掩码<code>t32</code>，并使其每个字节均为<code>0xAA</code>，即所有奇数位bit均为1。然后先通过<code>x &amp; t32</code>取出<code>x</code>的所有奇数bit位，然后与<code>t32</code>进行异或来判断取出来的结果是否等同<code>t32</code>，等同则说明<code>x</code>的所有奇数位bit均为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t8 = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">int</span> t16 = (t8 &lt;&lt; <span class="number">8</span>) | t8;</span><br><span class="line">    <span class="type">int</span> t32 = (t16 &lt;&lt; <span class="number">16</span>) | t16;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; t32) ^ t32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate">negate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>在C语言中，对于任意整数值<code>x</code>，计算表达式<code>-x</code>和<code>~x+1</code>得到的结果完全一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isasciidigit">isAsciiDigit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="line"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="line"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="line"> *            isAsciiDigit(0x05) = 0.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 15</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先<code>0x30</code>的二进制表示为<code>0b11 0000</code>，<code>0x39</code>的二进制表示为<code>0b11 1001 </code>。</p><p>用<code>cond1</code>判断<code>x</code>的高28位是否为<code>0x0000003</code>，同时也排除掉负数情况；再用<code>cond2</code>判断将<code>x</code>加6（<code>0b0110</code>）之后第5位bit是否会因为进位由1变为0，即判断<code>x</code>的最低4位是否小于等于<code>0b1001</code>。当且仅当<code>cond1</code>和<code>cond2</code>均为1时<code>isAsciiDigit</code>返回1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0x3</span>);</span><br><span class="line">    <span class="type">int</span> cond2 = ((x + <span class="number">0x6</span>) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 &amp; cond2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="conditional">conditional</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * conditional - same as x ? y : z </span><br><span class="line"> *   Example: conditional(2,4,5) = 4</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 16</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>可以想到<code>y + z + a + b</code>的形式，当<code>x</code>为真时让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">b=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>；当<code>x</code>为假时，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">a=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。由于不用<code>-</code>负号，因此可以用<code>~y + 1</code>代替<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，剩下的问题在于如何根据<code>x</code>的真假（即最低bit位为0或1）将所有bit位置为全1或全0。第一种方法是借助算术右移的机制，此时需要先将最低bit位左移至最高符号位，但是这种方式的移位数取决于整型类型具体有多少bit位，不具有普适性。另一种方法则更巧妙，<code>!x</code>的值只有0或1两种取值，再对它取负（即按位取反再加1）后就得到0和-1，而0和-1的补码表示不正是全0和全1嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mask1 = (!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> mask2 = (!!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> a = (~y + <span class="number">1</span>) &amp; mask1;</span><br><span class="line">    <span class="type">int</span> b = (~z + <span class="number">1</span>) &amp; mask2;</span><br><span class="line">    <span class="keyword">return</span> y + z + a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = (~y + <span class="number">1</span>) &amp; b;</span><br><span class="line">    <span class="type">int</span> d = (~z + <span class="number">1</span>) &amp; ~b;</span><br><span class="line">    <span class="keyword">return</span>  y + z + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于允许使用<code>|</code>位或运算操作，因此还有简洁的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>  (y &amp; ~b) | (z &amp; b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="islessorequal">isLessOrEqual</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="line"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 24</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ol><li>首先判断<code>x</code>与<code>y</code>是否相等，它们若相等则可以直接返回1，若<code>x</code>与<code>y</code>不等，则分别取<code>x</code>和<code>y</code>的符号位<code>signX</code>和<code>signY</code>；</li><li>若<code>x</code>正且<code>y</code>负，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定不成立，因此返回0；</li><li>若<code>x</code>负且<code>y</code>正，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定成立，因此返回1；</li><li>若<code>x</code>与<code>y</code>同号，则当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>结果为负（符号位为1）时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>成立。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !(x ^ y);       <span class="comment">// x == y</span></span><br><span class="line">    <span class="type">int</span> signX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cond2 = (!signX) &amp; signY;       <span class="comment">// x正y负</span></span><br><span class="line">    <span class="type">int</span> cond3 = (signX) &amp; (!signY);     <span class="comment">// x负y正</span></span><br><span class="line">    <span class="type">int</span> res = x + (~y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;       <span class="comment">// x与y同号</span></span><br><span class="line">    <span class="type">int</span> flag = res &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 | (!cond2 &amp; (cond3 | flag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalneg">logicalNeg</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * logicalNeg - implement the ! operator, using all of </span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4 </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>不等于<code>0</code>的数字有正负的区别，若<code>x</code>不为0时，则<code>x</code>与<code>-x</code>的符号位必然异号；当<code>x</code>为0时，<code>x</code>与<code>-x</code>的符号位均为0。因此可将<code>x</code>与<code>-x</code>进行与运算，若<code>x</code>不为0，则结果的符号位为1，否则为0，再通过算术右移31位可得到全1或全0。最后再对结果加<code>1</code>正好可将全1的二进制表示转为<code>0b0</code>，将全0的二进制表示转为<code>0b1</code>，非常巧妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> negX = ~x +<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sign = (x | negX) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> sign + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howmanybits">howManyBits</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> CMU15-213 Introduction to Computer Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-213 </tag>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15代理模式</title>
      <link href="/2022/08/16/Boolan-C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/08/16/Boolan-C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220816221853.jpg" alt=""></p><p>代理模式属于“接口隔离”模式，即增加一个间接层来解决问题的模式。</p><h2 id="动机">动机</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220816222100.jpg" alt=""></p><p>代理模式的问题场景：比如一个分布式的系统，要想访问另一台机器上的对象那是做不到的。这里的“透明操作”就是指一致性，对使用用户实现内部实现隔离，既能透明操作又能实现额外的功能。</p><h2 id="模式定义">模式定义</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220816222630.jpg" alt=""></p><p>“控制”指的就是隔离，而隔离的方式就是使用接口来控制对这个对象的访问。</p><h2 id="结构">结构</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220816222810.jpg" alt=""></p><p>代理模式的结构看起来非常简单，但在实际使用过程中它可能变得非常复杂。</p><p>比如图中有一个主体对象<code>Subject</code>，该主体真正的对象在<code>RealSubject</code>，  即接口是<code>Subject</code>而实际对象是<code>RealSubject</code>。访问时<code>client</code>本来应该直接创建一个声明为<code>Subject</code>的接口，而真正实际创建是<code>RealSubject</code>对象，但是由于某种特殊原因（比如安全方面对直接的对象需要访问控制、性能优化、分布式等原因）做不到，这时<code>client</code>应该直接访问<code>Proxy</code>。<code>Proxy</code>中通过<code>realSubject-&gt;Request();</code>来访问<code>RealSubject</code>对象，但在实际开发过程中这一块会很复杂。</p><h2 id="示例">示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ISubject</span>&#123;<span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>: <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientApp</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ISubject* subject;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设<code>subject = new RealSubject;</code>这里通过某种工厂模式或者其它方式生成了一个<code>RealSubject</code>，但这种方式不合适，可能由于性能原因/安全控制原因/分布式原因等根本拿不到这个<code>RealSubject</code>。该如何解决？</p><p>使用了代理模式的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ISubject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy的设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubjectProxy</span>: <span class="keyword">public</span> ISubject&#123;</span><br><span class="line">    RealSubject realSubject;<span class="comment">// 间接访问也有可能是将RealSubject本身作为一个对象放在Proxy里面</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对RealSubject的一种间接访问</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientApp</span>&#123;</span><br><span class="line">    ISubject* subject;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject = <span class="keyword">new</span> <span class="built_in">SubjectProxy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Proxy有时需要手工写一些代码，有时在某些平台上常常是使用一些工具来生成的。</p><p>出于安全控制的原因，间接访问也有可能是将<code>RealSubject</code>本身作为一个对象放在<code>Proxy</code>里面，也可能由于分布式等原因只能实现一些针对网络层的协议的控制，即<code>RealSubject realSubject;</code>通常是不会出现的。</p><p>Proxy的设计常常会比较复杂，有些框架会用自动工具来生成，但整体设计思想还是要理解代理，所谓代理就是<code>SubjectProxy</code>就是针对<code>RealSubject</code>的一个代理，用了代理模式后对于<code>ClientApp</code>程序来说还是一样透明，甚至<code>subject = new SubjectProxy();</code>这里还可以用工厂模式包装起来。至于Proxy内部做了啥工作这就看这个Proxy类要完成啥任务，安全控制/性能提升/分布式……总之<code>ClientApp</code>不能直接调用<code>Subject</code>。</p><p>Proxy模式看起来非常简单，但实际应用时却不简单，通常需要很多层面的配合。</p><h2 id="总结">总结</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220818000706.jpg" alt=""></p><p>具体Proxy内部实现起来差异相当大（比如<code>SubjectProxy</code>代理类的<code>Process</code>），但总体设计思想都是代理类和实际类型采用的接口是一致的，从而使得客户端感觉上是一致的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 对RealSubject的一种间接访问</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写时复制（<em>Copy-on-Write, COW</em>）实际在某些实现上就是：（比如字符串类经常如此）如果原对象没有更改，复制时内部会有一个指针指向该原对象，这样每复制一份都不是深拷贝而是浅拷贝，即指针共享；当发生改对象或者可能会产生改对象的行为时，就需要内部再拷贝一份。这样实际上就是一种代理模式。</p><p>分布式系统中会大量使用代理模式！</p><p>有些系统中字符串<em>COW</em>技术的实现与字符串原有的接口并不是完全一致的，但它也是一种代理。代理的核心思想是增加一层间接层，来实现一些不为外界所知/所累的部分功能（性能特殊优化/AoP框架/分布式系统等）。</p>]]></content>
      
      
      <categories>
          
          <category> Boolan </category>
          
          <category> 李建忠 C++设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-213 Lecture15 Linking</title>
      <link href="/2022/08/14/CMU15-213-15Linking/"/>
      <url>/2022/08/14/CMU15-213-15Linking/</url>
      
        <content type="html"><![CDATA[<p>本节课主要通过研究学习链接的处理来探索系统是如何构建（<em>build</em>）程序的。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814012301.jpg" alt=""></p><p>先来看一个简答的程序，该程序由两部分源文件组成<code>main.c</code>和<code>sum.c</code>。像<code>main.c</code>中这样返回退出状态<code>return val;</code>很奇怪，这么做只是为了让编译器不会优化掉所有代码。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814012821.jpg" alt=""></p><p>现在看看编译这两个模块代码时会发生什么，对于<code>main.c</code>和<code>sum.c</code>中的每个源文件，GCC在这些<code>.c</code>文件上调用一系列<code>Translator</code>翻译器。它首先调用C预处理器<code>C preprocessor</code>，即<code>cpp</code>；然后它调用实际的编译器<code>cc1</code>，编译器生成汇编代码，然后由汇编器<code>as</code>翻译并生成一个名为<code>main.o</code>的<code>.o</code>可重定位目标程序，对于<code>sum.c</code>来说也是一样的流程。</p><p>源代码在经过这三个<code>translator</code>翻译器处理之后就得到了两个<code>.o</code>类型的目标文件，链接器获取那些<code>.o</code>文件并将它们链接在一起，最后形成一个可以运行的单个可执行文件。然后用户就可以将该可执行程序<code>prog</code>加载和运行在系统上。</p><p><code>main.c</code>和<code>sum.c</code>是源文件，这些<code>.o</code>文件是单独编译的目标文件，也称为可重定位目标文件，因为它们可以组合起来形成一个完全链接的可执行目标文件。</p><h2 id="why-linkers？">Why Linkers？</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814224156.jpg" alt=""><br><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814224658.jpg" alt=""></p><p>为什么允许这种所谓的单独编译？为何不将所有代码都包含在一个大文件中，原因主要有以下几点：</p><ol><li>模块化——模块化可以将庞大的代码分解成更小更精简的代码模块，可以将相关的函数放入单独的源文件中，可以定义函数库；</li><li>效率——如果程序分解成多个模块，更改其中一个模块时就不必重新编译所有其它项目，可以只重新编译修改的那个模块，然后将它们再次链接在一起，这样在时间和空间上都更具效率。如果需要使用C标准库中的所有函数，可以将它们全部放在一个文件里，但是实际编译并链接到程序中的那些函数才是实际要调用的函数，因此可以更节省空间。程序员通常只使用标准C函数的一小部分，因此将所有那些不使用的函数链接到实际代码中是没有意义的。</li></ol><h2 id="what-do-linkers-do？">What Do Linkers Do？</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814225914.jpg" alt=""></p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814231539.jpg" alt=""></p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814231617.jpg" alt=""></p><p>链接器主要执行两个任务：</p><ol><li><p>符号解析（<em>symbol resolution</em>）——程序会定义和引用符号（<em>symbol</em>），这里链接器所指的符号包括全局变量和函数。<code>void swap()&#123;...&#125;</code>这里定义了一个叫<code>swap</code>的符号，这样当调用<code>swap();</code>时就会指向/引用该符号。<code>int *xp = &amp;x;</code>定义了一个指向<code>int</code>类型的指针<code>xp</code>，如此就定义了<code>xp</code>并将其初始化为变量<code>x</code>的地址，即一个指向<code>x</code>的引用。</p><p>所有这些符号定义都会被汇编器存储在一个目标文件中，在符号表（<em>symbol table</em>）中，它是一个结构体数组，其中每个结构体都包含相关符号的信息，例如符号的名称、大小和位置。符号解析是指链接器在进行链接过程中，将每个符号引用（<em>symbol reference</em>）与一个对应的符号定义（<em>symbol definition</em>）相关联。这样存在一个问题，就像在多个模块中可以声明具有相同名称的全局变量，而链接器必须判别将这些符号定义中的哪一个用于后续的符号引用。</p></li><li><p>重定向（<em>relacation</em>）——当链接器为每个符号引用关联一个唯一的符号定义后，会进行第二步重定向，在重定向过程中它会将所有模块合并到一个可执行的目标模块中，该模块可以直接在系统上加载并执行。因此在它进行合并时必须清楚每个符号也即每个函数和变量将被存储在哪里，这就是重定向。因为最初函数只是存储在它们各自目标文件（<code>.o</code>文件）模块中的某个偏移量处，由于链接器并不知道这些函数最终将被加载到内存的何处，在重定向之前，目标文件模块中函数的地址仅是它在该目标模块中的偏移量，对于数据也是如此。在重定向这一步，链接器会决定程序执行时每个符号最终被加载到内存的位置，并将这些绝对位置和符号绑定到一起，然后它会查看对这些符号的所有引用并更新这些引用，使得它们现在指向正确的地址。</p></li></ol><h2 id="three-kinds-of-object-files-modules">Three kinds of Object Files (Modules)</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814233056.jpg" alt=""></p><p>目标文件模块有三种类型：</p><ol><li><code>.o</code>文件——它称为可重定位目标模块，是汇编程序输出的一个二进制文件，但是它无法被直接加载到内存，需要经过链接器的操作才能实际使用</li><li><code>a.out</code>文件——由链接器生成的可执行目标文件称为<code>a.out</code>文件（Linux平台）</li><li><code>.so</code>文件——另一种类型的目标文件称为共享目标文件或<code>.so</code>文件，这是一种创建共享库的现代技术</li></ol><h2 id="executable-and-linkable-format-elf">Executable and Linkable Format (ELF)</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814234013.jpg" alt=""></p><p>目标模块采用称为ELF的标准格式，它是<code>.o</code>可重定位文件、<code>.out</code>可执行目标文件和<code>.so</code>共享目标文件的统一格式。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220814234452.jpg" alt=""></p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815001154.jpg" alt=""></p><p>这些ELF二进制文件非常地结构化，它分为以下几个部分：</p><ol><li><code>ELF header</code>——其中包括字长、字节序、文件类型等内容信息，无论是<code>.o</code>、<code>.out</code>还是<code>.so</code>都包含ELF header，它提供一些关于该二进制文件的概括信息</li><li><code>Segment header table</code>——它只为可执行目标文件而定义，用来指明代码的所有不同segment（段）将在内存中的位置，指明stack在哪里，共享库在哪里，以及初始化和未初始化的数据应该放在哪里，代码应该放在哪里……所有这些不同的部分均在segment header table中定义</li><li>.<code>text</code>部分——<code>.text</code>一直用来指代代码</li><li>.<code>rodata</code>部分——<code>.rodata</code>全称为read only data，例如<code>switch</code>语句中的跳转表。<code>.text</code>和<code>.rodata</code>都是只读属性的，无法对它们进行写操作</li><li><code>.data</code>部分——这块空间用来包含所有已初始化的全局变量</li><li><code>.bss</code>部分——它定义了未初始化的全局变量。这实际上并不占用<code>.o</code>文件的任何空间，因为它们都是未初始化的，但符号表中有它们的相关条目，当程序被加载时，实际上必须要为这些变量分配空间、</li><li><code>.symtab</code>——它就是符号表，实际是一个结构体数组，包含用于过程（函数）、全局变量和任何静态属性定义的东西，它们在符号表中都有一个对应的条目。</li><li><code>.rel</code>部分——<code>.rel .text</code>和<code>.rel .data</code>它们包含了重定位信息，可以将它们视为笔记，当链接器去识别所有对符号的引用时，它在其中放置了一点笔记，用于实际创建可执行文件时修复对这个符号的引用。一个重定位条目就相当于一则笔记，汇编器提示链接器必须要修复这个引用，因为汇编器不知道这个符号加载至内存时会被实际存储在内存中哪块位置</li><li><code>.debug</code>部分——它其中包含将源代码中的行号与机器代码中的行号相关联的信息，它称为<code>.debug</code>因为是使用<code>-g</code>编译选项编译时得到的结果</li><li><code>section header table</code>——通过它可以知道不同<code>section</code>的起始位置</li></ol><h2 id="linker-symbols">Linker Symbols</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815001642.jpg" alt=""></p><p>对于链接器有三种不同的符号：</p><ol><li><p>全局符号——全局符号定义在某个模块<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>中，它们可以被其它模块使用。如果有一个由多个模块组成的程序，并将每一个模块编译成一个<code>.o</code>文件，这样将会调用未定义的函数，这些函数由其它模块定义，此时编译器不会抛出错误，因为它假设这些是在其它模块中定义的，并且它假定链接器将能够在其中找到它们并确定地址。使用任何不带静态属性的全局变量或函数定义都是全局符号。</p></li><li><p>外部符号——外部符号在某些方面与全局符号相反，它由模块<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>引用，但在其它模块中定义。比如前面例子中当<code>main.c</code>代码调用函数<code>sum</code>时，它引用了一个外部符号。</p></li><li><p>局部符号——局部符号（<em>local symbols</em>）在模块内部进行定义和引用，这与局部变量不同，局部C变量由编译器在栈上管理，链接器并不会对本地C变量有啥想法。对于使用静态属性声明的全局变量或函数，但其只能从定义它的这个模块内部引用，因此使用静态属性定义的函数或全局变量的作用域仅限于它被定义的模块，所以可以创建一个不能从该模块外部调用的私有函数。</p><p>如果想创建一个C函数库，并希望在其中创建一堆函数并且其它程序可以链接并调用该函数集，想让其它程序可见的函数是在没有静态属性的情况下定义的，而想要私有的函数只能是内部的，可以将其声明为静态（<em>static</em>）属性。这样就获得局部符号的抽象，使得能对外隐藏一些信息，只公开想要公开的数据和函数。</p></li></ol><h2 id="symbol-resolution">Symbol Resolution</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815230827.jpg" alt=""></p><p>在<code>main.c</code>中引用了一个名为<code>array</code>的全局变量，它本就在<code>main.c</code>中定义，<code>main.c</code>中还定义了一个全局函数<code>main</code>，里面又引用了一个全局函数<code>sum</code>，<code>sum</code>定义在<code>sum.c</code>中。<code>val</code>是栈上的局部C变量，链接器对此一无所知，<code>sum.c</code>中的<code>i</code>和<code>s</code>也是局部变量。</p><h2 id="理解局部静态c变量与局部非静态c变量之间的区别">理解局部静态C变量与局部非静态C变量之间的区别</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815231610.jpg" alt=""></p><p>函数<code>f</code>中定义了一个名为<code>x</code>的整型局部静态变量，由于它是局部的，所以它的作用域仅限于这个函数，因此变量<code>x</code>只能在函数<code>f</code>中引用。同理，函数<code>g</code>中<code>x</code>的这个定义只能被函数<code>g</code>引用，但由于它是用静态属性声明的，所以它并不会存储在栈上，它实际上会被存储在<code>.data</code>这个<code>section</code>中，就如同一个全局变量一样。也即在某种程度上，它就像是一个全局变量被存放在<code>.data section</code>中，而不是存在栈里；但它又是一个局部C变量，它的作用域被严格限制在定义它的这个函数范围内。</p><p>编译器会为<code>x</code>的每个定义分配空间，编译器会给它一个特定名字来消除歧义，这些符号被分配在<code>.data</code>中，因为它们被初始化并且像其它任何符号一样会在符号表中获得一则条目。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815232625.jpg" alt=""></p><p>在符号解析期间，链接器将每个符号引用与一个唯一的符号定义相关联，而如果所有这些模块中有多个符号定义时，链接器又如何将每个符号引用与一个唯一的符号定义相关关联呢？为了理解这一点，一般将符号定义为强或弱，强符号指那些过程函数名称或初始化全局变量，弱符号指未初始化的全局变量。<code>p1.c</code>中的<code>int foo = 5;</code>就是一个强符号，因为它被初始化了，根据定义<code>foo</code>就是强符号；<code>p2.c</code>中的<code>foo</code>就是弱符号，因为它未被初始化，<code>p2()</code>是强符号。</p><h2 id="linker-s-symbol-rules">Linker’s Symbol Rules</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815233504.jpg" alt=""></p><p>链接器的使用规则如下：</p><ol><li>不允许多个强符号——因为这是一个错误，如果跨多模块声明了一个具有相同名称的函数，链接器就会抛出一个错误，这是不允许的</li><li>在同时给定了一个强符号和多个弱符号时，链接器会选择强符号——如果有一个强符号和多个弱符号拥有相同的名字时，然后编译器就会选择强符号，它会将对该符号的所有引用关联到那个强符号定义上</li><li>如果仅有多个弱符号，那么链接器会从中任意选择一个——这就是可能存在的问题，可以使用<code>-fno-common</code>的<code>GCC</code>标志覆盖，如果使用<code>-fno-common</code>参数来声明函数，多个弱符号会在链接器中抛出错误。</li></ol><h2 id="linker-puzzles-重点">Linker Puzzles（重点）</h2><p><strong>链接错误</strong>是最糟糕的一种错误类型，它是最难调试的错误类型，因为菜鸡程序员通常不知道链接器内部发生了什么，通常只有最优秀的程序员才能真正了解这些链接器的工作方式以及它们会抛出什么样的错误，以及该如何调试它们。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220815234752.jpg" alt=""></p><p>假设有这样一个程序，该程序有两个模块，每个模块对应于图中的一个矩形。每个模块中都定义了<code>p1()</code>，它两都是强符号，这就会出现一个错误（Rule 1）。</p><p>第二行的例子假设定义了<code>p1()</code>和<code>p2()</code>，这是没有问题的，但有两个弱符号都叫<code>x</code>，如果其它模块引用<code>x</code>，链接器只能选择其一作为符号定义，但这不一定是程序员想要的结果（Rule 3）。虽然在两个模块中<code>x</code>都被声明为<code>int</code>，并未造成任何破坏，只是存在某个地方的整型变量，链接器选择哪一个并不重要，但如果使用不同类型声明这些弱符号时就会遭遇麻烦。</p><p><b>危险危险危险！！！</b>第三行在一个模块中声明了一个<code>int x</code>，在另一个模块中声明了一个<code>double x</code>，如果对<code>x</code>进行写操作，链接器只能任意选择<code>x</code>的符号定义来使用（Rule 3）。<code>double x</code>是一个长度为8字节的符号，如果链接器选择的是这个，那么在程序中任何对<code>x</code>的引用都将指向这个<code>double</code>，即使在前一个模块中引用<code>x</code>它也会是一个8字节的变量，这样它就会覆盖<code>y</code>变量，因为左边模块中变量<code>x</code>和变量<code>y</code>在内存中是紧挨着存储的。</p><p><b>危险危险危险！！！</b>第四行中左边定义了一个强符号<code>x</code>（因为它已被初始化），链接器会始终将所有对<code>x</code>的引用关联到这个整型大小的符号上（Rule 2），所以如果对右边模块的<code>x</code>进行写操作，由于右边<code>x</code>是一个<code>double</code>它就会覆盖这模块中的<code>y</code>。因为对<code>p2</code>中的<code>x</code>进行写操作它会占用8个字节，因为编译器知道它是一个<code>double</code>，但由于合规的分配空间它所去的内存位置其实只有4个字节，因为链接器会选择左边的强符号，这样对<code>p2</code>中的<code>x</code>进行写操作实际上会覆盖<code>y</code>！</p><p>第五行左边定义了一个强符号<code>x</code>（Rule 2），所以右边模块对<code>x</code>所引用的那个初始化变量可能并不是程序员想要的，程序员可能会假设它在代码中并未初始化</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220816220750.jpg" alt=""></p><ul><li>以上的这些问题是避免使用全局变量的部分原因，如果需要声明一个全局C变量，可以的话尽量将其生命为<code>static</code>，因为这样会将作用域限制为它所声明的模块中</li><li>如果程序员定义了一个全局变量并初始化它，这样程序员就会发现代码中是否有多个同名且初始化的全局符号（根据Rule 1，有的话链接时会直接报错）</li><li>最佳实践：可以通过引用一个外部变量来告诉编译器说它使用的是外部属性（使用<code>extern</code>关键字声明该变量）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> CMU15-213 Introduction to Computer Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-213 </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2面向对象设计原则</title>
      <link href="/2022/08/12/Boolan-C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2022/08/12/Boolan-C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811225825.jpg" alt=""></p><p>变化是软件设计中最大的挑战！使用了抽象原则的面向对象设计最大优势在于抵御变化，能够将变化的范围降低到最小。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811230220.jpg" alt=""></p><p>封装、继承和多态是面向对象的底层思维理解，从抽象思维来理解，面向对象首先是可以隔离变化，将变化所带来的影响减为最小。微观层面各司其职，借助C++的多态机制可以达到接口一样但实现不一样。对象是拥有独立责任的一个抽象体。</p><h2 id="面向对象设计原则">面向对象设计原则</h2><h3 id="依赖倒置原则">依赖倒置原则</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811231052.jpg" alt=""></p><p>面向对象有八大设计原则，它们比某一个具体的设计模式更为重要。这些设计模式有的可能如今已经不流行了，有些模式则被某些语言的某种机制替代了，有些模式可能程序员都遗忘了，这些都不重要。而有了这些设计原则可以发明自己的设计模式，也可以理解千千万万未来其它领域的设计模式。评判各种设计模式的标准也是靠设计原则，所有的设计模式都是依赖于这些设计原则推导出来的，如果它违背了设计原则，那么它就是错误的。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811233015.jpg" alt=""></p><p>第二种做法是稳定的，<code>Shape</code>是个抽象类/体，它是稳定的；<code>MainForm</code>是稳定的，它依赖于稳定的<code>Shape</code>，这没有问题；而具体的<code>Line</code>、<code>Rect</code>等作为一个不稳定的依赖于稳定的<code>Shape</code>。如此就实现了隔离变化，将下面<code>Line</code>和<code>Rect</code>的变化隔离起来了，而上面的<code>MainForm</code>和<code>Shape</code>是相对稳定的，这就是依赖倒置原则。依赖倒置原则贯穿所有的设计模式，它非常依赖于抽象类的提出。</p><h3 id="开放封闭原则">开放封闭原则</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811233702.jpg" alt=""></p><p>在面向对象领域且使用静态语言的环境下，一<strong>改变</strong>源代码就意味着需要相关文件进行重新编译、重新测试和重新部署，改变的代价是非常高的。而<strong>增加</strong>就相当于以扩展方式应对需求的变化，增加到另外一个文件里，其余地方都无需更改，正如1设计模式简介最后介绍的抽象思维例子。</p><p>即当需求变更时不要想着大面积改代码，应该聚焦于增加一些东西来应对新需求的变化，这是人类处理很多问题的智慧，在面向对象领域也是如此。</p><h3 id="单一职责原则">单一职责原则</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811234749.jpg" alt=""></p><p>如果一个类有非常庞杂的方法和成员就非常不合理，这说明它里面隐含了多项责任，而这多个责任会将类的设计者往不同的方向上拉扯，类的责任思考不慎就极易跳进坑，单一职责原则可以帮助类的设计者思考这方面。</p><h3 id="liskov替换原则">Liskov替换原则</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811235217.jpg" alt=""></p><p>Liskov替换原则其实就是&quot;is a&quot;的另外一种表达，即所有需要基类的地方使用派生类的对象都可以传过去正常使用。反例就是有的程序员在派生类继承基类后发现基类中的方法在派生类中无法使用，于是在派生类的这些方法里报异常<code>throw Exception</code>，这种做法违背了派生类能够替代基类的原则，或者说派生类与基类其实是一种组合关系而非继承关系。继承关系必须用&quot;is a&quot;原则。</p><h3 id="接口隔离原则">接口隔离原则</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220811235900.jpg" alt=""></p><p>接口应该小而完备，即不要把非必要的方法<code>public</code>，如果只是子类使用那就设为<code>protected</code>，如果仅本类使用那就设为<code>private</code>，仅有在有必要暴露时才做成<code>public</code>。无节制地将方法设为<code>public</code>会很容易地让外部程序对它产生依赖。</p><h3 id="优先使用对象组合-而不是类继承">优先使用对象组合，而不是类继承</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812000247.jpg" alt=""></p><p>继承关系本质上是一种&quot;is a&quot;类属关系，比如动物继承自生物，人类又继承自动物。对象组合就是<code>class A</code>中放了<code>class B</code>，B类型可以指针或对象均可。继承关系里基类暴露给派生类的内容是比较多的，或者说基类和派生类耦合度过高，而对象组合的耦合度相对较低。</p><h3 id="封装变化点">封装变化点</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812000918.jpg" alt=""></p><p>当程序员的素养逐步提升时，是可以在软件领域中划分出分界层，封装更高层次的理解是封装变化点，一侧变化，一侧稳定。</p><h3 id="针对接口编程-而不是针对实现编程">针对接口编程，而不是针对实现编程</h3><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812001144.jpg" alt=""></p><p>业务类型不要生成具体的类，而是声明为某个接口，这就是针对接口编程。针对接口编程原则与依赖倒置原则相辅相成，这两种设计原则是从不同角度看待问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainForm1.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point p1;</span><br><span class="line">Point p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面就违背了面向接口设计的原则，它们都依赖于具体类型了</span></span><br><span class="line">vector&lt;Line&gt; lineVector;</span><br><span class="line">vector&lt;Rect&gt; rectVector;</span><br><span class="line">vector&lt;Circle&gt; circleVector;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnPaint</span><span class="params">(<span class="type">const</span> PaintEventArgs&amp; e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shapeVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="comment">// 在具体处理时只使用接口的通用方法即可</span></span><br><span class="line">shapeVector[i]-&gt;<span class="built_in">Draw</span>(e.Graphics); </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Form::<span class="built_in">OnPaint</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812002135.jpg" alt=""></p><p>面向接口设计它是产业强盛的标志，任何行业放眼望去，该行业如果特别强盛，则它一定有非常强大的接口标准化的工作在做。接口标准化的核心就是分工协作，软件领域内的核心就是分工协作，通过分工协作才会实现复用性，接口就在里面扮演了重要的角色。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812002531.jpg" alt=""></p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812002825.jpg" alt=""></p><p>毕升的活字印刷术就相当于松耦合设计。</p><p>看各行各业，以汽车制造业为例，汽车制造业特别是新能源汽车制造业当今如此繁荣，有着高度的流水化标准，汽车工业中的很多标准都掌握在核心公司手中。再比如飞机制造业的空客和波音公司，它们设定了很多标准，包括但不限于制造标准，还有安全标准等，它们才得以将飞机生产制造分配到全球各大工厂来高度协作，并在行业内达到不可挑战的垄断地位。</p><p>所以面向接口设计是传统行业的智慧逐步借鉴到软件行业。</p><h2 id="将设计原则提升为设计经验">将设计原则提升为设计经验</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220812003253.jpg" alt=""></p><p>设计习语比如《Effective C++》、《More Effective C++》、《Exception C++》、《More Exception C++》等书籍，它们均属于这一层面。设计模式主要解决变化中的复用性问题。</p><p>进入学习到某一具体的设计模式之前，一定要深入地领悟这八大设计原则，如此才能非常灵活地理解和运用具体某一个模式。</p>]]></content>
      
      
      <categories>
          
          <category> Boolan </category>
          
          <category> 李建忠 C++设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1设计模式简介</title>
      <link href="/2022/08/11/Boolan-C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/08/11/Boolan-C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810215440.jpg" alt="">希望通过学习设计模式可以理解软件松耦合的设计思想，在锤炼和打磨设计模式的过程中也要理解掌握背后的一套设计原则，很多时候设计原则比某个具体的设计模式更重要。使用设计模式时要采用具体的重构方法，课程学习23种主要的设计模式。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810220032.jpg" alt=""></p><p>软件行业不需要重新发明轮子。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810220144.jpg" alt=""></p><p>可复用是设计模式的目标，面向对象是手法。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810220552.jpg" alt=""></p><p>程序员负责打通两个部分，希望把人类社会生活中的各种需求表达给计算机，让计算机可以理解并帮助人类执行。这里牵涉到两个思维模型，底层思维要求程序员与计算机进行沟通，从机器层面理解对象的构造；抽象思维也同样重要，它帮助程序员很好地管理代码的复杂度。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810221247.jpg" alt=""></p><p>面向对象向下需要理解面向对象的内部机制，偏向底层思维。但光理解这些是不够的，还要向上理解，因为用了面向对象的机制并不意味着你的设计就是面向对象了，或者说是一个好的面向对象的设计，评判设计的标准要靠抽象思维。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810221716.jpg" alt=""></p><p>软件领域中经常有这样一种需求的变更，它会冲击你的软件体系结构，软件行业从业者经常会面临这种挑战，这种挑战会给软件带来巨大的风险。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810221942.jpg" alt=""></p><p>软件领域的复杂性的根本原因在于变化，现在互联网公司甚至按周/天来release，这些变化会摧毁软件体系结构的设计。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810222245.jpg" alt=""></p><p>解决这种变化的复杂性有两种思维模型：分解和抽象。</p><p>以C语言为代表的结构化语言解决问题的思路就是分而治之，但是仅有分解在有些时候是不够的。人类解决更高层次的复杂性时，有一种通用的技术叫抽象。设计模式最后就是帮助程序员围绕抽象这个关键词建立一套思维的方式和模型。</p><h2 id="show-me-the-code">Show me the Code</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810234317.jpg" alt=""></p><h3 id="采用分解思路">采用分解思路</h3><p>以下是采用分解思路的画图工具代码，为了便于展示，代码中部分内容未遵循C++编码规范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape1.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;<span class="comment">// 描述图形的点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>&#123;<span class="comment">// 描述图形的线条</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point start;</span><br><span class="line">    Point end;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Line</span>(<span class="type">const</span> Point&amp; start, <span class="type">const</span> Point&amp; end)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span>&#123;<span class="comment">// 描述矩形</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point leftUp;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Rect</span>(<span class="type">const</span> Point&amp; leftUp, <span class="type">int</span> width, <span class="type">int</span> height)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;leftUp = leftUp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width = width;</span><br><span class="line"><span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其对应的界面表示窗口应用类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainForm1.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;<span class="comment">// Form仅表示父类，无需关注其具体API</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point p1;</span><br><span class="line">Point p2;</span><br><span class="line"></span><br><span class="line">vector&lt;Line&gt; lineVector;<span class="comment">// 程序要在界面上画线</span></span><br><span class="line">vector&lt;Rect&gt; rectVector;<span class="comment">// 程序要在界面上画矩形</span></span><br><span class="line"><span class="comment">//改变</span></span><br><span class="line">vector&lt;Circle&gt; circleVector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainForm</span>()&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 对鼠标的操作分别有鼠标按下去、鼠标抬起和界面被刷新</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnMouseDown</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnMouseUp</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnPaint</span><span class="params">(<span class="type">const</span> PaintEventArgs&amp; e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当鼠标被按下时记录第一个点p1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnMouseDown</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>&#123;</span><br><span class="line">p1.x = e.X;</span><br><span class="line">p1.y = e.Y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Form::<span class="built_in">OnMouseDown</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当鼠标抬起来时取第二个点p2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnMouseUp</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>&#123;</span><br><span class="line">p2.x = e.X;</span><br><span class="line">p2.y = e.Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rdoLine.Checked)&#123;<span class="comment">// 用户选择画线</span></span><br><span class="line"><span class="function">Line <span class="title">line</span><span class="params">(p1, p2)</span></span>;</span><br><span class="line">lineVector.<span class="built_in">push_back</span>(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rdoRect.Checked)&#123;<span class="comment">// 用户选择画矩形</span></span><br><span class="line"><span class="type">int</span> width = <span class="built_in">abs</span>(p2.x - p1.x);</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">abs</span>(p2.y - p1.y);</span><br><span class="line"><span class="function">Rect <span class="title">rect</span><span class="params">(p1, width, height)</span></span>;</span><br><span class="line">rectVector.<span class="built_in">push_back</span>(rect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (...)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">circleVector.<span class="built_in">push_back</span>(circle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Refresh</span>();<span class="comment">// Refresh系统会调用OnPaint()</span></span><br><span class="line"></span><br><span class="line">Form::<span class="built_in">OnMouseUp</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnPaint</span><span class="params">(<span class="type">const</span> PaintEventArgs&amp; e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对直线，限定画红色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lineVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">e.Graphics.<span class="built_in">DrawLine</span>(Pens.Red,</span><br><span class="line">lineVector[i].start.x, </span><br><span class="line">lineVector[i].start.y,</span><br><span class="line">lineVector[i].end.x,</span><br><span class="line">lineVector[i].end.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对矩形，限定画红色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rectVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">e.Graphics.<span class="built_in">DrawRectangle</span>(Pens.Red,</span><br><span class="line">rectVector[i].leftUp,</span><br><span class="line">rectVector[i].width,</span><br><span class="line">rectVector[i].height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变</span></span><br><span class="line"><span class="comment">// 针对圆形，限定画红色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; circleVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">e.Graphics.<span class="built_in">DrawCircle</span>(Pens.Red,</span><br><span class="line">circleVector[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Form::<span class="built_in">OnPaint</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="采用抽象思路">采用抽象思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape2.h</span></span><br><span class="line"><span class="comment">// 抽象做法里添加了一个虚基类Shape，里面有一个纯虚函数Draw()，析构函数也是虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">const</span> Graphics&amp; g)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point start;</span><br><span class="line">Point end;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Line</span>(<span class="type">const</span> Point&amp; start, <span class="type">const</span> Point&amp; end)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;start = start;</span><br><span class="line"><span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现自己的Draw，负责画自己</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">const</span> Graphics&amp; g)</span></span>&#123;</span><br><span class="line">g.<span class="built_in">DrawLine</span>(Pens.Red, </span><br><span class="line">start.x, start.y,end.x, end.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point leftUp;</span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Rect</span>(<span class="type">const</span> Point&amp; leftUp, <span class="type">int</span> width, <span class="type">int</span> height)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;leftUp = leftUp;</span><br><span class="line"><span class="keyword">this</span>-&gt;width = width;</span><br><span class="line"><span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现自己的Draw，负责画自己</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">const</span> Graphics&amp; g)</span></span>&#123;</span><br><span class="line">g.<span class="built_in">DrawRectangle</span>(Pens.Red,</span><br><span class="line">leftUp,width,height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//实现自己的Draw，负责画自己</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">const</span> Graphics&amp; g)</span></span>&#123;</span><br><span class="line">g.<span class="built_in">DrawCircle</span>(Pens.Red,</span><br><span class="line">...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的MainForm代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Point p1;</span><br><span class="line">Point p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对所有形状</span></span><br><span class="line">vector&lt;Shape*&gt; shapeVector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainForm</span>()&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnMouseDown</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnMouseUp</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnPaint</span><span class="params">(<span class="type">const</span> PaintEventArgs&amp; e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnMouseDown</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>&#123;</span><br><span class="line">p1.x = e.X;</span><br><span class="line">p1.y = e.Y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Form::<span class="built_in">OnMouseDown</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnMouseUp</span><span class="params">(<span class="type">const</span> MouseEventArgs&amp; e)</span></span>&#123;</span><br><span class="line">p2.x = e.X;</span><br><span class="line">p2.y = e.Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rdoLine.Checked)&#123;</span><br><span class="line">shapeVector.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Line</span>(p1,p2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rdoRect.Checked)&#123;</span><br><span class="line"><span class="type">int</span> width = <span class="built_in">abs</span>(p2.x - p1.x);</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">abs</span>(p2.y - p1.y);</span><br><span class="line">shapeVector.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(p1, width, height));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (...)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">shapeVector.<span class="built_in">push_back</span>(circle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Refresh</span>();</span><br><span class="line"></span><br><span class="line">Form::<span class="built_in">OnMouseUp</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainForm::OnPaint</span><span class="params">(<span class="type">const</span> PaintEventArgs&amp; e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对所有形状</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shapeVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">shapeVector[i]-&gt;<span class="built_in">Draw</span>(e.Graphics); <span class="comment">// 多态调用，各负其责</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Form::<span class="built_in">OnPaint</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，MainForm里就没有必要设计<code>vector&lt;Line&gt;、vector&lt;Rect&gt;</code>等，只需设计一个<code>vector&lt;Shape*&gt;</code>就可以了，它可以应对所有的类型。<code>vector&lt;Shape*&gt;</code>中虽然存放的是<code>Shape*</code>指针类型，但实际应用时可能指向的是<code>Line</code>、<code>Rect</code>等类型，其实就是利用多态的特性。当然，MainForm析构函数里记得要对<code>ShapeVector</code>中存放的指针进行<code>delete</code>。</p><p><code>MainForm::OnPaint()</code>中只需对<code>ShapeVector</code>中的所有元素执行<code>Draw()</code>多态调用。</p><h3 id="总结：">总结：</h3><p>如果仅静态地来看待上面这两种设计其实很难评判两者优劣，这里假设一种情况，客户新需要需要实现<code>Circle</code>圆形画法。</p><p>第一种分解思路的写法需要在Shape1.h中添加<code>Circle</code>类，还要在MainForm1.cpp中加上<code>vector&lt;Circle&gt; circleVector</code>，还有<code>MainForm::OnMouseUp()</code>中要添加创建<code>Circle</code>对象并往<code>circleVector</code>中<code>push_back</code>，<code>MainForm::OnPaint()</code>中也需要针对<code>Circle</code>类型去单独地去画。如此一个很小的需求就要在很多地方进行更改源代码，这也是加班的重要原因，需求在不断地剧烈变动，而普通程序员在被动地满足应对这种需求。</p><p>第二种做法也需要在Shape2.h中添加<code>Circle</code>类，并且让它<code>public</code>继承<code>Shape</code>，<code>override</code>重写自己的<code>Draw()</code>。MainForm2.cpp中无需修改<code>vector&lt;Shape*&gt; shapeVector</code>，<code>Cirlce</code>本身就是一个<code>Shape</code>。<code>MainForm::OnMouseUp()</code>中要添加<code>new Circle</code>对象并往<code>circleVector</code>中<code>push_back</code> ，而<code>MainForm::OnPaint()</code>无需任何变化。如果用了工厂模式，其实<code>MainForm::OnMouseUp()</code>也可无需更改。</p><p>总结来看，第二种设计方法由于需求的变更，它的改变很少，即它的重用性得到了很高的提升，可以不断复用。而第一种写法复用性非常差，当需求变化时这种写法在盲目且繁琐地更改源代码。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20220810234351.jpg" alt=""></p><p>设计模式讲的就是复用性，所有设计模式的目标也是复用性。</p><p>分解就是各种各样的类型分别设计，同时在具体操作和处理它们时分而治之，但是分而治之的做法是不易代码复用的，因为如果将来有新的情况就需要针对它再做一种处理。</p><p>抽象就是通过一种方法统一地来处理，比如<code>Shape</code>就是一个抽象类，它表达一种抽象的方式，其它所有的图形类都继承自它（即它们均符合<code>Shape</code>对它们的抽象）。那么在其它的地方处理时就无需分而治之，这就是统一的处理，这正是抽象的方法使得程序员可以统一地处理。统一处理带来的优势是如果以后再有任何变化，这种处理方法是不变的，这正是复用。</p><p>程序员必须深刻理解抽象这种设计方法和设计目标，后续会利用这种抽象设计思想来针对不同领域的不同问题提出不同的设计模式来去解决它。</p>]]></content>
      
      
      <categories>
          
          <category> Boolan </category>
          
          <category> 李建忠 C++设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2300 咒语和药水的成功对数</title>
      <link href="/2022/07/26/Leetcode-2300/"/>
      <url>/2022/07/26/Leetcode-2300/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="排序-二分-o-m-n-logm">（排序+二分）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>将表示药水能量强度的数组<code>potions</code>从小到大排序；</li><li>对于每个<code>spells[i]</code>，在<code>potions</code>中二分查找到第一个大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil success / spells[i] \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">⌉</span></span></span></span>的位置，然后记录答案。</li></ol><h2 id="时间复杂度">时间复杂度</h2><p>对<code>potions</code>数组排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>；对每个咒语的能量强度<code>spells[i]</code>均需要在<code>potions</code>数组中做一次二分，二分时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，故总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h2 id="空间复杂度">空间复杂度</h2><p><code>sort</code>排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的系统栈空间。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = spells.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = success / spells[i];</span><br><span class="line">            <span class="keyword">if</span> (success % spells[i]) t++;</span><br><span class="line">            res[i] = potions.<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 873 最长的斐波那契子序列的长度</title>
      <link href="/2022/07/09/Leetcode-873/"/>
      <url>/2022/07/09/Leetcode-873/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="线性dp-o-n-2">（线性DP）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>本题是最长上升子序列问题的变形。<br>由于斐波那契序列要求新加入的数是前两个数之和，假设新加入斐波那契数列的数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且其前两项分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，因此动态规划的状态定义仅需两维。</p><ol><li>状态定义：用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示最后一个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且倒数第二个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的最长斐波那契式的子序列长度；</li><li>状态计算：根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>可计算出斐波那契序列中倒数第三项的预期值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>已在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>之前出现过，则更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = max(f[i][j], f[j][k] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ol><p>注意如果最后不存在斐波那契式的子序列需要返回0。</p><p>状态定义为两维，状态转移的计算开销为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，算法总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            pos[arr[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> x = arr[i] - arr[j];</span><br><span class="line">                f[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; arr[j] &amp;&amp; pos.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                    <span class="type">int</span> k = pos[x];</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[j][k] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">3</span> ? res : <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1217 玩筹码</title>
      <link href="/2022/07/08/Leetcode-1217/"/>
      <url>/2022/07/08/Leetcode-1217/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/">1217. 玩筹码 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="找规律-o-n">（找规律）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4><p>筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，而筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此可总结出三条性质：</p><ol><li>筹码在偶数位置间移动无需代价；</li><li>筹码在奇数位置间移动也无需代价；</li><li>将一个筹码在偶数位置与奇数位置间转移的代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ol><p>所以针对本题，首先需要分别统计位于奇数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>和位于偶数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>，而最终只有两种情况：</p><ol><li>将所有筹码全部放置在某个偶数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>；</li><li>将所有筹码全部放置在某个奇数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>。</li></ol><p>两种情况最小值即为将所有筹码移动到同一位置上所需要的最小代价。</p><p>算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : position)</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span>) odd++;</span><br><span class="line">            <span class="keyword">else</span> even++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 4 寻找两个正序数组中的中位数</title>
      <link href="/2022/05/08/Leetcode-4/"/>
      <url>/2022/05/08/Leetcode-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组中的中位数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="递归-o-log-m-n">（递归）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></h4><p>问题的本质是在两个有序数组中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>小数，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时即可找出中位数。<br>为了便于后续分析，首先假定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素的数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素的数量。分别从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中各自取出前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个元素进行比较：</p><ol><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &gt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过多，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过少，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数;</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &lt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过少，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过多，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数。当出现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列中元素数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>的边界情况时，记得数组访问不能越界<code>si = min(i + k / 2, int(nums1.size()))</code>。</li></ol><h4 id="时间复杂度">时间复杂度</h4><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>即可找出中位数，并且每次递归时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的规模都会减半，因此总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() - i &gt; nums2.<span class="built_in">size</span>() - j)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span> (i == nums1.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">        <span class="type">int</span> si = <span class="built_in">min</span>(i + k / <span class="number">2</span>, <span class="built_in">int</span>(nums1.<span class="built_in">size</span>())), sj = j + k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[si - <span class="number">1</span>] &gt; nums2[sj - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, i, nums2, sj, k - k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, si, nums2, j, k - (si - i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 52 N皇后 II</title>
      <link href="/2022/05/04/Leetcode-52/"/>
      <url>/2022/05/04/Leetcode-52/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案数。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u - i + depth] &amp;&amp; !udg[u + i])&#123;</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">                res += <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 51 N皇后</title>
      <link href="/2022/05/04/Leetcode-51/"/>
      <url>/2022/05/04/Leetcode-51/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">51. N皇后 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后<code>path[u][i]='Q'</code>，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg, path</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg; </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        path = <span class="built_in">vector</span>&lt;string&gt;(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[i - u + depth] &amp;&amp; !udg[i + u])&#123;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">true</span>;</span><br><span class="line">                path[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 恢复现场</span></span><br><span class="line">                path[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 59 螺旋矩阵 II</title>
      <link href="/2022/05/04/Leetcode-59/"/>
      <url>/2022/05/04/Leetcode-59/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-n-2">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>矩阵中每个位置仅遍历一次，所以总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++)&#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n || res[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 54 螺旋矩阵</title>
      <link href="/2022/05/04/Leetcode-54/"/>
      <url>/2022/05/04/Leetcode-54/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-nm">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>定义二维bool数组<code>st</code>表示该位置是否被访问过;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>每个位置仅遍历一次，且寻找方向的时间复杂度是常数，故总时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度">空间复杂度</h4><p>需要额外<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的空间存储<code>st</code>数组。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || st[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span> ) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 191 位1的个数</title>
      <link href="/2022/05/03/Leetcode-191/"/>
      <url>/2022/05/03/Leetcode-191/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="位运算-o-1">（位运算）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>在整数的补码表示中，<code>-x</code>等价于<code>~x+1</code>，<code>lowbit(x)=x &amp; -x </code>可以返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>二进制表示下的最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此可以每次减掉<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>二进制表示下最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>减到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>为止。</p><p>时间复杂度分析：总共最多进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>次操作，每次操作的计算量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            n -= <span class="built_in">lowbit</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">lowbit</span><span class="params">(<span class="type">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/01/hello-world/"/>
      <url>/2022/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
