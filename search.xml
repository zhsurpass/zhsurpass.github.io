<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《计算机架构性能评估方法》第四章 分析性能建模</title>
      <link href="/2024/11/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E5%BB%BA%E6%A8%A1/"/>
      <url>/2024/11/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机架构性能评估方法-第四章-分析性能建模">《计算机架构性能评估方法》第四章 分析性能建模</h1><blockquote><p>Copyright © 2010 by Morgan &amp; Claypool<br>All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in<br>any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations in<br>printed reviews, without the prior permission of the publisher.<br>Computer Architecture Performance Evaluation Methods<br>Lieven Eeckhout<br><a href="http://www.morganclaypool.com">www.morganclaypool.com</a><br>ISBN: 9781608454679 paperback<br>ISBN: 9781608454686 ebook<br>DOI 10.2200/S00273ED1V01Y201006CAC010<br>A Publication in the Morgan &amp; Claypool Publishers series<br>SYNTHESIS LECTURES ON COMPUTER ARCHITECTURE<br>Lecture #10<br>Series Editor: Mark D. Hill, University of Wisconsin<br>Series ISSN<br>Synthesis Lectures on Computer Architecture<br>Print 1935-3235 Electronic 1935-3243</p></blockquote><p>分析性能建模是一种重要的性能评估方法，在过去几年中得到了越来越多的关注。与流行的仿真方法相比，分析建模可能不太准确，但它比仿真快好几个数量级：甚至可以立即获得性能估计结果，因为这就是一个计算有限数量公式的问题，最多几秒钟或者几分钟内就可以完成。仿真则很可能花费数小时、数天甚至数周的时间。</p><p>由于其巨大的速度优势，分析建模可以非常快速地探索巨大的架构设计空间，这使其在设计周期的早期阶段非常有用，甚至可以探索难以通过仿真探索的巨大设计空间。换句话说，分析建模可用于快速识别感兴趣的区域，然后通过仿真对其进行更详细的探索。<em>Lee</em>和<em>Brooks</em>所做的一项研究说明了分析建模在探索大型设计空间方面的力量，该研究探索了自适应微架构的潜力，它同时改变了微架构的适应性和适应的时间粒度——这是一项通过详细的周期精确的仿真无法实现的研究。</p><p>此外，分析建模提供了更多基本的洞察力。虽然仿真也提供了有价值的见解，但它需要许多仿真来理解性能对设计参数的敏感性。相反，在分析建模中，灵敏度可以从公式本身看出来。比如<em>Hill</em>和<em>Marty</em>将<em>Amdahl</em>定律扩展到多核处理器。他们用一个简单的硬件<em>cost model</em>增强了<em>Amdahl</em>定律，并探讨了对称(同质)、非对称(异构)和动态多核处理的影响。尽管它很简单，但它提供了基本的见解，并揭示了多核时代的各种重要成果。</p><h2 id="4-1-经验建模与机械建模">4.1 经验建模与机械建模</h2><p>在本章中，我们将分析性能建模的最新工作分为三大类：经验建模、机械建模和经验-机械混合建模。机械建模基于第一原则构建性能模型，也就是说，性能模型是基于对底层系统机制的基本理解，以自底向上的方式构建的。机械建模可以看作是“白盒”性能建模，它的主要特征是提供基本的洞察力，并可能产生新的知识。另一方面，经验建模通过“黑盒”方法构建性能模型。经验建模通常利用统计推断和机器学习技术，比如回归建模或神经网络，从训练数据中自动学习出性能模型。虽然由于底层系统的复杂性，通过经验建模推断性能模型更容易，但它通常比机械建模提供更少的洞察力。机械-经验混合建模方法是机械建模和经验建模的折中，它可以被视为“灰盒”建模。混合机械-经验模型从一个通用的性能公式开始，该公式来源于对底层系统的见解；然而，这个公式包含了一些未知的参数。然后通过拟合(比如回归)来推断这些未知参数，类似于经验建模。混合机械-经验建模的动机是它提供了洞察力（它继承自机械建模），同时简化了性能模型的构建（它继承自经验建模）。</p><p>尽管区分了经验建模和机械建模，但并不存在纯粹的经验建模或机械建模。例如在建模假设和近似中，机械建模总是包含某种形式的经验主义。同样地，经验建模总是包含一个机械组件，例如，在模型的输入列表中—模型输入列表是基于对底层系统的一些理解构建的。因此，经验建模和机械建模之间的区别是相对的，我们的分类基于建模中经验与机械的支配地位，现在将更详细地描述这三种建模方法。</p><h2 id="4-2-经验建模">4.2 经验建模</h2><p>虽然经验建模允许用户将领域知识嵌入到模型中，但没有这些先验知识依然能构建出有效的模型。这种灵活性可能解释了这种建模技术最近的流行性。不同的研究小组提出了不同的经验建模方法，这里将重新讨论。</p><h3 id="4-2-1-线性回归">4.2.1 线性回归</h3><p>线性回归是一种广泛使用的经验建模方法，它将响应变量与许多输入参数联系起来。<em>Joseph</em>等人将该技术应用于处理器性能建模，并建立了将微架构参数(以及它们之间的一些交互)与处理器整体性能联系起来的线性回归模型。他们只使用线性回归来检验设计参数的显著性，即他们没有使用线性回归进行预测建模。在这个意义上，线性回归类似于前面章节讨论的PCA和Plackett-Burman方法。接下来将讨论更先进的回归技术，包括非线性和基于样条的回归，它们已经成功地应用于预测建模。由于更高级的回归方法是在线性回归的基础上进行扩展的，所以在这里先讲述下线性回归。</p><p>线性回归最简单的形式是：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>β</mi><mi>i</mi></msub><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">y=\beta_0 + \sum_{i=1}^n \beta_i x_i + \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是因变量，也被称为响应变量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是自变量，也称为输入变量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>是由于未拟合产生的误差项。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\beta_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>系数表示输入变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>每单位变化对应因变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的期望变化，即回归系数代表了各自变量的显著性或重要性。线性回归模型可能会将性能(因变量)与一组微架构参数(自变量)联系起来，后者可以是处理器带宽、管道深度、缓存大小、缓存延迟等。换句话说，线性回归尝试找到许多数据点的最佳线性拟合，如图4.1所示。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241218-011011.jpg" alt=""></p><p>这个简单的线性回归模型假设输入变量是彼此独立的，即变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对因变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的影响不依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo mathvariant="normal">≠</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j\neq i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。在许多情况下，这不是一个准确的假设，特别是在计算机体系结构中。比如使得处理器流水线更深对性能的影响取决于内存层次结构的配置。更激进的内存层次结构可以减少<em>cache</em>未命中率，从而减少访存平均耗时并增加流水线的优势。因此，在回归模型中是有可能要考虑变量间的相互影响：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机架构性能评估方法》第五章 仿真</title>
      <link href="/2024/11/06/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/11/06/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机架构性能评估方法-第五章-仿真">《计算机架构性能评估方法》第五章 仿真</h1><blockquote><p>Copyright © 2010 by Morgan &amp; Claypool<br>All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in<br>any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations in<br>printed reviews, without the prior permission of the publisher.<br>Computer Architecture Performance Evaluation Methods<br>Lieven Eeckhout<br><a href="http://www.morganclaypool.com">www.morganclaypool.com</a><br>ISBN: 9781608454679 paperback<br>ISBN: 9781608454686 ebook<br>DOI 10.2200/S00273ED1V01Y201006CAC010<br>A Publication in the Morgan &amp; Claypool Publishers series<br>SYNTHESIS LECTURES ON COMPUTER ARCHITECTURE<br>Lecture #10<br>Series Editor: Mark D. Hill, University of Wisconsin<br>Series ISSN<br>Synthesis Lectures on Computer Architecture<br>Print 1935-3235 Electronic 1935-3243</p></blockquote><p>仿真是计算机体系结构中普遍使用的性能评估方法。它被广泛使用有以下几个原因：</p><ol><li>分析建模方法尽管评估速度非常快，并且提供了深刻的洞察力，但对于架构师需要做出很多的设计决策而言引入了太多的不准确性。分析建模对于制定高层次设计决策和在庞大设计空间中识别感兴趣的区域非常有价值，然后使用分析建模方法很难评估各种设计方法导致的细微性能变化。</li><li>另一方面，硬件原型虽然非常准确，但开发起来非常耗时且昂贵。</li></ol><p>仿真器<em>sinmulator</em>是处理器体系架构的性能模型软件。仿真器所建模的处理器架构称为目标架构，在物理机器上运行仿真器就能得到性能结果。相较于构建硬件原型相比仿真有着非常重大优势，它开发相对便宜，并且通常比分析建模要准确得多。此外，仿真器非常灵活且易于参数化，这样便于探索架构设计空间，评估一个新颖的设计想法，这对于计算机架构师设计一个处理器和相关的研究者而言是非常重要的特性。比如，可以通过参数化，比如改变仿真器某些参数并在各种<em>benchmark</em>上跑仿真就能评估<em>cache</em>大小、延迟、处理器带宽和分支预测器的影响，评估出一个架构特性所带来的影响。仿真甚至能对当今非常不同的体系架构进行评估。</p><h2 id="5-1-计算机架构师的工具箱">5.1 计算机架构师的工具箱</h2><p>仿真有很多方法，每种方法代表了在准确性、评估时间、开发时间和覆盖范围间进行取舍。精度是指仿真模型相较于真实硬件的保真度，评估时间是指跑一次仿真需要多长时间，开发时间是指开发仿真器的所需时间，最后覆盖范围是指仿真器能探索的设计空间大小，例如一个<em>cache</em>仿真器仅能被用于评估计算机<em>cache</em>性能，而不是处理器的整体性能。</p><p>仿真器的权衡/取舍可以描述为图5.1所示的菱形，每种仿真方法或者一般的建模工作都可以按照这四个维度进行表征描述。这些维度不是彼此相互独立的，事实上它们是相互矛盾的。例如，通过建模附加特性可以对真实硬件进行更忠实地建模，这样增加了仿真器的覆盖范围，提高了仿真的准确度，但同时也增加了仿真器的开发时间和评估时间，因为仿真器将构建得更加复杂，并且由于增加的复杂度，会导致仿真跑得更慢执行时间更长。相反，如果一个仿真器仅对整个系统的一个组件进行建模，比如针对分支预测器或者<em>cache</em>，虽然相较于整个系统覆盖范围有限，但由于其相对简单且跑起来很快，开发时间和评估时间就会短，对于研究的组件的准确度就会很高非常有价值。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20241106014117.jpg" alt=""></p><p>后续部分会描述计算架构师工具箱中常用的几种仿真技术，每种仿真技术代表了在准确性、覆盖率、开发时间和评估时间方面的不同权衡取舍。表5-1总结了四个维度上不同的仿真技术。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241110-210115.jpg" alt=""></p><h2 id="5-2-功能性仿真">5.2 功能性仿真</h2><p>功能性仿真只对一个指令集架构<em>ISA</em>的功能特性进行建模，它不提供任何的时间估计。即任何一时刻仅仿真一个指令，获得输入值然后计算输出值。因此，功能性仿真器也被称为指令集模拟器。这些工具通常对于验证设计的正确性非常有用，而不适用于评估它的性能特征。所以，关于性能和实现细节的准确度和覆盖率是不适用的。然而，功能性仿真在开发时效方面很优秀，因为在硬件项目开发时通常已经就存在了功能仿真器，除非处理器实现了一套全新的指令集。功能仿真器具有很长的生命周期，它可以跨越许多开发项目。功能性仿真在评估时间方面很快，因为不需要对微架构特性进行建模。功能仿真器的例子是<em>sim-safe</em>和<em>sim-fast</em>。</p><h3 id="插桩">插桩</h3><p>功能仿真的另一种选择是插桩，也被称作直接执行。检测获取一个二进制文件并向其中添加代码，以便在实际硬件上运行经过插桩的二进制文件时收集感兴趣的属性。例如，如果目标是生成内存地址的追踪，则只需对可执行二进制文件中引用内存的每个指令进行检测，然后在本机硬件上运行经过插桩的二进制可执行文件就能得到对内存地址的追踪。插桩相较于功能性仿真的优势在于它带来的开销更小。插桩在真实硬件上本地执行所有指令，相反功能性仿真模拟所有指令因此每条目标指令会执行更多的主机指令。存在两种检测类型：静态插桩只静态地插桩二进制文件；动态插桩在运行时动态地插桩运行的二进制机器指令。静态插桩的例子是<em>Atom</em>和<em>EEL</em>，而<em>Embra</em>、<em>Shade</em>和<em>Pin</em>支持动态插桩。与功能性仿真相比，插桩的局限性在于目标指令集架构通常与主机的指令集架构相同，因此插桩框架不容易移植。就像<em>Shader</em>框架中所做的那样，动态插桩二进制翻译器可以将主机指令集架构的指令翻译成目标指令集架构的指令来解决这个问题。但是，仿真器只能在实现了目标指令集架构的机器上运行。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241110-214436.jpg" alt=""></p><p><em>Burtscher</em>和<em>Ganusov</em>提出了一种将插桩的速度和功能性仿真的可移植性相结合的方法，参见图5.2。他们提出一个功能性仿真器合成器，它将一个二进制可执行文件以及一个包含所有支持指令的C定义代码片段的文件作为输入，然后合成器将二进制指令翻译成C语句。如果需要，用户可以添加模拟代码来收集比如指令或地址的追踪。编译合成后C代码生成定制的功能仿真器。</p><h3 id="操作系统的影响">操作系统的影响</h3><p>功能性仿真通常仅限于用户级代码，比如应用程序和系统库代码，然而它并不能仿真模拟操作系统调用或中断时发生的情况。为了获得功能正确的执行，需要仿真模拟影响应用代码的操作系统影响。一种常见的方法是忽略中断并模拟操作系统调用的效果。仿真模拟系统调用通常是通过手动识别系统调用的输入寄存器、输出寄存器和内存状态，并本地调用系统调用来完成。对于每个系统调用都需要这么做，这是一项繁琐且费力的工作，特别是当希望将一个仿真器移植到新版本的操作系统或者非常不一样的操作系统上。</p><p><em>Narayanasamy</em>等人提出了一种自动捕捉操作系统交互副作用的技术，一个插桩的二进制代码收集每个执行的系统调用、中断和DMA传输，记录它如何改变寄存器状态和内存状态。只有当内存位置稍后被一个<em>load</em>操作读时才会记录内存状态的改变。具体是按如何方式做的：插桩的二进制代码维护应用程序地址空间的一份用户级副本。操作系统的影响诸如系统调用、中断和DMA传输，只会影响应用程序的地址空间，而不是用户级的副本。应用程序的写操作更新了应用程序的地址空间和用户级的副本。应用程序的读操作会验证在应用程序地址空间读到数据是否与用户级副本中读到的数据匹配，如果不匹配仿真器就判定是由于操作系统的影响导致应用程序状态的改变，因此它知道需要记录应用程序地址空间中的负载值，这些状态变化存储在一个称为操作系统影响的日志中。在功能性仿真期间，当触发一个系统调用时会读取操作系统影响日志，日志中记录的状态改变会重放一遍，即修改仿真模拟的寄存器和内存状态以模拟系统调用带来的影响。因为这个过程不依赖于系统调用的语义，它是完全自动的，这就简化了开发和移植用户级仿真器。这个技术的副作用是它支持确定性的仿真，即操作系统的影响在运行时是相同的。虽然这样有助于比较不同的设计方案，但它也有缺陷，将在5.6.2节中讨论。</p><h2 id="5-3-全系统仿真">5.3 全系统仿真</h2><p>用户级仿真对于一些工作负载<em>workload</em>已经足够准确了，比如<em>SPEC CPU benchmarks</em>花费很少时间执行系统级代码，因此将仿真模拟限制为用户级代码就足矣了。然而对于其它的工作负载<em>workload</em>，比如商业工作负载数据库服务器、web服务器、电子邮件服务器等等，对它们仅仅仿真模拟用户级代码是明显不够的，因为这些工作负载<em>workload</em>花费了相当多的时间执行系统级代码，因此这些工作负载<em>workload</em>需要全系统仿真模拟。此外，多核硬件的激增增加了全系统仿真的重要性，因为多线程负载<em>workload</em>性能会收到操作系统调度决策的影响，不对操作系统进行仿真模拟可能导致不准确的性能指标，因为这样没有考虑操作系统的影响。</p><p>全系统仿真是指仿真模拟整个计算机系统，这样使得完整的软件栈能跑在仿真模拟器上。软件栈包括应用程序以及未修改的商业操作系统，这样仿真包括IO和操作系统活动，其次是处理器和内存活动。换言之，全系统仿真可以被看做是一个系统仿真模拟器或者一个系统虚拟机，它对用户来说就是虚拟硬件，它给全系统仿真模拟器的用户提供了就像跑在真实硬件上的假象。比较知名的全系统仿真模拟器例子有<em>SimOS</em>、<em>SimICs</em>、<em>SimNow</em>、<em>M5</em>、<em>Bochs</em>、<em>QEMU</em>和<em>Mambo</em>。</p><p>全系统仿真模拟器提供的功能与用户级功能仿真模拟器基本相同，两者都是提供对动态执行指令的追踪，唯一的区别是功能仿真模拟器只仿真用户级代码指令，而全系统仿真模拟器要同时仿真模拟用户级和系统级代码。因此与用户级仿真相比，全系统仿真实现了更大的覆盖范围，然而开发一个全系统仿真器远非易事。</p><h2 id="5-4-专门追踪驱动仿真">5.4 专门追踪驱动仿真</h2><p>专门追踪驱动的仿真采用指令和地址跟踪，这些追踪可能只包括用户级指令，也可能同时包括用户级和系统级指令，来孤立地仿真目标架构的特定组件，比如<em>cache</em>或者分支预测器。性能表现通常以未命中率来评估。有很多被广泛使用的工具，特别是对于<em>cache</em>仿真有<em>Dinero IV</em>。此外，针对在一次仿真模拟运行中仿真多个<em>cache</em>配置已经提出了几条建议。虽然开发时间和评估时间都很好，但覆盖范围比较有限，因为只对一个处理器的特定组件进行了建模。而且虽然未命中率指标的准确性很好，但由于许多其它因素的影响，处理器整体性能仅与这些未命中率大致相关。专门的跟踪驱动仿真在工具箱中仍占有一席之地，因为它提供了一种评估处理器特定层面的一种轻松方法。</p><h2 id="5-5-追踪驱动仿真">5.5 追踪驱动仿真</h2><p>完整的追踪驱动仿真，或者简称未追踪驱动仿真，采用程序指令和地址追踪，并将完整的<em>benchmark</em>追踪提供给详细的微架构时序仿真模拟器。一个追踪驱动仿真器将功能仿真与时序仿真分离开来。这通常很有用，因为功能仿真只需要执行一次，而在评估不同微架构时详细的时序仿真要执行很多次。这种分离一定程度上减少了评估时间。总的来说，完整的追踪驱动仿真需要很长的开发时间，也需要很长的仿真执行时间，但它在准确性和覆盖率上都非常好。</p><p>这种方法的一个明显缺点是需要存储追踪文件，对于当前的基准测试和运行时间合唱的计算机程序而言，追踪文件可能非常大。虽然现在磁盘空间已经非常便宜，但是可以使用追踪压缩来解决这个问题，针对计算机追踪压缩已经提出了几种方法。</p><p>现代超标量处理器的另一个缺点是它们预测分支并推测地执行很多指令，沿着错误预测的推测执行指令后续将被取消。这些无效的指令不会显示在通过功能性仿真生成的追踪文件中，尽管它们可能影响<em>cache</em>或预测器的内容。因此追踪驱动仿真并不能准确地仿真模拟出沿着错误预测路径的影响。</p><p>模拟多线程工作负载<em>workload</em>时的另一个限制是追踪驱动仿真不能对线程间次序和目标微架构进行建模。原因是追踪是固定的，并且施加了特定的顺序。对于一些研究，这种影响可能是有限的，然而对于其它研究来说，这可能是重要的。这一切都取决于优化的类型和评估的工作负载。关键问题是某些微架构的变化，例如分支预测器、<em>cache</em>、预取器等，甚至是很小的变化就可能导致线程以不同的顺序获取锁。这可能会导致共享资源，比如缓存、内存、互联网络等出现不同的冲突和争用行为，进而影响线程的交错并行。因此，即使是微体系结构中的微小变化也可能导致非常不同的性能数字，并且这些变化可能对于特定的基准测试出现巨大差异，所以一个特定基准测试的大变化可能不能代表其它工作负载。由于追踪驱动仿真模拟的时单个线程次序，它并不能捕捉这些影响。此外，追踪可能反映甚至可能不会出现在目标微体系结构上的特定次序。</p><h2 id="5-6-执行驱动仿真">5.6 执行驱动仿真</h2><p>与追踪驱动仿真相比，执行驱动仿真结合了功能仿真和时序仿真。为了做到这一点，它消除了追踪驱动仿真的缺点，即不需要存储追踪文件，可以准确地模拟推测执行的指令，并且可以准确地建模多线程工作负载。由于以上这些原因，执行驱动仿真已经成为实际上常用的仿真方法。执行驱动的仿真器有<em>SimpleScalar</em>、<em>RSIM</em>、<em>Asim</em>、<em>M5</em>、<em>GEMS</em>、<em>Flexus</em>和<em>PLTSim</em>。尽管执行驱动仿真相比于追踪驱动仿真实现了更高的准确度，但它是以增加开发时间和评估时间为代价的。</p><h3 id="5-6-1-分类">5.6.1 分类</h3><p><em>Manuer</em>等人针对执行驱动仿真器提出了一种有用的分类方法，参见图5.3。该分类方法反映了四种不同的方式来耦合功能和时序组件，以管理仿真器的复杂性和开发时间。一个紧密集成功能和时序组件的执行驱动仿真器，因此被称为集成的执行驱动仿真器(见图5.3a)，显然更难以开发和维护。一个集成仿真器并不灵活，难以扩展(比如在评估新的体系架构时)，并且存在潜在的风险就是修改时序组件可能意外地往功能组件中引入错误。此外，如前所述，功能模型往往变化很小，然而，在架构探索的过程中时序模型可能会发生很大的变化。因此，从仿真器的复杂性和开发的角度来看，将功能部分与时序部分解耦开是可取的。现在讨论的解耦方法有很多种：</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241117-223327.jpg" alt=""></p><p><strong>时序驱动仿真</strong></p><p>时序驱动仿真器允许时序仿真器驱动功能仿真器去沿着错误预测的路径获取指令，并选择特定的线程交错(图5.3b)。<em>Asim</em>就是一个时序驱动的仿真器。功能模型跟踪体系结构的状态，比如寄存器和内存值。时序模型没有值的概念，相反它从功能模型中获取有效地址，并使用它来确定缓存是否命中，访问分支预测器等。功能模型可以被视为时序模型调用的一系列函数调用，以便在精确的模拟时间执行特定的功能任务。需要组织功能模型以使其能够部分地模拟指令。特别是功能仿真器需要解码、执行、执行内存操作(访存)、终止和提交指令的能力。然后时序模型会调用功能模型来在正确的时间以正确的顺序执行特定的任务。例如，当仿真在一个加载单元上执行<code>load</code>指令时，时序模型会要求功能模型计算<code>load</code>的有效地址。然后将这个地址发送回时序模型，该模型随后会确定这个<code>load</code>指令是否会发生一次<em>cache</em>未命中。根据时序模型，只有当<em>cache</em>命中访问返回或者<em>cache</em>未命中从内存返回时，功能仿真器才会从内存读取该值。这确保<code>load</code>指令读取到与目标体系结构完全相同的数据。当<code>load</code>提交进目标体系架构时，指令也同样提交进功能模型中。功能模型还跟踪足够的内部状态，以便在发现指令沿着错误预测路径执行时可以在功能模型中终止该指令。</p><p><strong>功能优先仿真</strong></p><p>在功能优先仿真模型(图5.3c)中，功能仿真器将指令追踪输入时序仿真器。这类似于追踪驱动仿真，不同之处在于追踪不需要存储在磁盘上；追踪可以通过Unix管道从功能仿真器传送到时序仿真器。</p><p>为了能够沿着错误预测路径进行仿真，并对时序相关的线程间顺序和依赖关系进行建模，功能模型提供了回滚来恢复之前的状态。特别是在执行分支时，功能模型不知道分支是否被错误预测——只有时序仿真器知道——因此，它将只执行正确路径的指令。当时时序仿真器在取指阶段检测到错误预测分支时，功能仿真器需要重定向去沿着错误预测分支获取指令。这要求功能仿真器回滚到分支之前的状态，并沿着错误预测的分支路径向时序仿真器提供指令。在时序模型中解决了错误预测的分支后，功能模型需要再次回滚，然后开始向时序模型提供正确路径的指令。换言之，功能模型正在推测分支分支将采取的路径，即它推测该分支将被时序模型正确地预测。</p><p>如前所述，线程间依赖肯呢个取决于时序，也就是说时序的微小变化可能会改变线程获取锁的顺序，从而可能改变功能和性能。这也适用于功能优先的仿真器：功能模型和时序模型之间的计时可能不同，因此功能模型获取锁的顺序不一定与时序模型中观察到的顺序相同。这个排序问题基本上归结为<code>load</code>是否在功能和时序模型中读取相同的数据。因此，功能优先仿真可以通过跟踪功能模型和时序模型中读取到的数据来处理这个顺序问题。仿真器让功能模型提前运行，但是当时序模型检测到在目标体系结构中读取的数据将与和功能模型中读取的数据不同时，它会回滚模型，并请求功能模型使用正确的数据重新执行<code>load</code>指令，这称为推测功能优先仿真。解决顺序问题的代价是在时序仿真器中跟踪目标内存状态，并比较功能仿真器和时序仿真器的数据。</p><p><em>Argollo</em>等人提出了<em>COTSon</em>仿真基架，该设施采用AMD的<code>SimNow</code>功能仿真器将指令跟踪发送至时序仿真器。<em>COTSon</em>的主要重点是去模拟复杂的基准测试，比如商用操作系统和多层应用，以及向外扩展和仿真模拟大核心数。为了管理仿真器复杂度并提高仿真速度，<em>COTSon</em>不提供回滚功能，而是实现时序反馈，这使得时序仿真器可以调整功能仿真器的速度以反映时序估计。</p><p>综上所述，功能优先仿真的关键优势在于它允许功能仿真器在时序仿真器之前运行，并利用并行性，即并行运行功能和时序仿真器。相较于时序驱动仿真(时序模型在每个指令/周期驱动功能模型)，功能优先仿真提高了仿真器的性能，比如减少了评估时间，并降低了整个仿真器的复杂性。</p><p><strong>时序优先仿真</strong></p><p>时序优先仿真使时序模型先于功能模型运行，见图5.3。除了微体系结构状态之外，时序仿真器还对体系结构的特性(寄存器和内存状态)进行了建模，大部分都是正确的。这允许沿着错误预测的分支准确地建模推测性执行，以及线程间事件的顺序。当时序模型提交指令时，即当指令变为非推测性时，功能模型验证时序仿真器是否偏离了功能模型。当时序仿真器出现偏差时，由功能仿真器进行修复。这意味着在重新启动时序仿真器之前，体系结构状态将被重新加载，微体系结构状态将被重置。换句话说，时序优先仿真由一个几乎正确集成了的执行驱动仿真器(时序仿真器)组成，该仿真器由一个功能正确的功能仿真器检查。</p><p>时序优先仿真器比完全集成的仿真器更容易开发，因为时序仿真器不需要实现所有指令。指令子集对性能很重要，并且很好地涵盖动态执行的指令就足够了。与时序驱动仿真相比，时序优先仿真对功能仿真器的要求较少，而对时序仿真器的要求较多。</p><h3 id="5-6-2-处理非确定性">5.6.2 处理非确定性</h3><p>在执行驱动仿真器上模拟多线程工作负载时，必须处理的一个重要挑战是不确定性——<em>Alameldeen</em>和<em>Wood</em>对不确定性进行了全面的评估。不确定性指的是这样一个事实，即很小的时间变化可能导致从相同初始状态开始的执行遵循了不同的执行路径。非确定性在真实硬件和仿真中都存在。在实际硬件上，时序变化有各种来源，例如中断、I/O、与直接内存访问(DMA)的总线争用、DRAM刷新等。在比较体系架构设计方案时，还可以在仿真过程中观察到非确定性。例如，可能有雨多种原因，某些设计参数的更改(例如缓存大小、缓存延迟、分支预测器配置、处理器宽度等)可能导致不确定性。</p><ul><li>操作系统可能在不同的运行过程中做出不同的调度决策。例如，调度量可能在一次运行中在I/O事件之前结束，而在另一次运行中则不会结束。</li><li>线程可能以不同的顺序获得锁。这可能导致执行自旋锁循环指令所花费的周期和指令数在不同的体系结构中有所不同。</li><li>以不同相对速度运行的线程可能会导致不同的缓存一致性流量以及共享资源中的冲突行为。例如，共享多核缓存中的冲突行为在不同的架构设计中可能是不同的；同样，互连网络中的争用也可能不同。</li></ul><p>在架构探索过程中，不确定性使得比较不同设计方案变得非常复杂。时间差异可能导致仿真的<em>workload</em>由不同的性能特征采取不同的执行路径。因此很难比较不同的设计方案。如果执行路径的变化差异很重要，比较仿真就变得不可靠了，因为在不同的执行中完成的工作量和类型是不同的。最基本的问题是，在不同的设计方案之间观察到的性能差异是由于设计方案差异还是由于执行<em>workload</em>差异导致的。不解决这个问题可能会导致不正确的结论。</p><p><em>Alameldeen</em>和<em>Wood</em>提出了一个简单的实验，清晰地说明了在仿真中处理不确定性的必要性。他们考虑OLTP工作负载<em>workload</em>，并观察到性能随着内存访问时间的增加而增加，例如84-ns DRAM的性能比81-ns DRAM的性能提高7%。当然，这是没有意义的——没有一个计算机架构师会得出内存越慢性能越好的结论。尽管这个结论在这个简单的实验中是明显的，但在更复杂、更不直观的设计研究中可能不那么明显。对于如何处理不确定性，有三种可能的解决方案。</p><p><strong>长时间跑仿真</strong></p><p>一种解决方案是仿真足够长的时间，比如仿真模拟几分钟而不是几秒钟。不确定性可能在长期仿真模拟实验中基本被消除，然而考虑到计算机架构仿真非常缓慢，这个方法在实践中并不可行。</p><p><strong>消除不确定性</strong></p><p>第二种方法就是消除不确定性。<em>Lepak</em>等人和<em>Pereira</em>等人提出了在执行驱动仿真器上仿真不同架构配置时提供多线程程序可再现行为的方法；<em>Lepak</em>等人考虑的是全系统仿真，而<em>Pereira</em>等人关注的是用户级仿真。这些方法通过保证执行相同的执行路径来消除不确定性：它们通过引入人工熄火(突然中断)来强制跨仿真的共享内存访问顺序相同；此外，在仿真过程中，中断被强制触发在特定的点上。<em>Lepak</em>等人和<em>Pereira</em>等人的方法都提出了一个度量指标和方法来量化执行在多大程度上被迫是确定性的。引入熄火意味着在每个仿真中要完成相同数量的工作；因此，可以基于单个仿真比较不同的设计方案。强制确定性的缺陷在于它可能导致在真实系统中可能永远不会发生的执行。换句话说，对于易受不确定性影响的工作负载<em>workload</em>，这个方法可能没有用处。因此，正如<em>Lepak</em>等人所承认的那样，必须谨慎使用确定性仿真。</p><p>注意，跟踪驱动的仿真还完全消除了不确定性，因为跟踪中的指令在不同的系统中是完全相同的。然而，跟踪驱动的仿真也受到同样的限制：它不能恰当地评估影响线程交互的体系结构设计。</p><p><strong>统计方法</strong></p><p>第三种方法是使用(经典的)统计方法得出有效确凿的结论。<em>Alameldeen</em>和<em>Wood</em>提出在仿真过程中人为地注入小的时间变化。更具体地说，他们通过在DRAM访问延迟中添加0到4 ns之间的均匀分布随机数，以在内存系统定时中注入微小的变化。这些随机注入的扰动产生了从相同初始条件开始的一系列可能的执行——注意，仿真器是确定性的并且将总是产生相同的时间，因此需要引入随机扰动。然后他们多次运行仿真，并计算这些运行的平均值及其置信区间。</p><p>这种方法的一个明显缺点是它需要多次运行仿真，这延长了总仿真时间。与消除不确定性的方法相比，这个方法更加耗时。但是，这是通过仿真获得可靠性能数值的最佳方法。此外，运行多个(小型)仿真可能比执行一个长时间仿真更节省时间。</p><h2 id="5-7-模块化仿真基架">5.7 模块化仿真基架</h2><p>周期精确的仿真器是极其复杂的软件，与它们所建模的微架构相当。与任何其他大型软件项目一样，确保良好的软件结构对于保持开发过程的可管理性至关重要。模块化和可复用性是提高模型开发的可管理性和速度的两个关键目标。模块化指的是将性能建模问题分解为可以单独建模的更小的部分。可复用性是指在不同的应用环境中复用不利的组件。模块化和可复用性提供了很多好处，它提高了建模效率和性能模型的保真度(因为单个组件可能已经在不同的上下文中使用和验证过)；它允许跨项目共享单个组件，甚至在生产环境中跨产品和代际；它促进了体系架构实验，比如可以很容易地交换组件同时保持其余的性能模型不变。有所的这些好处都会缩短整体的开发时间。</p><p>一些仿真基础设施实践了模块化原则，例如<em>Asim</em>，<em>Liberty</em>，<em>MicroLib</em>，<em>UNISIM</em>和<em>M5</em>。模块化仿真基础设施通常提供一个仿真器基础设施，用于创建多个性能模型而不是仅有一个性能模型。<em>Asim</em>特别考虑了作为基础软件组件的模块。模块代表目标设计的物理组件(例如，缓存，分支预测器等)或硬件算法的操作(例如，缓存替换策略)。每个模块提供一个良好定义的接口，支持模块复用。开发人员可以为仿真基础设施贡献新的模块，只要他们实现模块接口，比如分支预测器应该实现分支预测器的三种方法：获得分支预测，更新分支预测器和处理错误预测的分支。<em>Asim</em>附带了架构师工作台，允许通过选择和连接模块来组装性能模型。</p><h2 id="5-8-仿真加速的需要">5.8 仿真加速的需要</h2><p>周期精确的仿真非常缓慢，这是当今架构研究和研发中的一个关键问题。最根本的原因是正在建模的微架构非常复杂。今天的处理器由数亿甚至数十亿个晶体管组成，它们实现了复杂的功能，如内存层次结构、推测执行、乱序执行、预取等。此外，多核处理的趋势进一步加剧了这个问题，因为现在需要模拟多核以及它们在共享资源中的相互作用。如此庞大的晶体管数量导致了一个非常大而复杂的设计空间，需要在新的微架构的设计周期中进行探索。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20241121-013208.jpg" alt=""></p><p>虽然直觉和分析建模可以帮助指导设计过程，但最终架构师必须依赖详细的周期精确仿真，以便在这个复杂的设计空间中做出正确的设计决策。微体系结构的复杂性明显地反映在性能模型的复杂性和速度上。周期精确的仿真模型非常慢。<em>Chiou</em>等人概述了当今仿真器的典型仿真速度，参见表5.2。学术界的仿真器的速度范围在69 KIPS和740 KIPS之间，它们通常比在1 KHz到200 KIPS速度范围内运行的工业界仿真器更快。换句话说，仅仿真(目标系统的)一秒钟的实时时间可能会耗费数小时甚至数天的仿真时间，即使是在当今最快的机器上运行的最快的仿真器上也是如此。这只是仿真一个设计点。架构师通常会运行许多仿真，以便深入了解设计空间。考虑到设计空间是巨大的，需要运行的仿真数量可能非常大，这可能会使得探索设计空间很快变得不可行的。</p><p>更糟糕的是，正在仿真的基准测试的复杂性也在增长。鉴于处理器变得越来越强大，基准测试需要变得更加复杂。在过去，在多核时代之前虽然单线程性能呈指数级增长，但基准测试需要执行更多指令并访问更多数据，以便以有意义的方式给当前和未来的处理器施加负载压力。比如SPEC CPU基准测试的复杂性大幅提高：动态指令数量从CPU89的平均25亿个动态执行指令增加到CPU2000的2300亿个指令，CPU2006的平均2.5亿条指令。现在在多核时代，为了强调设计中的多核处理器，基准测试将需要越来越多线程化。</p><p>周期精确仿真速度慢是一个众所周知且长期存在的问题，研究人员提出了各种解决方案来解决这一重要问题。由于其重要性，本书的其余部分致力于讲解提高仿真速度的技术。采样仿真将在第6章中介绍，它可能是最广泛使用的仿真加速技术，通过只仿真长时间运行基准中的一小段代码来减少仿真时间。我们将在第7章中重新讨论统计仿真，它采用不同的方法提高仿真速度，主要是通过生成代表长时间运行基准测试的小型工作负载<em>workload</em>，并且同时降低仿真器的复杂性。统计仿真的目的仅仅是作为一种快速探索设计空间的技术，与详细的周期精确模拟相补充。最后在第8章中描述了利用并行性来加速仿真的三种方法：(i)在并行机器上分布式运行仿真；(ii)并行化仿真器以在主机器的并行性中受益；(iii)通过将仿真器映射到可重构硬件(即fpga)上来利用细粒度并行性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库打桩机制</title>
      <link href="/2024/09/02/%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/09/02/%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近做内存仿真相关研发时用到了打桩机制，相关总结如下：</p><p>Linux链接器支持一个很强大的技术，称为库打桩，它允许程序员截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。</p><p>下面是它的基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。</p><p>打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。要研究这些不同的机制，后面会一个示例程序作为运行例子。它调用C标准库(<code>libc.so</code>)中的<code>malloc</code>和<code>free</code>函数，对<code>malloc</code>的调用从堆中分配一个32字节的块，并返回指向该块的指针；对<code>free</code>的调用把块还给堆，供后续的<code>malloc</code>调用使用。目标就是用打桩来追踪程序运行时对<code>malloc</code>和<code>free</code>的调用。</p><h2 id="编译时打桩">编译时打桩</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiletime/int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiletime/malloc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfree</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiletime/mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILETIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d)=%p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfree</span><span class="params">(<span class="type">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的代码展示了如何使用C预处理在编译时打桩，<code>mymalloc.c</code>中的包装函数调用目标函数，打印追踪记录并返回。本地的<code>malloc.h</code>头文件指示预处理器用对相应包装函数的调用替换掉对目标函数的调用。像下面这样编译和链接这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -DCOMPILETIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -I. -o intc int.c mymalloc.o</span></span><br></pre></td></tr></table></figure><p>由于有<code>-I.</code>参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找<code>malloc.h</code>。注意，<code>mymalloc.c</code>中的包装函数是使用标准<code>mallo.h</code>头文件编译的。</p><p>运行这个程序会得到如下的追踪信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">./intc</span> </span><br><span class="line">malloc(32)=0x55718fd292a0</span><br><span class="line">free(0x55718fd292a0)</span><br></pre></td></tr></table></figure><h2 id="链接时打桩">链接时打桩</h2><p>Linux静态链接器支持用<code>--wrap f</code>标志进行链接时打桩。这个标志告诉链接器，把对符号<code>f</code>的引用解析城<code>__wrap f</code>，还要把对符号<code>__real_f</code>的引用解析为<code>f</code>。以下是示例程序的包装函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linktime/int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linktime/mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* __real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span>* ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="type">void</span>* __wrap_malloc(<span class="type">size_t</span> size)&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = __real_malloc(size);        <span class="comment">/* call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span>* ptr)&#123;</span><br><span class="line">    __real_free(ptr);                       <span class="comment">/* call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>用下述方法把这些源文件编译成可重定位目标文件，并把目标文件链接成可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -DLINKTIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -c int.c</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o</span></span><br></pre></td></tr></table></figure><p><code>-Wl,option</code>标志把<code>option</code>传递给链接器。<code>option</code>中的每个逗号都要替换为一个空格，所以<code>-Wl,--wrap,malloc</code>就把<code>--wrap malloc</code>传递给链接器，以类似的方式传递<code>-Wl,--wrap,free</code>。</p><p>运行该程序会得到如下追踪信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">./intl</span> </span><br><span class="line">malloc(32) = 0x55d5164c02a0</span><br><span class="line">free(0x55d5164c02a0)</span><br></pre></td></tr></table></figure><h2 id="运行时打桩">运行时打桩</h2><p>编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制基于动态链接器的<code>LD_PRELOAD</code>环境变量。</p><p>如果<code>LD_PRELOAD</code>环境变量被设置为一个共享库路径名的列表(以空格或分号分隔)，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(<code>LD-LINUX.SO</code>)会先搜索<code>LD_PRELOAD</code>库，然后才搜索任何其它的库。有了这个机制，当你加载和执行任意可执行文件时，可以对任何共享库中的任何函数打桩，包括<code>libc.so</code>。</p><p>以下展示了<code>malloc</code>和<code>free</code>的包装函数，每个包装函数中，对<code>dlsym</code>的调用返回指向目标<code>libc</code>函数的指针。然后包装函数调用目标函数，打印追踪记录，再返回：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line"></span><br><span class="line">    mallocp = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);   <span class="comment">/* Get address of libc malloc */</span></span><br><span class="line">    <span class="keyword">if</span>((error = <span class="built_in">dlerror</span>()) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, stderr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">char</span>* ptr = <span class="built_in">mallocp</span>(size);              <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*freep)(<span class="type">void</span>*) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line">    <span class="keyword">if</span>(!ptr) <span class="keyword">return</span>;</span><br><span class="line">    freep = <span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);       <span class="comment">/* Get address of libc free */</span></span><br><span class="line">    <span class="keyword">if</span>((error = <span class="built_in">dlerror</span>()) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, stderr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">freep</span>(ptr);                             <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>下面是如何构建包含这些包装函数的共享库的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span></span><br></pre></td></tr></table></figure><p>然后编译主程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gcc -o intr int.c</span></span><br></pre></td></tr></table></figure><p>从bash shell中运行这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">LD_PRELOAD=<span class="string">&quot;./mymalloc.so&quot;</span> ./intr</span></span><br><span class="line">malloc(32) = 0x1bf7010</span><br><span class="line">free(0x1bf7010)</span><br></pre></td></tr></table></figure><p>注意，可以用<code>LD_PRELOAD</code>对任何可执行程序的库函数调用打桩！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 146 LRU缓存机制</title>
      <link href="/2024/04/01/Leetcode-146/"/>
      <url>/2024/04/01/Leetcode-146/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU缓存 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="双链表-哈希表-o-1">(双链表+哈希表) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>可以使用哈希表来维护整个缓存，哈希表增删改查时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的，这样使得<code>put</code>和<code>get</code>操作的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。为了实现最近最少使用的缓存淘汰机制，还得使用双链表作为一个队列，每次用到一个节点就先将它从双链表中删掉，然后再将它插入到双链表最左侧，如果缓存不够时就将最右侧节点淘汰掉即可。为了方便，双链表的头尾使用虚拟节点，每个节点中除了前后指针外存储<code>key</code>和<code>value</code>，哈希表用于将<code>key</code>映射至双链表中对应节点地址。<br><code>put(key,valye)</code>：首先用哈希表判断<code>key</code>是否存在：如果<code>key</code>存在，则修改对应的<code>value</code>，同时将<code>key</code>对应的节点放到双链表的最左侧；如果<code>key</code>不存在且缓存已满，则删除双链表最右侧的节点(上次使用时间最老的节点)并更新哈希表，然后在双链表最左侧插入<code>(key,value)</code>节点并更新哈希表；否则<code>key</code>不存在且缓存未满，此时直接在双链表最左侧插入<code>(key, value)</code>节点，同时更新哈希表。<br><code>get(key)</code>：首先用哈希表判断<code>key</code>是否存在：如果<code>key</code>存在，则返回对应的<code>value</code>，同时将<code>key</code>对应的节点放到双链表的最左侧；如果<code>key</code>不存在，则返回<code>-1</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>双链表和哈希表的增删改查操作的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以<code>put</code>和<code>get</code>操作的时间复杂度也都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度">空间复杂度</h4><p>使用了双链表和哈希表，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key, val;</span><br><span class="line">        Node* left, *right;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">val</span>(v), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;*L, *R;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; hash;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* p)</span></span>&#123;</span><br><span class="line">        p-&gt;left-&gt;right = p-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node* p)</span></span>&#123;</span><br><span class="line">        p-&gt;left = L;</span><br><span class="line">        p-&gt;right = L-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left = p;</span><br><span class="line">        L-&gt;right = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        n = capacity;</span><br><span class="line">        L = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>), R = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        L-&gt;right = R, R-&gt;left = L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* p = hash[key];</span><br><span class="line">        <span class="built_in">remove</span>(p);</span><br><span class="line">        <span class="built_in">insert</span>(p);</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">count</span>(key))&#123;</span><br><span class="line">            Node* p = hash[key];</span><br><span class="line">            p-&gt;val = value;</span><br><span class="line">            <span class="built_in">remove</span>(p);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">size</span>() == n)&#123;</span><br><span class="line">                Node* p = R-&gt;left;</span><br><span class="line">                <span class="built_in">remove</span>(p);</span><br><span class="line">                hash.<span class="built_in">erase</span>(p-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* t = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            <span class="built_in">insert</span>(t);</span><br><span class="line">            hash[key] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml解析器</title>
      <link href="/2024/03/10/xml%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>/2024/03/10/xml%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>json解析器</title>
      <link href="/2024/03/03/json%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>/2024/03/03/json%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="json简介">JSON简介</h1><h2 id="json定义">JSON定义</h2><p>JSON的全称是&quot;JavaScript Object Notation&quot;，意思是JavaScript对象表示法，它是一种基于文本，独<br>立于语言的轻量级数据交换格式。</p><h2 id="json元素">JSON元素</h2><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20250623-185615.jpg" alt=""></p><h2 id="json规则">JSON规则</h2><ul><li>空值：<code>null</code></li><li>布尔：<code>true</code>、<code>false</code></li><li>数字：<code>123</code>，<code>1.23</code></li><li>字符串：由双引号包裹</li><li>数组(Array)：用方括号<code>[]</code>表示，里面可以包含空值、布尔、数字、字符串、数组、对象</li><li>对象(Object)：用大括号<code>&#123;&#125;</code>表示，里面由键值对组成，键是字符串，值可以是空值、数字、布尔、字符串、数组、对象</li><li>并列的数据之间用逗号<code>,</code>进行分隔</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;work&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;c++&quot;</span><span class="punctuation">,</span> <span class="string">&quot;php&quot;</span><span class="punctuation">,</span> <span class="string">&quot;python&quot;</span><span class="punctuation">,</span> <span class="string">&quot;go&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="json官网">JSON官网</h2><p><a href="https://www.json.org/json-zh.html">https://www.json.org/json-zh.html</a></p><h1 id="json解析器设计与实现">JSON解析器设计与实现</h1><p>特点：</p><ul><li>独立：不依赖第三方库</li><li>跨平台：支持Linux、Windows、MacOS</li><li>简单好用：友好的API，核心的Parse仅200多行代码</li><li>高性能：性能比jsoncpp、nlohmann等高很多</li></ul><h2 id="api设计">API设计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json/json.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> json</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Json</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">// 使用枚举类型来表示不同类型的JSON元素</span></span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">            &#123;</span><br><span class="line">                JSON_NULL = <span class="number">0</span>,</span><br><span class="line">                JSON_BOOL,</span><br><span class="line">                JSON_INT,</span><br><span class="line">                JSON_DOUBLE,</span><br><span class="line">                JSON_STRING,</span><br><span class="line">                JSON_ARRAY,</span><br><span class="line">                JSON_OBJECT</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">Json</span>();</span><br><span class="line">            <span class="built_in">Json</span>(Type type);</span><br><span class="line">            <span class="built_in">Json</span>(<span class="type">bool</span> value);</span><br><span class="line">            <span class="built_in">Json</span>(<span class="type">int</span> value);</span><br><span class="line">            <span class="built_in">Json</span>(<span class="type">double</span> value);</span><br><span class="line">            <span class="built_in">Json</span>(<span class="type">const</span> <span class="type">char</span> * value);</span><br><span class="line">            <span class="built_in">Json</span>(<span class="type">const</span> string &amp; value);</span><br><span class="line">            <span class="built_in">Json</span>(<span class="type">const</span> Json &amp; other);</span><br><span class="line">            <span class="built_in">Json</span>(Json &amp;&amp; other);</span><br><span class="line">            ~<span class="built_in">Json</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function">Type <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_null</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_array</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_object</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重载类型转换运算符，类型转换运算符必须是类的成员函数，它不能声明返回类型，形参列表必须为空切通常应该是const</span></span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">as_bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">as_int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">double</span> <span class="title">as_double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function">string <span class="title">as_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拷贝赋值运算符首先需要清理释放资源，避免内存泄露</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(<span class="type">bool</span> value);</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(<span class="type">int</span> value);</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(<span class="type">double</span> value);</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> * value);</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp; value);</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Json &amp; other);</span><br><span class="line">            Json &amp; <span class="keyword">operator</span>=(Json &amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">string <span class="title">str</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="comment">// 重载输出运算符，IO运算符必须定义为非成员函数且一般被声明为友元</span></span><br><span class="line">            <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> Json &amp; json)</span><br><span class="line">            &#123;</span><br><span class="line">                os &lt;&lt; json.<span class="built_in">str</span>();</span><br><span class="line">                <span class="keyword">return</span> os;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> Json &amp; value)</span></span>;                <span class="comment">// 向json数组中添加元素</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(Json &amp;&amp; value)</span></span>;                     <span class="comment">// 向json数组中添加元素，避免深拷贝</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">has</span><span class="params">(<span class="type">int</span> index)</span></span>;                            <span class="comment">// 判断json数组中是否有该下标</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">has</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * key)</span> <span class="type">const</span></span>;               <span class="comment">// 判断json数组中是否有某个键</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">has</span><span class="params">(<span class="type">const</span> string &amp; key)</span> <span class="type">const</span></span>;             <span class="comment">// 判断json数组中是否有某个键</span></span><br><span class="line">            <span class="function">Json <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span></span>;                            <span class="comment">// 根据下标获取json数组中的元素</span></span><br><span class="line">            <span class="function">Json <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * key)</span></span>;                     <span class="comment">// 根据键获取对应的json对象</span></span><br><span class="line">            <span class="function">Json <span class="title">get</span><span class="params">(<span class="type">const</span> string &amp; key)</span></span>;                   <span class="comment">// 根据键获取对应的json对象</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span></span>;                         <span class="comment">// 根据下标删除json数组中的元素</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * key)</span></span>;                  <span class="comment">// 根据键删除对应的json对象</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> string &amp; key)</span></span>;                <span class="comment">// 根据键删除对应的json对象</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重载下标运算符</span></span><br><span class="line">            Json &amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);                   <span class="comment">// 根据下标获取json数组中的元素</span></span><br><span class="line">            Json &amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">char</span> * key);            <span class="comment">// 根据键获取json对象</span></span><br><span class="line">            Json &amp; <span class="keyword">operator</span>[](<span class="type">const</span> string &amp; key);          <span class="comment">// 根据键获取json对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历数组</span></span><br><span class="line">            <span class="keyword">using</span> iterator = std::vector&lt;Json&gt;::iterator;</span><br><span class="line">            <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (m_value.m_array)-&gt;<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;   </span><br><span class="line">                <span class="keyword">return</span> (m_value.m_array)-&gt;<span class="built_in">end</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// json对象和json数组均有的操作</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buf, <span class="type">int</span> len)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">// 深拷贝</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> Json &amp; other)</span></span>;</span><br><span class="line">            <span class="comment">// 浅拷贝，仅用于移动语义提升性能</span></span><br><span class="line">            <span class="comment">// swap仅交换内容，不拷贝内容</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Json &amp; other)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">union</span> <span class="title class_">Value</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> m_bool;</span><br><span class="line">                <span class="type">int</span> m_int;</span><br><span class="line">                <span class="type">double</span> m_double;</span><br><span class="line">                string * m_string;</span><br><span class="line">                std::vector&lt;Json&gt; * m_array;</span><br><span class="line">                std::map&lt;string, Json&gt; * m_object;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Type m_type;                <span class="comment">// json实际存储的类型</span></span><br><span class="line">            Value m_value;              <span class="comment">// json实际存储的值</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json/json.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/parser.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::json;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>() : <span class="built_in">m_type</span>(JSON_NULL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(Type type) : <span class="built_in">m_type</span>(type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON_NULL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_BOOL:</span><br><span class="line">            m_value.m_bool = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_INT:</span><br><span class="line">            m_value.m_int = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_DOUBLE:</span><br><span class="line">            m_value.m_double = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_STRING:</span><br><span class="line">            m_value.m_string = <span class="keyword">new</span> <span class="built_in">string</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_ARRAY:</span><br><span class="line">            m_value.m_array = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;Json&gt;();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_OBJECT:</span><br><span class="line">            m_value.m_object = <span class="keyword">new</span> std::<span class="built_in">map</span>&lt;string, Json&gt;();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(<span class="type">bool</span> value) : <span class="built_in">m_type</span>(JSON_BOOL)</span><br><span class="line">&#123;</span><br><span class="line">    m_value.m_bool = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(<span class="type">int</span> value) : <span class="built_in">m_type</span>(JSON_INT)</span><br><span class="line">&#123;</span><br><span class="line">    m_value.m_int = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(<span class="type">double</span> value) : <span class="built_in">m_type</span>(JSON_DOUBLE)</span><br><span class="line">&#123;</span><br><span class="line">    m_value.m_double = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(<span class="type">const</span> <span class="type">char</span> * value) : <span class="built_in">m_type</span>(JSON_STRING)</span><br><span class="line">&#123;</span><br><span class="line">    m_value.m_string = <span class="keyword">new</span> <span class="built_in">string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(<span class="type">const</span> string &amp; value) : <span class="built_in">m_type</span>(JSON_STRING)</span><br><span class="line">&#123;</span><br><span class="line">    m_value.m_string = <span class="keyword">new</span> <span class="built_in">string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(<span class="type">const</span> Json &amp; other) : <span class="built_in">m_type</span>(JSON_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">copy</span>(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::<span class="built_in">Json</span>(Json &amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json::~<span class="built_in">Json</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="comment">// clear();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Json::str</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON_NULL:</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_BOOL:</span><br><span class="line">            ss &lt;&lt; (m_value.m_bool ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_INT:</span><br><span class="line">            ss &lt;&lt; m_value.m_int;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_DOUBLE:</span><br><span class="line">            ss &lt;&lt; m_value.m_double;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_STRING:</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; *(m_value.m_string) &lt;&lt; <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_ARRAY:</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = (m_value.m_array)-&gt;<span class="built_in">begin</span>(); it != (m_value.m_array)-&gt;<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != (m_value.m_array)-&gt;<span class="built_in">begin</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ss &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ss &lt;&lt; (*it).<span class="built_in">str</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_OBJECT:</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = (m_value.m_object)-&gt;<span class="built_in">begin</span>(); it != (m_value.m_object)-&gt;<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != (m_value.m_object)-&gt;<span class="built_in">begin</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ss &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ss &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\&quot;:&quot;</span> &lt;&lt; it-&gt;second.<span class="built_in">str</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json::Type <span class="title">Json::type</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_null</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_BOOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_INT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_DOUBLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_string</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_STRING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_array</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_ARRAY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::is_object</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == JSON_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::as_bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (m_type == JSON_BOOL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_value.m_bool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;type error: not bool type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Json::as_int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type == JSON_INT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_value.m_int;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;type error: not int type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Json::as_double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type == JSON_DOUBLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_value.m_double;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;type error: not double type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Json::as_string</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type == JSON_STRING)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *(m_value.m_string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;type error: not string type&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json::<span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">as_bool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">as_int</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">as_double</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json::<span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">as_string</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON_NULL:</span><br><span class="line">        <span class="keyword">case</span> JSON_BOOL:</span><br><span class="line">        <span class="keyword">case</span> JSON_INT:</span><br><span class="line">        <span class="keyword">case</span> JSON_DOUBLE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_STRING:</span><br><span class="line">            <span class="keyword">if</span> (m_value.m_string != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_value.m_string;</span><br><span class="line">                m_value.m_string = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_ARRAY:</span><br><span class="line">            <span class="keyword">if</span> (m_value.m_array != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it = (m_value.m_array)-&gt;<span class="built_in">begin</span>(); it != (m_value.m_array)-&gt;<span class="built_in">end</span>(); ++it)</span><br><span class="line">                &#123;</span><br><span class="line">                    it-&gt;<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> m_value.m_array;</span><br><span class="line">                m_value.m_array = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_OBJECT:</span><br><span class="line">            <span class="keyword">if</span> (m_value.m_object != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it = (m_value.m_object)-&gt;<span class="built_in">begin</span>(); it != (m_value.m_object)-&gt;<span class="built_in">end</span>(); ++it)</span><br><span class="line">                &#123;</span><br><span class="line">                    it-&gt;second.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> m_value.m_object;</span><br><span class="line">                m_value.m_object = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_type = JSON_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(<span class="type">bool</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    m_type = JSON_BOOL;</span><br><span class="line">    m_value.m_bool = value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    m_type = JSON_INT;</span><br><span class="line">    m_value.m_int = value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(<span class="type">double</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    m_type = JSON_DOUBLE;</span><br><span class="line">    m_value.m_double = value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    m_type = JSON_STRING;</span><br><span class="line">    m_value.m_string = <span class="keyword">new</span> <span class="built_in">string</span>(value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    m_type = JSON_STRING;</span><br><span class="line">    m_value.m_string = <span class="keyword">new</span> <span class="built_in">string</span>(value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(<span class="type">const</span> Json &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">copy</span>(other);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>=(Json &amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(other);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::append</span><span class="params">(<span class="type">const</span> Json &amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_ARRAY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        m_type = JSON_ARRAY;</span><br><span class="line">        m_value.m_array = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;Json&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    (m_value.m_array)-&gt;<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::append</span><span class="params">(Json &amp;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_ARRAY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        m_type = JSON_ARRAY;</span><br><span class="line">        m_value.m_array = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;Json&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    (m_value.m_array)-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::has</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_ARRAY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = (<span class="type">int</span>)(m_value.m_array)-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::has</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_OBJECT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (m_value.m_object)-&gt;<span class="built_in">find</span>(key) != (m_value.m_object)-&gt;<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::has</span><span class="params">(<span class="type">const</span> string &amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">has</span>(key.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Json::get</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has</span>(index))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (m_value.m_array)-&gt;<span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Json::get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has</span>(key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*(m_value.m_object))[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Json::get</span><span class="params">(<span class="type">const</span> string &amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(key.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::remove</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has</span>(index))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (m_value.m_array)-&gt;<span class="built_in">at</span>(index).<span class="built_in">clear</span>();</span><br><span class="line">    (m_value.m_array)-&gt;<span class="built_in">erase</span>((m_value.m_array)-&gt;<span class="built_in">begin</span>() + index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_OBJECT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = (m_value.m_object)-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it == (m_value.m_object)-&gt;<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;second.<span class="built_in">clear</span>();</span><br><span class="line">    (m_value.m_object)-&gt;<span class="built_in">erase</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::remove</span><span class="params">(<span class="type">const</span> string &amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">remove</span>(key.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_ARRAY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;type error: not array&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has</span>(index))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;array out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (m_value.m_array)-&gt;<span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">char</span> * key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != JSON_OBJECT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        m_type = JSON_OBJECT;</span><br><span class="line">        m_value.m_object = <span class="keyword">new</span> std::<span class="built_in">map</span>&lt;string, Json&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*(m_value.m_object))[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Json &amp; Json::<span class="keyword">operator</span>[](<span class="type">const</span> string &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>)[key.<span class="built_in">c_str</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Json::size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON_ARRAY:</span><br><span class="line">            <span class="keyword">return</span> (m_value.m_array)-&gt;<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_OBJECT:</span><br><span class="line">            <span class="keyword">return</span> (m_value.m_object)-&gt;<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Json::empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON_NULL:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_ARRAY:</span><br><span class="line">            <span class="keyword">return</span> (m_value.m_array)-&gt;<span class="built_in">empty</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_OBJECT:</span><br><span class="line">            <span class="keyword">return</span> (m_value.m_object)-&gt;<span class="built_in">empty</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::copy</span><span class="params">(<span class="type">const</span> Json &amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    m_type = other.m_type;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON_NULL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_BOOL:</span><br><span class="line">        <span class="keyword">case</span> JSON_INT:</span><br><span class="line">        <span class="keyword">case</span> JSON_DOUBLE:</span><br><span class="line">            m_value = other.m_value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_STRING:</span><br><span class="line">            <span class="keyword">if</span> (other.m_value.m_string != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_value.m_string = <span class="keyword">new</span> <span class="built_in">string</span>(*(other.m_value.m_string));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_ARRAY:</span><br><span class="line">            <span class="keyword">if</span> (other.m_value.m_array != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_value.m_array = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;Json&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it = (other.m_value.m_array)-&gt;<span class="built_in">begin</span>(); it != (other.m_value.m_array)-&gt;<span class="built_in">end</span>(); ++it)</span><br><span class="line">                &#123;</span><br><span class="line">                    (m_value.m_array)-&gt;<span class="built_in">push_back</span>(*it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> JSON_OBJECT:</span><br><span class="line">            <span class="keyword">if</span> (other.m_value.m_object != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_value.m_object = <span class="keyword">new</span> std::<span class="built_in">map</span>&lt;string, Json&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it = (other.m_value.m_object)-&gt;<span class="built_in">begin</span>(); it != (other.m_value.m_object)-&gt;<span class="built_in">end</span>(); ++it)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*(m_value.m_object))[it-&gt;first] = it-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::parse</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    Parser p;</span><br><span class="line">    p.<span class="built_in">load</span>(filename);</span><br><span class="line">    *<span class="keyword">this</span> = p.<span class="built_in">parse</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::parse</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    Parser p;</span><br><span class="line">    p.<span class="built_in">load</span>(buf, len);</span><br><span class="line">    *<span class="keyword">this</span> = p.<span class="built_in">parse</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap仅交换内容，不拷贝内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Json::swap</span><span class="params">(Json &amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Type type = m_type;</span><br><span class="line">    Value value = m_value;</span><br><span class="line">    m_type = other.m_type;</span><br><span class="line">    m_value = other.m_value;</span><br><span class="line">    other.m_type = type;</span><br><span class="line">    other.m_value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parse实现">Parse实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json/parser.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> json</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Parser</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Parser</span>() = <span class="keyword">default</span>;</span><br><span class="line">            ~<span class="built_in">Parser</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buf, <span class="type">int</span> len)</span></span>;</span><br><span class="line">            <span class="function">Json <span class="title">parse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">// 忽略空白符</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">skip_white_space</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">// 读取下一个字符</span></span><br><span class="line">            <span class="function"><span class="type">char</span> <span class="title">get_next_token</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">in_range</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">Json <span class="title">parse_null</span><span class="params">()</span></span>;                  <span class="comment">// 解析null</span></span><br><span class="line">            <span class="function">Json <span class="title">parse_bool</span><span class="params">()</span></span>;                  <span class="comment">// 解析bool</span></span><br><span class="line">            <span class="function">Json <span class="title">parse_number</span><span class="params">()</span></span>;                <span class="comment">// 解析数字</span></span><br><span class="line">            <span class="function">string <span class="title">parse_string</span><span class="params">()</span></span>;              <span class="comment">// 解析字符串</span></span><br><span class="line">            <span class="function">Json <span class="title">parse_array</span><span class="params">()</span></span>;                 <span class="comment">// 解析数组</span></span><br><span class="line">            <span class="function">Json <span class="title">parse_object</span><span class="params">()</span></span>;                <span class="comment">// 解析对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            string m_str;</span><br><span class="line">            <span class="type">size_t</span> m_idx = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json/parser.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/parser.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::load</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; ofs.<span class="built_in">rdbuf</span>();</span><br><span class="line">    m_str = oss.<span class="built_in">str</span>();</span><br><span class="line">    m_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_str.<span class="built_in">assign</span>(buf, len);</span><br><span class="line">    m_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::skip_white_space</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_str[m_idx] == <span class="string">&#x27; &#x27;</span> || m_str[m_idx] == <span class="string">&#x27;\r&#x27;</span> || m_str[m_idx] == <span class="string">&#x27;\n&#x27;</span> || m_str[m_idx] == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        m_idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Parser::get_next_token</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">skip_white_space</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_idx == m_str.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;unexpected input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_str[m_idx++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Parser::in_range</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= lower &amp;&amp; x &lt;= upper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Parser::parse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="comment">// null</span></span><br><span class="line">            m_idx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parse_null</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="comment">// true, false</span></span><br><span class="line">            m_idx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parse_bool</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            <span class="comment">// 数字</span></span><br><span class="line">            m_idx--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parse_number</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">            <span class="comment">// 字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parse_string</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="comment">// 数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parse_array</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            <span class="comment">// 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parse_object</span>();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;unexpected character&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Parser::parse_null</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_str.<span class="built_in">compare</span>(m_idx, <span class="number">4</span>, <span class="string">&quot;null&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;parse null error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Parser::parse_bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_str.<span class="built_in">compare</span>(m_idx, <span class="number">4</span>, <span class="string">&quot;true&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_str.<span class="built_in">compare</span>(m_idx, <span class="number">5</span>, <span class="string">&quot;false&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;parse bool error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Parser::parse_number</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = m_idx;</span><br><span class="line">    <span class="keyword">if</span> (m_str[m_idx] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_str[m_idx] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">in_range</span>(m_str[m_idx], <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx++;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">in_range</span>(m_str[m_idx], <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            m_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;invalid character in number&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有小数</span></span><br><span class="line">    <span class="keyword">if</span> (m_str[m_idx] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>(std::<span class="built_in">atoi</span>(m_str.<span class="built_in">c_str</span>() + pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有小数</span></span><br><span class="line">    m_idx++;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">in_range</span>(m_str[m_idx], <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;invalid float number&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">in_range</span>(m_str[m_idx], <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        m_idx++;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Json</span>(std::<span class="built_in">atof</span>(m_str.<span class="built_in">c_str</span>() + pos));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Parser::parse_string</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = m_idx;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是转义字符</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:           <span class="comment">// unicode</span></span><br><span class="line">                    m_idx += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_str.<span class="built_in">substr</span>(pos, m_idx - pos - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Parser::parse_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Json <span class="title">arr</span><span class="params">(Json::JSON_ARRAY)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    m_idx--;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr.<span class="built_in">append</span>(<span class="built_in">parse</span>());</span><br><span class="line">        ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;expected &#x27;,&#x27; in array&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Json <span class="title">Parser::parse_object</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Json <span class="title">obj</span><span class="params">(Json::JSON_OBJECT)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    m_idx--;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;invalid object key&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        string key = <span class="built_in">parse_string</span>();</span><br><span class="line">        ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;expected &#x27;:&#x27; in object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj[key] = <span class="built_in">parse</span>();</span><br><span class="line">        ch = <span class="built_in">get_next_token</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;expected &#x27;,&#x27; in object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/2024/02/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/02/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串操作">字符串操作</h1><h2 id="to-lower-内容转小写">to_lower 内容转小写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::to_lower</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="to-upper-内容转大写">to_upper 内容转大写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::to_upper</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ltrim-裁剪左边">ltrim 裁剪左边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::ltrim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    <span class="type">size_t</span> pos = str.<span class="built_in">find_first_not_of</span>(trims);</span><br><span class="line">    <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        str.<span class="built_in">erase</span>(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rtrim-裁剪右边">rtrim 裁剪右边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::rtrim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    <span class="type">size_t</span> pos = str.<span class="built_in">find_last_not_of</span>(trims);</span><br><span class="line">    <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        str.<span class="built_in">erase</span>(pos + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="trim-裁剪左右两边">trim 裁剪左右两边</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::trim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="built_in">ltrim</span>(input, trims);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rtrim</span>(str, trims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="split-字符串分割">split 字符串分割</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;string&gt; <span class="title">String::split</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;string&gt; output;</span><br><span class="line">    <span class="type">size_t</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> index = input.<span class="built_in">find_first_of</span>(separator, last);</span><br><span class="line">    <span class="keyword">while</span> (index != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        string str = input.<span class="built_in">substr</span>(last, index - last);</span><br><span class="line">        output.<span class="built_in">push_back</span>(str);</span><br><span class="line">        last = index + <span class="number">1</span>;</span><br><span class="line">        index = input.<span class="built_in">find_first_of</span>(separator, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index - last &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        output.<span class="built_in">push_back</span>(input.<span class="built_in">substr</span>(last, index - last));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;string&gt; <span class="title">String::split</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">char</span> separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">split</span>(input, <span class="built_in">string</span>(<span class="number">1</span>, separator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join-字符串合并">join 字符串合并</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::join</span><span class="params">(<span class="type">const</span> std::vector&lt;string&gt; &amp; input, <span class="type">const</span> string &amp; separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = input.<span class="built_in">begin</span>(); it != input.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it != input.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            oss &lt;&lt; separator;</span><br><span class="line">        &#125;</span><br><span class="line">        oss &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::join</span><span class="params">(<span class="type">const</span> std::vector&lt;string&gt; &amp; input, <span class="type">char</span> separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">join</span>(input, <span class="built_in">string</span>(<span class="number">1</span>, separator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="has-prefix-判断是否有前缀">has_prefix 判断是否有前缀</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">String::has_prefix</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; prefix.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>()) == prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="has-suffix-判断是否有后缀">has_suffix 判断是否有后缀</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">String::has_suffix</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; suffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; suffix.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="built_in">substr</span>(input.<span class="built_in">size</span>() - suffix.<span class="built_in">size</span>(), suffix.<span class="built_in">size</span>()) == suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="capitalize-首字母大写">capitalize 首字母大写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::capitalize</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ch = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        ch = (<span class="type">char</span>)<span class="built_in">toupper</span>(ch);</span><br><span class="line">        std::<span class="built_in">replace</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + <span class="number">1</span>, str[<span class="number">0</span>], ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="format-格式化">format 格式化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">String::format</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    va_list arg_ptr;</span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, arg_ptr);</span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(buf, len + <span class="number">1</span>, format, arg_ptr);</span><br><span class="line">        <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        result = buf;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整实现">完整实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/string.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">            ~<span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">to_lower</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">to_upper</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 裁剪左边</span></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">ltrim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span>;</span><br><span class="line">            <span class="comment">// 裁剪右边</span></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">rtrim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span>;</span><br><span class="line">            <span class="comment">// 裁剪左右两边</span></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">trim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串分割</span></span><br><span class="line">            <span class="function"><span class="type">static</span> std::vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; separator)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> std::vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">char</span> separator)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串合并</span></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">join</span><span class="params">(<span class="type">const</span> std::vector&lt;string&gt; &amp; input, <span class="type">const</span> string &amp; separator)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">join</span><span class="params">(<span class="type">const</span> std::vector&lt;string&gt; &amp; input, <span class="type">char</span> separator)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串是否有前缀</span></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">has_prefix</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; prefix)</span></span>;</span><br><span class="line">            <span class="comment">// 字符串是否有后缀</span></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">has_suffix</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; suffix)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首字母大写</span></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">capitalize</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串可变参数格式化</span></span><br><span class="line">            <span class="function"><span class="type">static</span> string <span class="title">format</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * format, ...)</span></span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/string.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::to_lower</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::to_upper</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::ltrim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    <span class="type">size_t</span> pos = str.<span class="built_in">find_first_not_of</span>(trims);</span><br><span class="line">    <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        str.<span class="built_in">erase</span>(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::rtrim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    <span class="type">size_t</span> pos = str.<span class="built_in">find_last_not_of</span>(trims);</span><br><span class="line">    <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">        str.<span class="built_in">erase</span>(pos + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::trim</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; trims)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="built_in">ltrim</span>(input, trims);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rtrim</span>(str, trims);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;string&gt; <span class="title">String::split</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;string&gt; output;</span><br><span class="line">    <span class="type">size_t</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> index = input.<span class="built_in">find_first_of</span>(separator, last);</span><br><span class="line">    <span class="keyword">while</span> (index != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        string str = input.<span class="built_in">substr</span>(last, index - last);</span><br><span class="line">        output.<span class="built_in">push_back</span>(str);</span><br><span class="line">        last = index + <span class="number">1</span>;</span><br><span class="line">        index = input.<span class="built_in">find_first_of</span>(separator, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index - last &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        output.<span class="built_in">push_back</span>(input.<span class="built_in">substr</span>(last, index - last));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;string&gt; <span class="title">String::split</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">char</span> separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">split</span>(input, <span class="built_in">string</span>(<span class="number">1</span>, separator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::join</span><span class="params">(<span class="type">const</span> std::vector&lt;string&gt; &amp; input, <span class="type">const</span> string &amp; separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = input.<span class="built_in">begin</span>(); it != input.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it != input.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            oss &lt;&lt; separator;</span><br><span class="line">        &#125;</span><br><span class="line">        oss &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::join</span><span class="params">(<span class="type">const</span> std::vector&lt;string&gt; &amp; input, <span class="type">char</span> separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">join</span>(input, <span class="built_in">string</span>(<span class="number">1</span>, separator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">String::has_prefix</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; prefix.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>()) == prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">String::has_suffix</span><span class="params">(<span class="type">const</span> string &amp; input, <span class="type">const</span> string &amp; suffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; suffix.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="built_in">substr</span>(input.<span class="built_in">size</span>() - suffix.<span class="built_in">size</span>(), suffix.<span class="built_in">size</span>()) == suffix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::capitalize</span><span class="params">(<span class="type">const</span> string &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = input;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ch = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        ch = (<span class="type">char</span>)<span class="built_in">toupper</span>(ch);</span><br><span class="line">        std::<span class="built_in">replace</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + <span class="number">1</span>, str[<span class="number">0</span>], ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">String::format</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    va_list arg_ptr;</span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, arg_ptr);</span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(buf, len + <span class="number">1</span>, format, arg_ptr);</span><br><span class="line">        <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        result = buf;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time时间操作</title>
      <link href="/2024/02/18/time%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/02/18/time%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="时间常用操作">时间常用操作</h1><h2 id="time">time</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *timer)</span></span></span><br></pre></td></tr></table></figure><p>形参<code>timer</code>值为<code>NULL</code>时得到当前日历时间（从<code>1970-01-01 00:00:00</code>到现在的秒数）。<br>形参<code>timer</code>为时间数值时，用于设置日历时间，<code>time_t</code>是一个<code>unsigned long</code>类型。<br>如果<code>timer</code>不为空，则返回值也存储在变量<code>timer</code>中。</p><p>缺点：时间精度仅为秒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 自1970年1月1日起的秒数</span></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ticks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="localtime">localtime</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span> *timer)</span><br></pre></td></tr></table></figure><p>C库函数<code>struct tm *localtime(const time_t *timer)</code>使用<code>timer</code>的值来填充<code>tm</code>结构，并用本地时区表示。<code>tm</code>结构体内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm_sec; <span class="comment">// 秒，范围从0到59</span></span><br><span class="line">    <span class="type">int</span> tm_min; <span class="comment">// 分，范围从0到59</span></span><br><span class="line">    <span class="type">int</span> tm_hour; <span class="comment">// 小时，范围从0到23</span></span><br><span class="line">    <span class="type">int</span> tm_mday; <span class="comment">// 一月中的第几天，范围从1到31</span></span><br><span class="line">    <span class="type">int</span> tm_mon; <span class="comment">// 月份，范围从0到11</span></span><br><span class="line">    <span class="type">int</span> tm_year; <span class="comment">// 自1900起的年数</span></span><br><span class="line">    <span class="type">int</span> tm_wday; <span class="comment">// 一周中的第几天，范围从0到6</span></span><br><span class="line">    <span class="type">int</span> tm_yday; <span class="comment">// 一年中的第几天，范围从0到365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> * info;</span><br><span class="line">    info = <span class="built_in">localtime</span>(&amp;ticks);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d %d:%d:%d\n&quot;</span>,</span><br><span class="line">    info-&gt;tm_year + <span class="number">1900</span>, info-&gt;tm_mon + <span class="number">1</span>, info-&gt;tm_mday,</span><br><span class="line">    info-&gt;tm_hour, info-&gt;tm_min, info-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：线程不安全！</p><p>Linux线程安全版本为<code>localtime_r</code>，Windows线程安全版本为<code>localtime_s</code>。</p><h2 id="asctime">asctime</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span></span><br></pre></td></tr></table></figure><p>C库函数<code>char *asctime(const struct tm *timeptr)</code>返回一个指向字符串的指针，它代表了结构体<code>struct timeptr</code>的日期和时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> * info;</span><br><span class="line">    info = <span class="built_in">localtime</span>(&amp;ticks);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">asctime</span>(info));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：线程不安全；时间格式固定，适合欧美用户。</p><h2 id="strftime">strftime</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strftime</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>str</code>——指向目标数组的指针，用来保存产生的C字符串</li><li><code>len</code> ——<code>str</code>目标数组长度</li><li><code>format</code> ——这是C字符串，包含了普通字符和特殊格式说明符的任何组合，这些格式说明符由函数替换为表示，即为表示时间的格式</li><li><code>timeptr</code> ——中所指定时间的相对应值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> * info;</span><br><span class="line">    info = <span class="built_in">localtime</span>(&amp;ticks);</span><br><span class="line">    <span class="type">char</span> str[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(str, <span class="built_in">sizeof</span>(str), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：跨平台；线程安全；时间格式可定制</p><h2 id="sleep">sleep</h2><p>Linux:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>; <span class="comment">// 参数为秒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usleep</span><span class="params">(<span class="type">int</span> micro_seconds)</span></span>; <span class="comment">// 参数为微秒</span></span><br></pre></td></tr></table></figure><p>Windows:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sleep</span><span class="params">(DWORD dwMilliseconds)</span></span>; <span class="comment">// 参数为毫秒</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gettimeofday">gettimeofday</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure><p>其参数<code>tv</code>是保存获取时间结果的结构体，参数<code>tz</code>用于保存时区结果（若不使用则传入<code>NULL</code>即可）。</p><p><code>struct timeval</code>结构体内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">// 微秒数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sec = %ld, usec = %ld\n&quot;</span>, tv.tv_sec, tv.tv_usec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：非跨平台，Windows不支持该函数</p><h1 id="timer类设计与实现">Timer类设计与实现</h1><h2 id="跨平台实现">跨平台实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/time.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WI32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/time.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::get_time_of_day</span><span class="params">(<span class="keyword">struct</span> timeval * tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    SYSTEMTIME wtm;</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;wtm);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> tm;</span><br><span class="line">    tm.tm_year = wtm.wYear - <span class="number">1900</span>;</span><br><span class="line">    tm.tm_mon = wtm.wMonth - <span class="number">1</span>;</span><br><span class="line">    tm.tm_mday = wtm.wDay;</span><br><span class="line">    tm.tm_hour = wtm.wHour;</span><br><span class="line">    tm.tm_min = wtm.wMinute;</span><br><span class="line">    tm.tm_sec = wtm.wSecond;</span><br><span class="line">    tm.tm_isdst = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">mktime</span>(&amp;tm);</span><br><span class="line">    tv-&gt;tv_sec = ticks;</span><br><span class="line">    tv-&gt;tv_usec = wtm.wMilliseconds * <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(tv, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整实现">完整实现</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(hello CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;utility/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE .)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/time.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WI32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Time</span>();</span><br><span class="line">            ~<span class="built_in">Time</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下接口分别返回年月日时分秒周</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">year</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">month</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">day</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">hour</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">minute</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">second</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">week</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自1970-01-01 00:00:00到现在的秒数与毫秒数</span></span><br><span class="line">            <span class="function"><span class="type">double</span> <span class="title">seconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">double</span> <span class="title">milliseconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="comment">// 返回格式化的时间字符串</span></span><br><span class="line">            <span class="function">string <span class="title">format</span><span class="params">(<span class="type">const</span> string &amp; format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="keyword">operator</span>-(<span class="type">const</span> Time &amp; other);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">get_local_time</span><span class="params">(<span class="keyword">struct</span> tm * tm, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">get_time_of_day</span><span class="params">(<span class="keyword">struct</span> timeval * tv)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> m_tm = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">int</span> m_sec;</span><br><span class="line">            <span class="type">int</span> m_usec;             <span class="comment">// 毫秒精度</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/time.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自1970-01-01 00:00:00到现在的秒数</span></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">get_local_time</span>(&amp;m_tm, &amp;ticks);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">get_time_of_day</span>(&amp;tv);</span><br><span class="line">    m_sec = tv.tv_sec;</span><br><span class="line">    m_usec = tv.tv_usec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::get_local_time</span><span class="params">(<span class="keyword">struct</span> tm* tm, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">localtime_s</span>(tm, ticks);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">localtime_r</span>(ticks, tm);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::get_time_of_day</span><span class="params">(<span class="keyword">struct</span> timeval * tv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    SYSTEMTIME wtm;</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;wtm);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> tm;</span><br><span class="line">    tm.tm_year = wtm.wYear - <span class="number">1900</span>;</span><br><span class="line">    tm.tm_mon = wtm.wMonth - <span class="number">1</span>;</span><br><span class="line">    tm.tm_mday = wtm.wDay;</span><br><span class="line">    tm.tm_hour = wtm.wHour;</span><br><span class="line">    tm.tm_min = wtm.wMinute;</span><br><span class="line">    tm.tm_sec = wtm.wSecond;</span><br><span class="line">    tm.tm_isdst = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">mktime</span>(&amp;tm);</span><br><span class="line">    tv-&gt;tv_sec = ticks;</span><br><span class="line">    tv-&gt;tv_usec = wtm.wMilliseconds * <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(tv, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::year</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_year + <span class="number">1900</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::month</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_mon + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::day</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_mday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::hour</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_hour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::minute</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::second</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time::week</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_tm.tm_wday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">year</span>() &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="built_in">month</span>() &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="built_in">day</span>() &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">hour</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">minute</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">second</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Time::seconds</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Time::milliseconds</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sec * <span class="number">1000.0</span> + m_usec / <span class="number">1000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Time::<span class="keyword">operator</span>-(<span class="type">const</span> Time &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_sec - other.m_sec) * <span class="number">1000000.0</span> + (m_usec - other.m_usec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">Sleep</span>(milliseconds);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">usleep</span>(milliseconds * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Time::format</span><span class="params">(<span class="type">const</span> string &amp; format)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), format.<span class="built_in">c_str</span>(), &amp;m_tm);</span><br><span class="line">    <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time t1;</span><br><span class="line">    t1.<span class="built_in">show</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sec = &quot;</span> &lt;&lt; t1.<span class="built_in">seconds</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;milliseconds = &quot;</span> &lt;&lt; t1.<span class="built_in">milliseconds</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; t1.format(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    Time::<span class="built_in">sleep</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    Time t2;</span><br><span class="line">    <span class="type">double</span> usec = t2 - t1;</span><br><span class="line">    std::cout &lt;&lt; usec / <span class="number">1000.0</span> &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector深度探索</title>
      <link href="/2024/02/11/vector%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/"/>
      <url>/2024/02/11/vector%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="实现一个vector">实现一个vector</h1><h2 id="探索vector的视线">探索vector的视线</h2><p>以<code>vector&lt;char&gt;</code>为例，它其实就是个字符数组，内部结构如下图所示。图中方格表示<code>vector&lt;char&gt;</code>中的每一个元素，整个一串就是一个数组，而每个元素就是连续内存中的一个字符。</p><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20250617-011938.jpg" alt=""></p><p>该数组内部会有两个字段<code>size</code>和<code>capacity</code>，前者表示其实际大小，后者表示数组当前的最大容量5，即最多容纳多少个元素8，当它塞满以后如果继续往里面添加元素会触发内存的重新分配，给该数组分配更大一块内存。</p><h2 id="vector模板函数">vector模板函数</h2><h3 id="push-back">push_back</h3><p>向容器尾部添加元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> zh::stl::Vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_size &lt; m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[m_size] = value;</span><br><span class="line">        m_size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Vector扩容机制</span></span><br><span class="line">    <span class="keyword">if</span> (m_capacity == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_capacity = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_capacity *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T * data = <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] = m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data = data;</span><br><span class="line">    m_data[m_size] = value;</span><br><span class="line">    m_size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pop-back">pop_back</h3><p>删除容器中最后一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="at">at</h3><p>返回指定位置元素的索引，并进行边界检查</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= m_size)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out og range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="front">front</h3><p>返回第一个元素的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="back">back</h3><p>返回最后一个元素的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_data[m_size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="empty">empty</h3><p>判断<code>Vector</code>是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Vector&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear">clear</h3><p>删除<code>Vector</code>中所有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">clear</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size">size</h3><p>返回<code>Vector</code>中元素的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="capacity">capacity</h3><p>返回<code>Vector</code>的容量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="data">data</h3><p>返回内部数组指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T * Vector&lt;T&gt;::<span class="built_in">data</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="operator">operator[]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="operator">operator=</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt; &amp; Vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Vector&lt;T&gt; &amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_capacity &lt; other.m_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">            m_data = <span class="literal">nullptr</span>;</span><br><span class="line">            m_size = <span class="number">0</span>;</span><br><span class="line">            m_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">while</span> (m_capacity &lt; other.m_size)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">             m_capacity = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_capacity *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; other.m_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = other.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m_size = other.m_size;</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swap">swap</h3><p>交换两个<code>Vector</code>中的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">swap</span>(Vector&lt;T&gt; &amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    T * data = other.m_data;</span><br><span class="line">    <span class="type">int</span> size = other.m_size;</span><br><span class="line">    <span class="type">int</span> capacity = other.capacity;</span><br><span class="line">    other.m_data = m_data;</span><br><span class="line">    other.m_size = m_size;</span><br><span class="line">    other.m_capacity = capacity;</span><br><span class="line">    m_data = data;</span><br><span class="line">    m_size = size;</span><br><span class="line">    m_capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator">iterator</h3><p>将迭代器<code>iterator</code>作为<code>Vector</code>的内部类来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector的迭代器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">iterator</span>() : <span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">iterator</span>(T *pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">iterator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer == other.m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer != other.m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer == other.m_pointer;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀++</span></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀++</span></span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator <span class="keyword">operator</span>+(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        it.m_pointer += i;</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>+=(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀--</span></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀--</span></span><br><span class="line">    iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator <span class="keyword">operator</span>-(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        m_pointer -= i;</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>-=(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer -= i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>-(<span class="type">const</span> iterator &amp;other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer - other.m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器解引用</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">begin</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">Vector&lt;T&gt;::<span class="function">iterator <span class="title">it</span><span class="params">(m_data)</span></span>;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">end</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">iterator <span class="title">it</span><span class="params">(m_data + m_size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reverse-iterator">reverse_iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">reverse_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">reverse_iterator</span>() : <span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">reverse_iterator</span>(T *pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">reverse_iterator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> reverse_iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer == other.m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> reverse_iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer != other.m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> reverse_iterator &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer = other.m_pointer;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀++</span></span><br><span class="line">    reverse_iterator &amp;<span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer--;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀++</span></span><br><span class="line">    reverse_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator <span class="keyword">operator</span>+(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        it.m_pointer -= i;</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator &amp;<span class="keyword">operator</span>+=(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer -= i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀--</span></span><br><span class="line">    reverse_iterator &amp;<span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后缀--</span></span><br><span class="line">    reverse_iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator <span class="keyword">operator</span>-(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">        it.m_pointer += i;</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator &amp;<span class="keyword">operator</span>-=(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pointer += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::reverse_iterator Vector&lt;T&gt;::<span class="built_in">rbegin</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">reverse_iterator <span class="title">it</span><span class="params">(m_data + m_size - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::reverse_iterator Vector&lt;T&gt;::<span class="built_in">rend</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;T&gt;::<span class="function">reverse_iterator <span class="title">it</span><span class="params">(m_data - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert">insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(iterator position, <span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert</span>(position, <span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(iterator position, <span class="type">int</span> n, <span class="type">const</span> T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = position - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 容量足够</span></span><br><span class="line">    <span class="keyword">if</span> (m_size + n &lt;= m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先把后面的元素向后挪，避免覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m_size; i &gt; size; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[i + n - <span class="number">1</span>] = m_data[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_data[size + i] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        m_size += n;</span><br><span class="line">        <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">iterator</span>(m_data + size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不足，需要先扩容</span></span><br><span class="line">    <span class="keyword">while</span> (m_size + n &gt; m_capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_capacity *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T *data = <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] = m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[size + i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; m_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[n + i] = m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data = data;</span><br><span class="line">    m_size += n;</span><br><span class="line">    <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">iterator</span>(m_data + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="erase">erase</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(iterator pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span>() - pos == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        m_size -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = pos - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; m_size - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = m_data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    m_size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> f = first - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> l = last - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> n = last - first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size - l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[f + i] = m_data[l + i];</span><br><span class="line">    &#125;</span><br><span class="line">    m_size -= n;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整实现">完整实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stl/vector.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> stl</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Vector</span>();</span><br><span class="line">            ~<span class="built_in">Vector</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">T &amp; <span class="title">at</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">const</span> T &amp; <span class="title">at</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">T &amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">const</span> T &amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">T &amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">const</span> T &amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">T * <span class="title">data</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function"><span class="type">const</span> T * <span class="title">data</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            T &amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line">            <span class="type">const</span> T &amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">            Vector&lt;T&gt; &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vector&lt;T&gt; &amp; other);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Vector&lt;T&gt; &amp; other)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Vector的迭代器</span></span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">iterator</span>() : <span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">                <span class="built_in">iterator</span>(T * pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">                ~<span class="built_in">iterator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp; other)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer == other.m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator other)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer != other.m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator &amp; <span class="keyword">operator</span>=(<span class="type">const</span> iterator &amp; other)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer == other.m_pointer;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前缀++</span></span><br><span class="line">                iterator &amp; <span class="keyword">operator</span>++()</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer++;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 后缀++</span></span><br><span class="line">                iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    ++(*<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator <span class="keyword">operator</span>+(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    it.m_pointer += i;</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator &amp; <span class="keyword">operator</span>+=(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer += i;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前缀--</span></span><br><span class="line">                iterator &amp; <span class="keyword">operator</span>--()</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 后缀--</span></span><br><span class="line">                iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    --(*<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator <span class="keyword">operator</span>-(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    it.m_pointer -= i;</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator &amp; <span class="keyword">operator</span>-=(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer -= i;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="keyword">operator</span>-(<span class="type">const</span> iterator &amp; other) <span class="type">const</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer - other.m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 迭代器解引用</span></span><br><span class="line">                T &amp; <span class="keyword">operator</span>*()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> *m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                T * <span class="keyword">operator</span>-&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                T * m_pointer;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Vector的反向迭代器</span></span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">reverse_iterator</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">reverse_iterator</span>() : <span class="built_in">m_pointer</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">                <span class="built_in">reverse_iterator</span>(T * pointer) : <span class="built_in">m_pointer</span>(pointer) &#123;&#125;</span><br><span class="line">                ~<span class="built_in">reverse_iterator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> reverse_iterator &amp; other)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer == other.m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> reverse_iterator &amp; other)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer != other.m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reverse_iterator &amp; <span class="keyword">operator</span>=(<span class="type">const</span> reverse_iterator &amp; other)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer = other.m_pointer;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前缀++</span></span><br><span class="line">                reverse_iterator &amp; <span class="keyword">operator</span>++()</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer--;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 后缀++</span></span><br><span class="line">                reverse_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    ++(*<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reverse_iterator <span class="keyword">operator</span>+(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    it.m_pointer -= i;</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reverse_iterator &amp; <span class="keyword">operator</span>+=(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer -= i;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前缀--</span></span><br><span class="line">                reverse_iterator &amp; <span class="keyword">operator</span>--()</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer++;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 后缀--</span></span><br><span class="line">                reverse_iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    --(*<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reverse_iterator <span class="keyword">operator</span>-(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    reverse_iterator it = *<span class="keyword">this</span>;</span><br><span class="line">                    it.m_pointer += i;</span><br><span class="line">                    <span class="keyword">return</span> it;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reverse_iterator &amp; <span class="keyword">operator</span>-=(<span class="type">int</span> i)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pointer += i;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;   </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                T &amp; <span class="keyword">operator</span>*()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> *m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                T * <span class="keyword">operator</span>-&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_pointer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                T * m_pointer;</span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line">            <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">            <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line">            <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">int</span> n, <span class="type">const</span> T &amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;</span><br><span class="line">            <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_basic_type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            T * m_data;             <span class="comment">// 数组用指针来表示</span></span><br><span class="line">            <span class="type">int</span> m_size;             <span class="comment">// Vector中实际存储元素的个数</span></span><br><span class="line">            <span class="type">int</span> m_capacity;         <span class="comment">// Vector的最大容量</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        Vector&lt;T&gt;::<span class="built_in">Vector</span>() : <span class="built_in">m_data</span>(<span class="literal">nullptr</span>), <span class="built_in">m_size</span>(<span class="number">0</span>), <span class="built_in">m_capacity</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        zh::stl::Vector&lt;T&gt;::~<span class="built_in">Vector</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span>[] m_data;</span><br><span class="line">                m_data = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_size = <span class="number">0</span>;</span><br><span class="line">            m_capacity = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">void</span> zh::stl::Vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp; value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_size &lt; m_capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[m_size] = value;</span><br><span class="line">                m_size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Vector扩容机制</span></span><br><span class="line">            <span class="keyword">if</span> (m_capacity == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_capacity = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_capacity *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            T * data = <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">            <span class="comment">// 如果数据是基本类型，直接调用memcpy()进行整段内存复制</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_basic_type</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">memcpy</span>(data, m_data, m_size * <span class="built_in">sizeof</span>(T));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    data[i] = m_data[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> [] m_data;</span><br><span class="line">                m_data = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_data = data;</span><br><span class="line">            m_data[m_size] = value;</span><br><span class="line">            m_size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">show</span>() <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; m_size &lt;&lt; <span class="string">&quot;, capacity = &quot;</span> &lt;&lt; m_capacity &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_size &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= m_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out og range&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_data[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_data[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="built_in">front</span>() <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;vector is empty&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_data[m_size - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="built_in">back</span>() <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">bool</span> Vector&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_size == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">clear</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">capacity</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        T * Vector&lt;T&gt;::<span class="built_in">data</span>() <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">const</span> T * Vector&lt;T&gt;::<span class="built_in">data</span>() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">data</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">const</span> T &amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">at</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        Vector&lt;T&gt; &amp; Vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Vector&lt;T&gt; &amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_capacity &lt; other.m_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">                    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">                    m_size = <span class="number">0</span>;</span><br><span class="line">                    m_capacity = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (m_capacity &lt; other.m_size)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m_capacity == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_capacity = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        m_capacity *= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                m_data = <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; other.m_size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[i] = other.m_data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            m_size = other.m_size;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">void</span> Vector&lt;T&gt;::<span class="built_in">swap</span>(Vector&lt;T&gt; &amp; other)</span><br><span class="line">        &#123;</span><br><span class="line">            T * data = other.m_data;</span><br><span class="line">            <span class="type">int</span> size = other.m_size;</span><br><span class="line">            <span class="type">int</span> capacity = other.capacity;</span><br><span class="line">            other.m_data = m_data;</span><br><span class="line">            other.m_size = m_size;</span><br><span class="line">            other.m_capacity = capacity;</span><br><span class="line">            m_data = data;</span><br><span class="line">            m_size = size;</span><br><span class="line">            m_capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">begin</span>() <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector&lt;T&gt;::<span class="function">iterator <span class="title">it</span><span class="params">(m_data)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">end</span>() <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector&lt;T&gt;::<span class="function">iterator <span class="title">it</span><span class="params">(m_data + m_size)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::reverse_iterator Vector&lt;T&gt;::<span class="built_in">rbegin</span>() <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector&lt;T&gt;::<span class="function">reverse_iterator <span class="title">it</span><span class="params">(m_data + m_size - <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::reverse_iterator Vector&lt;T&gt;::<span class="built_in">rend</span>() <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector&lt;T&gt;::<span class="function">reverse_iterator <span class="title">it</span><span class="params">(m_data - <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(iterator position, <span class="type">const</span> T &amp; value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insert</span>(position, <span class="number">1</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">insert</span>(iterator position, <span class="type">int</span> n, <span class="type">const</span> T &amp; value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = position - <span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">// 容量足够</span></span><br><span class="line">            <span class="keyword">if</span> (m_size + n &lt;= m_capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 先把后面的元素向后挪，避免覆盖</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = m_size; i &gt; size; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_data[i + n - <span class="number">1</span>] = m_data[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_data[size + i] = value;</span><br><span class="line">                &#125;</span><br><span class="line">                m_size += n;</span><br><span class="line">                <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">iterator</span>(m_data + size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 容量不足，需要先扩容</span></span><br><span class="line">            <span class="keyword">while</span> (m_size + n &gt; m_capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_capacity == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_capacity = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m_capacity *= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T * data = <span class="keyword">new</span> T[m_capacity];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                data[i] = m_data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                data[size + i] = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; m_size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                data[n + i] = m_data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span>[] m_data;</span><br><span class="line">                m_data = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_data = data;</span><br><span class="line">            m_size += n;</span><br><span class="line">            <span class="keyword">return</span> Vector&lt;T&gt;::<span class="built_in">iterator</span>(m_data + size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(iterator pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;out of range&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">end</span>() - pos == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删除最后一个元素</span></span><br><span class="line">                m_size -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> size = pos - <span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; m_size - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[i] = m_data[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            m_size -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::<span class="built_in">erase</span>(iterator first, iterator last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> f = first - <span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> l = last - <span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> n = last - first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_size - l; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                m_data[f + i] = m_data[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">            m_size -= n;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="type">bool</span> Vector&lt;T&gt;::<span class="built_in">is_basic_type</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果模板参数类型是指针，则认定为基本数据类型</span></span><br><span class="line">            <span class="keyword">if</span> (std::is_pointer&lt;T&gt;::value)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过typeid判断是否为基本数据类型</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">bool</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">char</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">unsigned</span> <span class="type">char</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">short</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">unsigned</span> <span class="type">short</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">int</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">unsigned</span> <span class="type">int</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">long</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">float</span>)) ||</span><br><span class="line">                   (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">double</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2024/02/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/02/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式简介">单例模式简介</h1><p>单例模式，是属于创建类型的一种常用的软件设计模式，通过单例模式的方法创建的类在当前进程中仅有一个实例。</p><h1 id="应用场景">应用场景</h1><p>单例模式可应用于配置管理、日志记录、线程池、连接池、内存池、对象池、消息队列等。</p><h1 id="实现步骤">实现步骤</h1><ol><li>将类的构造函数定义为私有方法</li><li>定义一个私有的类的静态成员数据</li><li>提供一个公有的获取静态实例的静态方法</li></ol><h1 id="单例模式设计与实现">单例模式设计与实现</h1><h2 id="常用实现">常用实现</h2><p>单例模式需要将构造函数、析构函数、拷贝构造函数和拷贝赋值运算符声明为私有的。</p><p>然后定义一个私有的类的静态实例，并初始化私有的静态实例为空指针<code>nullptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/singleton.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> m_instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton * m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton * Singleton::m_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;test/singleton.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton * s = Singleton::<span class="built_in">instance</span>();</span><br><span class="line">    s-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全">线程安全</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> m_instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面单例模式的常见实现是存在多线程安全问题的，需要解决该线程安全问题。</p><h3 id="饿汉式写法">饿汉式写法</h3><p>由于静态数据成员是在<code>main()</code>函数运行之前初始化的，它只会被初始化一次，因此可以使用静态数据成员来解决单例模式的线程安全问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::m_instance;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>在程序启动时就初始化实例</li><li>线程安全，但可能会增加程序启动时间</li><li>如果单例对象很大且不一定会被使用，可能会浪费资源</li></ol><h3 id="懒汉式写法">懒汉式写法</h3><p>C++11标准保证静态局部变量的初始化是线程安全的，即在多线程环境下静态局部变量只会实例化一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton singleton;</span><br><span class="line">        <span class="keyword">return</span> &amp;singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>使用静态局部变量，C++11保证其初始化是线程安全的</li><li>只有第一次调用<code>instance()</code>时才会创建实例</li><li>简单、清晰、线程安全</li></ol><h2 id="模板实现">模板实现</h2><p>如果每个类都要实现单例模式，那可能每个类都要以相同的方式实现一遍，比较麻烦，可以借助模板来简化工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/singleton.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义模板类</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> T * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;   </span><br><span class="line">                <span class="comment">// C++11保证静态局部变量的初始化是线程安全的</span></span><br><span class="line">                <span class="type">static</span> T instance;</span><br><span class="line">                <span class="keyword">return</span> &amp;instance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            Singleton&lt;T&gt; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/a.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/singleton.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明类Singleton&lt;A&gt;为类A的友元以便于调用其私有构造函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;A&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    A &amp; <span class="keyword">operator</span>=(<span class="type">const</span> A &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="定义优化">定义优化</h2><p>每次写一个单例类都要重复编写以下代码，非常不变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明类Singleton&lt;A&gt;为类A的友元以便于调用其私有构造函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;A&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    A &amp; <span class="keyword">operator</span>=(<span class="type">const</span> A &amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以通过宏来进一步简化和优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/singleton.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义模板类</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> T * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;   </span><br><span class="line">                <span class="comment">// C++11保证静态局部变量的初始化是线程安全的</span></span><br><span class="line">                <span class="type">static</span> T instance;</span><br><span class="line">                <span class="keyword">return</span> &amp;instance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            Singleton&lt;T&gt; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在C++宏定义中，反斜杠\的主要用途是作为续行符，表示宏定义在下一行继续</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> SINGLETON(classname)                                        \</span></span><br><span class="line"><span class="meta">            friend class Singleton<span class="string">&lt;classname&gt;</span>;                              \</span></span><br><span class="line"><span class="meta">            private:                                                        \</span></span><br><span class="line"><span class="meta">                classname() = default;                                      \</span></span><br><span class="line"><span class="meta">                classname(const classname &amp;) = delete;                      \</span></span><br><span class="line"><span class="meta">                classname &amp; operator=(const classname &amp;) = delete;          \</span></span><br><span class="line"><span class="meta">                ~classname() = default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/a.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/singleton.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用宏来简化重复编码，非常方便</span></span><br><span class="line">    <span class="built_in">SINGLETON</span>(A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="使用带模板的单例模式优化日志系统">使用带模板的单例模式优化日志系统</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">option</span> CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;utility/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE .)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/singleton.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义模板类</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> T * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;   </span><br><span class="line">                <span class="comment">// C++11保证静态局部变量的初始化是线程安全的</span></span><br><span class="line">                <span class="type">static</span> T instance;</span><br><span class="line">                <span class="keyword">return</span> &amp;instance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            Singleton&lt;T&gt; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">            ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在C++宏定义中，反斜杠\的主要用途是作为续行符，表示宏定义在下一行继续</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> SINGLETON(classname)                                        \</span></span><br><span class="line"><span class="meta">            friend class Singleton<span class="string">&lt;classname&gt;</span>;                              \</span></span><br><span class="line"><span class="meta">            private:                                                        \</span></span><br><span class="line"><span class="meta">                classname() = default;                                      \</span></span><br><span class="line"><span class="meta">                classname(const classname &amp;) = delete;                      \</span></span><br><span class="line"><span class="meta">                classname &amp; operator=(const classname &amp;) = delete;          \</span></span><br><span class="line"><span class="meta">                ~classname() = default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// singleton/logger.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span>          <span class="comment">// 使用可变参数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/singleton.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了sleep()支持跨平台</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义日志宏以便于使用</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_debug(format, ...) \</span></span><br><span class="line"><span class="meta">            Singleton<span class="string">&lt;Logger&gt;</span>::instance()-&gt;log(Logger::LOG_DEBUG, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_info(format, ...) \</span></span><br><span class="line"><span class="meta">            Singleton<span class="string">&lt;Logger&gt;</span>::instance()-&gt;log(Logger::LOG_INFO, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_warn(format, ...) \</span></span><br><span class="line"><span class="meta">            Singleton<span class="string">&lt;Logger&gt;</span>::instance()-&gt;log(Logger::LOG_WARN, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_error(format, ...) \</span></span><br><span class="line"><span class="meta">            Singleton<span class="string">&lt;Logger&gt;</span>::instance()-&gt;log(Logger::LOG_ERROR, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_fatal(format, ...) \</span></span><br><span class="line"><span class="meta">            Singleton<span class="string">&lt;Logger&gt;</span>::instance()-&gt;log(Logger::LOG_FATAL, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负责记录日志的Logger类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">            <span class="built_in">SINGLETON</span>(Logger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">// 定义日志级别的枚举</span></span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">Level</span></span><br><span class="line">            &#123;</span><br><span class="line">                LOG_DEBUG = <span class="number">0</span>,</span><br><span class="line">                LOG_INFO,</span><br><span class="line">                LOG_WARN,</span><br><span class="line">                LOG_ERROR,</span><br><span class="line">                LOG_FATAL,</span><br><span class="line">                LOG_COUNT</span><br><span class="line">            &#125;;     </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志之前需先打开日志文件</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>;</span><br><span class="line">            <span class="comment">// 关闭日志文件</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">// 记录日志(日志级别、日志所在文件、日志所在文件的行号、日志格式、可变参数)</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span>;</span><br><span class="line">            <span class="comment">// 设置日志级别</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_level</span><span class="params">(Level level)</span></span>;</span><br><span class="line">            <span class="comment">// 设置日志的最大长度</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_max_size</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">            <span class="comment">// 控制台打印日志开关</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_console</span><span class="params">(<span class="type">bool</span> console)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">// 日志翻滚</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">// 支持跨平台的localtime接口</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">localtime</span><span class="params">(<span class="keyword">struct</span> tm * time_info, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span>;</span><br><span class="line">            <span class="comment">// 支持跨平台的sleep接口,单位毫秒</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            string m_filename;                          <span class="comment">// 日志文件名</span></span><br><span class="line">            std::ofstream m_ofs;                        <span class="comment">// 当前打开的日志文件流</span></span><br><span class="line">            <span class="type">int</span> m_max = <span class="number">0</span>;                              <span class="comment">// 日志的最大长度，默认值为0</span></span><br><span class="line">            <span class="type">int</span> m_len = <span class="number">0</span>;                              <span class="comment">// 记录当前日志的长度</span></span><br><span class="line">            <span class="type">int</span> m_level = LOG_DEBUG;                    <span class="comment">// 日志级别</span></span><br><span class="line">            <span class="type">bool</span> m_console = <span class="literal">true</span>;                      <span class="comment">// 控制台打印日志内容开关</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * s_level[LOG_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// singleton/logger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * Logger::s_level[LOG_COUNT] = &#123;<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;WARN&quot;</span>, <span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;FATAL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::open</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_filename = filename;</span><br><span class="line">    m_ofs.<span class="built_in">open</span>(filename, std::ios::app);        <span class="comment">// 以追加的方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (m_ofs.<span class="built_in">fail</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;open log file failed: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开日志文件时需计算已写入多少内容</span></span><br><span class="line">    m_ofs.<span class="built_in">seekp</span>(<span class="number">0</span>, std::ios::end);              <span class="comment">// 将文件指针移动至文件结尾</span></span><br><span class="line">    m_len = (<span class="type">int</span>)m_ofs.<span class="built_in">tellp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::set_level</span><span class="params">(Level level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_level = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::set_max_size</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_max = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::set_console</span><span class="params">(<span class="type">bool</span> console)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_console = console;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...是可变参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_level &gt; level)                    <span class="comment">// 低级别日志直接忽略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_ofs.<span class="built_in">fail</span>())                       <span class="comment">// 检查文件流是否处于有效的活跃状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> time_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">localtime</span>(&amp;time_info, &amp;ticks);        <span class="comment">// 把整型的时间戳转换为年月日时分秒</span></span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;time_info);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;                            <span class="comment">// 日志记录内容的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * fmt = <span class="string">&quot;%s %s %s:%d &quot;</span>;       <span class="comment">// 时间 级别 源文件:行号</span></span><br><span class="line">    <span class="comment">// 计算格式化字符串的长度</span></span><br><span class="line">    len = <span class="built_in">snprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, fmt, timestamp, s_level[m_level], file, line);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buffer = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, len + <span class="number">1</span>, fmt, timestamp, s_level[m_level], file, line);</span><br><span class="line">        buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        oss &lt;&lt; buffer;</span><br><span class="line">        m_len += len;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数的处理:</span></span><br><span class="line">    va_list arg_ptr;                                    <span class="comment">// 首先定义va_list类型变量作为可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr, format);                          <span class="comment">// 然后使用va_start进行初始化</span></span><br><span class="line">    len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, arg_ptr);       <span class="comment">// 拿到可变参数组装成日志的长度</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);                                    <span class="comment">// 调用va_end清理释放可变参数资源</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * content = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(content, len + <span class="number">1</span>, format, arg_ptr);</span><br><span class="line">        <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">        content[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        oss &lt;&lt; content;</span><br><span class="line">        m_len += len;</span><br><span class="line">        <span class="keyword">delete</span>[] content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 日志内容每一行最后需要换行</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> string &amp; str = oss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_console)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line">    m_ofs &lt;&lt; str;</span><br><span class="line">    <span class="comment">// 强制将缓冲区中的数据立即写入到关联的文件中</span></span><br><span class="line">    m_ofs.<span class="built_in">flush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_max &gt; <span class="number">0</span> &amp;&amp; m_len &gt;= m_max)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log rotate: m_len = &quot;</span> &lt;&lt; m_len &lt;&lt; <span class="string">&quot;, m_max = &quot;</span> &lt;&lt; m_max &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 日志需要翻滚</span></span><br><span class="line">        <span class="built_in">rotate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志翻滚</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::rotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先关闭当前日志流</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// sleep1秒是为避免短时间内发生了多次日志翻滚而备份日志文件名相同</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 为避免日志文件名重复，日志文件名中采用时间戳</span></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> time_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">localtime</span>(&amp;time_info, &amp;ticks);</span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), <span class="string">&quot;.%Y-%m-%d_%H-%M-%S&quot;</span>, &amp;time_info);</span><br><span class="line">    string filename = m_filename + timestamp;</span><br><span class="line">    <span class="comment">// 如果new_filename不存在，则将old_filename重命名为new_filename;</span></span><br><span class="line">    <span class="comment">// 如果new_filename存在，会删除已存在的new_filename然后将old_filename重命名为new_filename</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rename</span>(m_filename.<span class="built_in">c_str</span>(), filename.<span class="built_in">c_str</span>()) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;rename ini file failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">open</span>(m_filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">Sleep</span>(milliseconds);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">usleep</span>(milliseconds * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::localtime</span><span class="params">(<span class="keyword">struct</span> tm * time_info, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 支持Windows平台和Linux平台</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32        </span></span><br><span class="line">    <span class="built_in">localtime_s</span>(time_info, ticks);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">localtime_r</span>(ticks, time_info);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> logger = Singleton&lt;Logger&gt;::<span class="built_in">instance</span>();</span><br><span class="line">    logger-&gt;<span class="built_in">open</span>(<span class="string">&quot;./main.log&quot;</span>);</span><br><span class="line">    logger-&gt;<span class="built_in">set_max_size</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">log_debug</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">log_error</span>(<span class="string">&quot;%s %d&quot;</span>, <span class="string">&quot;this is an error&quot;</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志系统</title>
      <link href="/2024/01/28/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/01/28/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="日志功能介绍">日志功能介绍</h1><p>程序特别是后台服务运行时，如果在线上出现问题，一般都是通过查找日志来定位原因的。比如程序崩溃或者运行不符合预期，最佳的方式就是查看日志文件，因此在开发时程序员要考虑将重要信息记录到日志文件中。</p><ol><li>日志存储：文本文件，文件后缀为<code>.log</code></li><li>日志内容：时间、级别、文件、行号、内容</li><li>日志级别：<code>debug &lt; info &lt; warn &lt; error &lt; fatal</code></li><li>日志翻滚：当日志的大小超过设置值，那么日志内容将保存到新文件</li><li>跨平台：支持 Linux、Windows 等不同的平台</li></ol><h1 id="日志功能设计与实现">日志功能设计与实现</h1><h2 id="日志写入">日志写入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_level &gt; level)                    <span class="comment">// 低级别日志直接忽略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_ofs.<span class="built_in">fail</span>())                       <span class="comment">// 检查文件流是否处于有效的活跃状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> time_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">localtime</span>(&amp;time_info, &amp;ticks);        <span class="comment">// 把整型的时间戳转换为年月日时分秒</span></span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;time_info);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;                            <span class="comment">// 日志记录内容的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * fmt = <span class="string">&quot;%s %s %s:%d &quot;</span>;       <span class="comment">// 时间 级别 源文件:行号</span></span><br><span class="line">    <span class="comment">// 计算格式化字符串的长度</span></span><br><span class="line">    len = <span class="built_in">snprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, fmt, timestamp, s_level[m_level], file, line);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buffer = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, len + <span class="number">1</span>, fmt, timestamp, s_level[m_level], file, line);</span><br><span class="line">        buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        oss &lt;&lt; buffer;</span><br><span class="line">        m_len += len;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数的处理:</span></span><br><span class="line">    va_list arg_ptr;                                    <span class="comment">// 首先定义va_list类型变量作为可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr, format);                          <span class="comment">// 然后使用va_start进行初始化</span></span><br><span class="line">    len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, arg_ptr);       <span class="comment">// 拿到可变参数组装成日志的长度</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);                                    <span class="comment">// 调用va_end清理释放可变参数资源</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * content = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(content, len + <span class="number">1</span>, format, arg_ptr);</span><br><span class="line">        <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">        content[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        oss &lt;&lt; content;</span><br><span class="line">        m_len += len;</span><br><span class="line">        <span class="keyword">delete</span>[] content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 日志内容每一行最后需要换行</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> string &amp; str = oss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_console)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line">    m_ofs &lt;&lt; str;</span><br><span class="line">    <span class="comment">// 强制将缓冲区中的数据立即写入到关联的文件中</span></span><br><span class="line">    m_ofs.<span class="built_in">flush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_max &gt; <span class="number">0</span> &amp;&amp; m_len &gt;= m_max)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log rotate: m_len = &quot;</span> &lt;&lt; m_len &lt;&lt; <span class="string">&quot;, m_max = &quot;</span> &lt;&lt; m_max &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 日志需要翻滚</span></span><br><span class="line">        <span class="built_in">rotate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志翻滚">日志翻滚</h2><p>日志是以追加方式写入文件中，随着时间推移日志文件会越来越大，当日志文件非常大时打开该日志文件会很慢，为了优化体验需要引入日志翻滚功能。日志翻滚是指先设置一个最大日志文件大小，当日志文件超过该大小时会先将旧日志内容备份，新的日志信息会写入另一份日志文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志翻滚</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::rotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先关闭当前日志流</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// sleep1秒是为避免短时间内发生了多次日志翻滚而备份日志文件名相同</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 为避免日志文件名重复，日志文件名中采用时间戳</span></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> time_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">localtime</span>(&amp;time_info, &amp;ticks);</span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), <span class="string">&quot;.%Y-%m-%d_%H-%M-%S&quot;</span>, &amp;time_info);</span><br><span class="line">    string filename = m_filename + timestamp;</span><br><span class="line">    <span class="comment">// 如果new_filename不存在，则将old_filename重命名为new_filename;</span></span><br><span class="line">    <span class="comment">// 如果new_filename存在，会删除已存在的new_filename然后将old_filename重命名为new_filename</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rename</span>(m_filename.<span class="built_in">c_str</span>(), filename.<span class="built_in">c_str</span>()) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;rename ini file failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">open</span>(m_filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨平台">跨平台</h2><p>在<code>Logger::log()</code>实现中调用了<code>localtime_s()</code>将时间戳<code>time_t</code>类型转换为本地时间<code>struct tm</code>，但该函数是Windows平台实现，不是跨平台的，Linux平台上对应的是<code>localtime_r()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">Sleep</span>(milliseconds);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">usleep</span>(milliseconds * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::localtime</span><span class="params">(<span class="keyword">struct</span> tm * time_info, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 支持Windows平台和Linux平台</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32        </span></span><br><span class="line">    <span class="built_in">localtime_s</span>(time_info, ticks);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">localtime_r</span>(ticks, time_info);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志单例">日志单例</h2><p>当前日志使用时需要通过创建实例<code>Logger log;</code>，但对于应用程序来说日志是全局的，在不同模块代码中调用的应该是同一个日志实例，因此需要将日志用单例模式来实现，全局仅有一个实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    </span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">// 单例模式为了保证全局只有一个日志实例，需要将其构造函数和析构函数声明为私有的</span></span><br><span class="line">            <span class="built_in">Logger</span>();</span><br><span class="line">            ~<span class="built_in">Logger</span>();</span><br><span class="line">            ......</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 静态指针指向全局唯一的Logger对象</span></span><br><span class="line">            <span class="type">static</span> Logger * m_instance;</span><br><span class="line">        &#125;;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/logger.cpp</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Logger * Logger::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Logger * <span class="title">Logger::instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="日志宏实现">日志宏实现</h2><p>在调试程序时可能会快速查看局部变量等信息，当前记录一条日志会调用<code>Logger::instance()-&gt;log()</code>，并传入日志级别、源文件名、文件行号和日志信息，这样比较冗长不便，可以引入宏来优化这部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义日志宏以便于使用</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_debug(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_DEBUG, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_info(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_INFO, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_warn(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_WARN, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_error(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_ERROR, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_fatal(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_FATAL, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">├── main.ini</span><br><span class="line">└── utility</span><br><span class="line">    ├── ini_file.cpp</span><br><span class="line">    ├── ini_file.h</span><br><span class="line">    ├── logger.cpp</span><br><span class="line">    ├── logger.h</span><br><span class="line">    ├── option.cpp</span><br><span class="line">    ├── option.h</span><br><span class="line">    ├── value.cpp</span><br><span class="line">    └── value.h</span><br><span class="line"></span><br><span class="line">2 directories, 11 files</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">option</span> CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;utility/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE .)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/logger.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span>          <span class="comment">// 使用可变参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了sleep()支持跨平台</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义日志宏以便于使用</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_debug(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_DEBUG, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_info(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_INFO, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_warn(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_WARN, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_error(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_ERROR, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> log_fatal(format, ...) \</span></span><br><span class="line"><span class="meta">            Logger::instance()-&gt;log(Logger::LOG_FATAL, __FILE__, __LINE__, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负责记录日志的Logger类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">// 定义日志级别的枚举</span></span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">Level</span></span><br><span class="line">            &#123;</span><br><span class="line">                LOG_DEBUG = <span class="number">0</span>,</span><br><span class="line">                LOG_INFO,</span><br><span class="line">                LOG_WARN,</span><br><span class="line">                LOG_ERROR,</span><br><span class="line">                LOG_FATAL,</span><br><span class="line">                LOG_COUNT</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 静态方法拿到全局的实例指针</span></span><br><span class="line">            <span class="function"><span class="type">static</span> Logger * <span class="title">instance</span><span class="params">()</span></span>;     </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志之前需先打开日志文件</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>;</span><br><span class="line">            <span class="comment">// 关闭日志文件</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">// 记录日志(日志级别、日志所在文件、日志所在文件的行号、日志格式、可变参数)</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span>;</span><br><span class="line">            <span class="comment">// 设置日志级别</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_level</span><span class="params">(Level level)</span></span>;</span><br><span class="line">            <span class="comment">// 设置日志的最大长度</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_max_size</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">            <span class="comment">// 控制台打印日志开关</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_console</span><span class="params">(<span class="type">bool</span> console)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">// 单例模式为了保证全局只有一个日志实例，需要将其构造函数和析构函数声明为私有的</span></span><br><span class="line">            <span class="built_in">Logger</span>();</span><br><span class="line">            ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 日志翻滚</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">// 支持跨平台的localtime接口</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">localtime</span><span class="params">(<span class="keyword">struct</span> tm * time_info, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span>;</span><br><span class="line">            <span class="comment">// 支持跨平台的sleep接口,单位毫秒</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            string m_filename;                          <span class="comment">// 日志文件名</span></span><br><span class="line">            std::ofstream m_ofs;                        <span class="comment">// 当前打开的日志文件流</span></span><br><span class="line">            <span class="type">int</span> m_max;                                  <span class="comment">// 日志的最大长度，默认值为0</span></span><br><span class="line">            <span class="type">int</span> m_len;                                  <span class="comment">// 记录当前日志的长度</span></span><br><span class="line">            <span class="type">int</span> m_level;                                <span class="comment">// 日志级别</span></span><br><span class="line">            <span class="type">bool</span> m_console;                             <span class="comment">// 控制台打印日志内容开关</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * s_level[LOG_COUNT];</span><br><span class="line">            <span class="type">static</span> Logger * m_instance;               <span class="comment">// 静态指针指向全局唯一的Logger对象</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/logger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * Logger::s_level[LOG_COUNT] = &#123;<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;WARN&quot;</span>, <span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;FATAL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">Logger * Logger::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Logger</span>() : <span class="built_in">m_level</span>(LOG_DEBUG), <span class="built_in">m_len</span>(<span class="number">0</span>), <span class="built_in">m_max</span>(<span class="number">0</span>) <span class="comment">// 默认情况下不支持日志翻滚</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::~<span class="built_in">Logger</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>();                                    <span class="comment">// 关闭打开的日志文件流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Logger * <span class="title">Logger::instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::open</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_filename = filename;</span><br><span class="line">    m_ofs.<span class="built_in">open</span>(filename, std::ios::app);        <span class="comment">// 以追加的方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (m_ofs.<span class="built_in">fail</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;open log file failed: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开日志文件时需计算已写入多少内容</span></span><br><span class="line">    m_ofs.<span class="built_in">seekp</span>(<span class="number">0</span>, std::ios::end);              <span class="comment">// 将文件指针移动至文件结尾</span></span><br><span class="line">    m_len = (<span class="type">int</span>)m_ofs.<span class="built_in">tellp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::set_level</span><span class="params">(Level level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_level = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::set_max_size</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_max = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::set_console</span><span class="params">(<span class="type">bool</span> console)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_console = console;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...是可变参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_level &gt; level)                    <span class="comment">// 低级别日志直接忽略</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_ofs.<span class="built_in">fail</span>())                       <span class="comment">// 检查文件流是否处于有效的活跃状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> time_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">localtime</span>(&amp;time_info, &amp;ticks);        <span class="comment">// 把整型的时间戳转换为年月日时分秒</span></span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;time_info);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;                            <span class="comment">// 日志记录内容的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * fmt = <span class="string">&quot;%s %s %s:%d &quot;</span>;       <span class="comment">// 时间 级别 源文件:行号</span></span><br><span class="line">    <span class="comment">// 计算格式化字符串的长度</span></span><br><span class="line">    len = <span class="built_in">snprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, fmt, timestamp, s_level[m_level], file, line);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buffer = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, len + <span class="number">1</span>, fmt, timestamp, s_level[m_level], file, line);</span><br><span class="line">        buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        oss &lt;&lt; buffer;</span><br><span class="line">        m_len += len;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数的处理:</span></span><br><span class="line">    va_list arg_ptr;                                    <span class="comment">// 首先定义va_list类型变量作为可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr, format);                          <span class="comment">// 然后使用va_start进行初始化</span></span><br><span class="line">    len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, arg_ptr);       <span class="comment">// 拿到可变参数组装成日志的长度</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);                                    <span class="comment">// 调用va_end清理释放可变参数资源</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * content = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">va_start</span>(arg_ptr, format);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(content, len + <span class="number">1</span>, format, arg_ptr);</span><br><span class="line">        <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line">        content[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        oss &lt;&lt; content;</span><br><span class="line">        m_len += len;</span><br><span class="line">        <span class="keyword">delete</span>[] content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 日志内容每一行最后需要换行</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> string &amp; str = oss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_console)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line">    m_ofs &lt;&lt; str;</span><br><span class="line">    <span class="comment">// 强制将缓冲区中的数据立即写入到关联的文件中</span></span><br><span class="line">    m_ofs.<span class="built_in">flush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_max &gt; <span class="number">0</span> &amp;&amp; m_len &gt;= m_max)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log rotate: m_len = &quot;</span> &lt;&lt; m_len &lt;&lt; <span class="string">&quot;, m_max = &quot;</span> &lt;&lt; m_max &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 日志需要翻滚</span></span><br><span class="line">        <span class="built_in">rotate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志翻滚</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::rotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先关闭当前日志流</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// sleep1秒是为避免短时间内发生了多次日志翻滚而备份日志文件名相同</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 为避免日志文件名重复，日志文件名中采用时间戳</span></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> time_info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">localtime</span>(&amp;time_info, &amp;ticks);</span><br><span class="line">    <span class="type">char</span> timestamp[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strftime</span>(timestamp, <span class="built_in">sizeof</span>(timestamp), <span class="string">&quot;.%Y-%m-%d_%H-%M-%S&quot;</span>, &amp;time_info);</span><br><span class="line">    string filename = m_filename + timestamp;</span><br><span class="line">    <span class="comment">// 如果new_filename不存在，则将old_filename重命名为new_filename;</span></span><br><span class="line">    <span class="comment">// 如果new_filename存在，会删除已存在的new_filename然后将old_filename重命名为new_filename</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rename</span>(m_filename.<span class="built_in">c_str</span>(), filename.<span class="built_in">c_str</span>()) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;rename ini file failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">open</span>(m_filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::sleep</span><span class="params">(<span class="type">int</span> milliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">Sleep</span>(milliseconds);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">usleep</span>(milliseconds * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::localtime</span><span class="params">(<span class="keyword">struct</span> tm * time_info, <span class="type">const</span> <span class="type">time_t</span> * ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 支持Windows平台和Linux平台</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32        </span></span><br><span class="line">    <span class="built_in">localtime_s</span>(time_info, ticks);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">localtime_r</span>(ticks, time_info);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Logger::<span class="built_in">instance</span>()-&gt;<span class="built_in">open</span>(<span class="string">&quot;./main.log&quot;</span>);</span><br><span class="line">    Logger::<span class="built_in">instance</span>()-&gt;<span class="built_in">set_max_size</span>(<span class="number">1024</span>);</span><br><span class="line">    Logger::<span class="built_in">instance</span>()-&gt;<span class="built_in">set_console</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//Logger::instance()-&gt;log(Logger::LOG_DEBUG, __FILE__, __LINE__, &quot;%s %d %d&quot;, &quot;hello world&quot;, i, 123);</span></span><br><span class="line">        <span class="built_in">log_debug</span>(<span class="string">&quot;%s %d %d&quot;</span>, <span class="string">&quot;hello world&quot;</span>, i, <span class="number">123</span>);</span><br><span class="line">        <span class="built_in">log_error</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;this is an error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ini解析器</title>
      <link href="/2024/01/21/ini%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>/2024/01/21/ini%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="常用配置文件类型">常用配置文件类型</h1><p>项目中一般会用到的配置文件有4种类型：</p><ol><li><p><code>INI</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile]</span></span><br><span class="line"><span class="attr">name</span> = jack</span><br><span class="line"><span class="attr">gender</span> = male</span><br><span class="line"><span class="attr">age</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure><p>优点：非常简单，书写方便</p><p>缺点：不能表达复杂的数据格式</p><p>应用场景：配置文件</p></li><li><p><code>XML</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ip</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">ip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：可以表达复杂的数据格式</p><p>缺点：书写麻烦</p><p>应用场景：配置文件，数据传输</p></li><li><p><code>JSON</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jack&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>优点：简单，可以表达复杂的数据格式</p><p>缺点：书写麻烦</p><p>应用场景：配置文件，数据传输</p></li><li><p><code>YAML</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">ip:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">profile:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">jack</span></span><br><span class="line">    <span class="attr">gender:</span> <span class="string">male</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>优点：简单直观，书写方便，可以表达复杂的数据格式</p><p>缺点：它使用空白符号缩进，使用场景受限，无法进行数据传输</p><p>运用场景：配置文件</p></li></ol><h1 id="为什么要用ini配置？">为什么要用INI配置？</h1><ol><li>非常简单，书写方便</li><li>运用广泛：linux绝大多数开源软件都采用<code>ini</code>配置，比如Mysql、Redis、PHP、OpenStack等</li></ol><p><code>INI</code>文件的格式很简单，例如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile]</span></span><br><span class="line"><span class="attr">name</span> = jack</span><br><span class="line"><span class="attr">gender</span> = male</span><br><span class="line"><span class="attr">age</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li>最基本的三个要素是：section、option、value</li><li>配置文件中可以包含多个section，每个section下面可以有多个option</li><li>option/value类似字典的key/value对，以=分隔</li><li>注释以#或者;开头</li></ul><h1 id="inifile解析器设计与实现">IniFile解析器设计与实现</h1><p><code>IniFile</code>是专门用来解析<code>INI</code>配置文件的，主要包括<code>INI</code>文件解析和<code>INI</code>常用操作。</p><p><code>INI</code>格式的三要素是<code>section</code>、<code>option</code>和<code>value</code>，其中<code>option</code>和<code>value</code>就是<code>map</code>中的<code>key-value</code>键值对关系。而对于一个<code>INI</code>文件来说有很多<code>section</code>，每个<code>section</code>有自己的名称，那么也可以用<code>map</code>来存储<code>section</code>名称到对应<code>section</code>内容的映射关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">├── main.ini</span><br><span class="line">└── utility</span><br><span class="line">    ├── ini_file.cpp</span><br><span class="line">    ├── ini_file.h</span><br><span class="line">    ├── option.cpp</span><br><span class="line">    ├── option.h</span><br><span class="line">    ├── value.cpp</span><br><span class="line">    └── value.h</span><br><span class="line"></span><br><span class="line">1 directory, 9 files</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">option</span> CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;utility/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE .)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/ini_file.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/value.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// INI配置文件解析器</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">IniFile</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Section即INI文件格式中的section，键值对即该section中的option和value</span></span><br><span class="line">            <span class="keyword">using</span> Section = std::map&lt;string, Value&gt;;</span><br><span class="line">            <span class="comment">// typdef std::map&lt;string, Value&gt; Section;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">IniFile</span>() = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">IniFile</span>(<span class="type">const</span> string &amp; filename);</span><br><span class="line">            ~<span class="built_in">IniFile</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析INI配置文件内容</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">load</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回INI配置文件的内容</span></span><br><span class="line">            <span class="function">string <span class="title">str</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="comment">// 打印INI文件中的所有配置项</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取INI配置文件中指定配置项内容</span></span><br><span class="line">            <span class="function">Value &amp; <span class="title">get</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key)</span></span>;</span><br><span class="line">            <span class="comment">// 设置INI配置文件中指定配置项内容</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key, <span class="type">const</span> Value &amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重载[]运算符便于用户使用，也更直观</span></span><br><span class="line">            Section &amp; <span class="keyword">operator</span>[](<span class="type">const</span> string &amp; section)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_sections[section];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断INI配置文件中是否存在某个section</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">has</span><span class="params">(<span class="type">const</span> string &amp; section)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">has</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除某个section</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> string &amp; section)</span></span>;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="comment">// 保存到配置文件中</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function">string <span class="title">trim</span><span class="params">(string str)</span></span>;                <span class="comment">// 将每一行前后的换行符去除掉</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            string m_filename;                      <span class="comment">// 保存INI文件的名称</span></span><br><span class="line">            std::map&lt;string, Section&gt; m_sections;   <span class="comment">// 记录section名称到对应section内容的映射关系</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/ini_file.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/ini_file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line">IniFile::<span class="built_in">IniFile</span>(<span class="type">const</span> string &amp; filename)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">load</span>(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">IniFile::trim</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字符串前端的空格/换行/回车去掉</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \r\n&quot;</span>));</span><br><span class="line">    <span class="comment">// 将字符串尾端的空格/换行/回车去掉</span></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \r\n&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IniFile::load</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sections.<span class="built_in">clear</span>();</span><br><span class="line">    m_filename = filename;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">fail</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;loading ini file failed: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    string line, name;</span><br><span class="line">    <span class="comment">// 读取每一行文件</span></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ifs, line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将每一行前后的换行符去除掉</span></span><br><span class="line">        line = <span class="built_in">trim</span>(line);</span><br><span class="line">        <span class="comment">// 如果是空行则直接略过</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果此行为注释则直接略过</span></span><br><span class="line">        <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以[开头则出现一个section</span></span><br><span class="line">        <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;invalid section: &quot;</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">            name = <span class="built_in">trim</span>(line.<span class="built_in">substr</span>(<span class="number">1</span>, pos - <span class="number">1</span>));</span><br><span class="line">            m_sections[name] = <span class="built_in">Section</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解析section中的key-value</span></span><br><span class="line">            <span class="keyword">auto</span> pos = line.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;invalid option: &quot;</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">            string key = <span class="built_in">trim</span>(line.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">            string val = <span class="built_in">trim</span>(line.<span class="built_in">substr</span>(pos + <span class="number">1</span>));</span><br><span class="line">            m_sections[name][key] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">IniFile::str</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; section : m_sections)</span><br><span class="line">    &#123;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; section.first &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; option : section.second)</span><br><span class="line">        &#123;</span><br><span class="line">            ss &lt;&lt; option.first &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">string</span>(option.second) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ss &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniFile::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value &amp; <span class="title">IniFile::get</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sections[section][key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniFile::set</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key, <span class="type">const</span> Value &amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sections[section][key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IniFile::has</span><span class="params">(<span class="type">const</span> string &amp; section)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sections.<span class="built_in">find</span>(section) != m_sections.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IniFile::has</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key)</span>\</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_sections.<span class="built_in">find</span>(section);</span><br><span class="line">    <span class="keyword">if</span> (it == m_sections.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second.<span class="built_in">find</span>(key) == it-&gt;second.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniFile::remove</span><span class="params">(<span class="type">const</span> string &amp; section)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sections.<span class="built_in">erase</span>(section);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniFile::remove</span><span class="params">(<span class="type">const</span> string &amp; section, <span class="type">const</span> string &amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_sections.<span class="built_in">find</span>(section);</span><br><span class="line">    <span class="keyword">if</span> (it == m_sections.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;second.<span class="built_in">erase</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniFile::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sections.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniFile::save</span><span class="params">(<span class="type">const</span> string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ofs.<span class="built_in">fail</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;saving ini file failed: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    ofs &lt;&lt; <span class="built_in">str</span>();</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/ini_file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">IniFile <span class="title">ini</span><span class="params">(<span class="string">&quot;./main.ini&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ini[<span class="string">&quot;server&quot;</span>][<span class="string">&quot;ip&quot;</span>] = <span class="string">&quot;192.168.1.1&quot;</span>;</span><br><span class="line">    ini[<span class="string">&quot;server&quot;</span>][<span class="string">&quot;port&quot;</span>] = <span class="number">8000</span>;</span><br><span class="line">    ini.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态数据类型</title>
      <link href="/2024/01/14/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/01/14/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="命令行参数解析实现存在的问题分析">命令行参数解析实现存在的问题分析</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/option.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Option opt;</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;a&quot;</span>, Option::OPT_NO);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;b&quot;</span>, Option::OPT_REQUIRED);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;c&quot;</span>, Option::OPT_OPTIONAL);</span><br><span class="line">    opt.<span class="built_in">parse</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> a = opt.<span class="built_in">get_bool</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b = opt.<span class="built_in">get_int</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    string c = opt.<span class="built_in">get_string</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取基本数据类型<code>getter()</code>这部分需要优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = opt.<span class="built_in">get_bool</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">int</span> b = opt.<span class="built_in">get_int</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">string c = opt.<span class="built_in">get_string</span>(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果要获取命令行参数是浮点类型需要新增<code>get_float()</code>方法，这样就会存在一堆<code>get_xxx()</code>方法。期望优化后达到以下目标，都使用一个<code>get()</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a = obj.<span class="built_in">get</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">int</span> b = obj.<span class="built_in">get</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">string c = obj.<span class="built_in">get</span>(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里无法通过函数重载来实现，因为这里参数数量和参数类型都相同，仅返回值不同，可能需要思考更巧妙的方式来解决。</p><p>对于设置基本数据类型<code>setter()</code>也需要优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">set_bool</span>(<span class="string">&quot;a&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">obj.<span class="built_in">set_int</span>(<span class="string">&quot;b&quot;</span>, <span class="number">123</span>);</span><br><span class="line">obj.<span class="built_in">set_string</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>期望优化后统一使用<code>set()</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">set</span>(<span class="string">&quot;a&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">obj.<span class="built_in">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">123</span>);</span><br><span class="line">obj.<span class="built_in">set</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>set()</code>可以通过函数重载方式来实现，因为虽然参数数量相同，但第二个参数类型不同。</p><p>但如果有了<code>Value</code>对象对基本数据类型进行封装，可以把基本数据类型转换为<code>Value</code>对象，而<code>Value</code>对象也可以转换为基本数据类型，这样就无需使用到函数重载技术了。</p><h1 id="value设计与实现">Value设计与实现</h1><p><img src="https://aliyun-oss-zh.oss-cn-beijing.aliyuncs.com/img/QQ20250610-183000.jpg" alt=""></p><p><code>Value</code>是一个类，左侧是基本数据类型，这些基本数据类型可以存储到<code>Value</code>对象中，同时<code>Value</code>可以转换为对应的基本数据类型，如此可以达到数据动态类型的效果。</p><h2 id="构造函数">构造函数</h2><p>由<code>bool</code>构造<code>Value</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="literal">true</span>;<span class="comment">// Value v(true); </span></span><br></pre></td></tr></table></figure><p>由<code>int</code>构造<code>Value</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>由<code>float</code>构造<code>Value</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="number">1.23</span>;</span><br></pre></td></tr></table></figure><p>由<code>string</code>构造<code>Value</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符">赋值运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value v;</span><br><span class="line">v = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="类型转换运算符">类型转换运算符</h2><p><code>Value</code>转换成<code>bool</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> b = v;</span><br></pre></td></tr></table></figure><p><code>Value</code>转换成<code>int</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> i = v;</span><br></pre></td></tr></table></figure><p><code>Value</code>转换成<code>float</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="number">1.23</span>;</span><br><span class="line"><span class="type">float</span> f = v;</span><br></pre></td></tr></table></figure><p><code>Value</code>转换成<code>string</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value v = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">string s = v;</span><br></pre></td></tr></table></figure><p>类型转换运算符用法简洁，代码可读性会提升不少。</p><p>这里提供带<code>const</code>和不带<code>const</code>两个版本的类型转换运算符是为了在使用场景上支持更广泛。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── utility</span><br><span class="line">    ├── option.cpp</span><br><span class="line">    ├── option.h</span><br><span class="line">    ├── value.cpp</span><br><span class="line">    └── value.h</span><br><span class="line"></span><br><span class="line">1 directory, 6 files</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">option</span> CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;utility/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE .)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/value.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Value</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">// Value类是对基本数据类型的封装，将它能封装的类型放到枚举中</span></span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">            &#123;</span><br><span class="line">                V_NULL = <span class="number">0</span>,         <span class="comment">// 无类型</span></span><br><span class="line">                V_BOOL,</span><br><span class="line">                V_INT,</span><br><span class="line">                V_FLOAT,</span><br><span class="line">                V_DOUBLE,</span><br><span class="line">                V_STRING</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过构造函数将基本数据类型转入到Value</span></span><br><span class="line">            <span class="comment">// 空构造函数不传入任何值，其构造出来的Value是空的，即V_NULL</span></span><br><span class="line">            <span class="built_in">Value</span>();</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">bool</span> value);</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">int</span> value);</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">unsigned</span> <span class="type">int</span> value);</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">float</span> value);</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">double</span> value);</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">const</span> <span class="type">char</span>* value);</span><br><span class="line">            <span class="built_in">Value</span>(<span class="type">const</span> string&amp; value);</span><br><span class="line">            ~<span class="built_in">Value</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 赋值运算符</span></span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">bool</span>&amp; value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>&amp; value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">float</span>&amp; value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">double</span>&amp; value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string&amp; value);</span><br><span class="line">            Value&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Value&amp; other);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 将Value对象内部数据打印出来，便于调试</span></span><br><span class="line"></span><br><span class="line">            <span class="function">Type <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 获取Value对象的类型</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_null</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 判断Value对象的类型是否为空</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_bool</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 判断Value对象的类型是否为bool</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_float</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">is_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实现等于运算符和不等于运算符，判断两个Value对象是否相等</span></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Value&amp; other);</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Value&amp; other);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 类型转换运算符，将Value对象转换为指定类型</span></span><br><span class="line">            <span class="comment">// 为了在使用场景上支持更广泛，这里提供带const和不带const两个版本</span></span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="type">unsigned</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="type">unsigned</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Type m_type;</span><br><span class="line">            string m_value;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/value.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/value.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>() : <span class="built_in">m_type</span>(V_NULL)</span><br><span class="line">&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">bool</span> value) : <span class="built_in">m_type</span>(V_BOOL)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = value ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">int</span> value) : <span class="built_in">m_type</span>(V_INT)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">unsigned</span> <span class="type">int</span> value) : <span class="built_in">m_type</span>(V_INT)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">float</span> value) : <span class="built_in">m_type</span>(V_FLOAT)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">double</span> value) : <span class="built_in">m_type</span>(V_DOUBLE)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">const</span> <span class="type">char</span>* value) : <span class="built_in">m_type</span>(V_STRING)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value::<span class="built_in">Value</span>(<span class="type">const</span> string&amp; value) : <span class="built_in">m_type</span>(V_STRING)</span><br><span class="line">&#123;</span><br><span class="line">    m_value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Value::show</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    string type;</span><br><span class="line">    <span class="keyword">switch</span> (m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> V_NULL:</span><br><span class="line">            type = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> V_BOOL:</span><br><span class="line">            type = <span class="string">&quot;bool&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> V_INT:</span><br><span class="line">            type = <span class="string">&quot;int&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> V_FLOAT:</span><br><span class="line">            type = <span class="string">&quot;float&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> V_DOUBLE:</span><br><span class="line">            type = <span class="string">&quot;double&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> V_STRING:</span><br><span class="line">            type = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type = &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;, value = &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">bool</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = V_BOOL;</span><br><span class="line">    m_value = value ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">int</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = V_INT;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">float</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = V_FLOAT;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">double</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = V_DOUBLE;</span><br><span class="line">    m_value = std::<span class="built_in">to_string</span>(value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = V_STRING;</span><br><span class="line">    m_value = value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> string&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = V_STRING;</span><br><span class="line">    m_value = value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value&amp; Value::<span class="keyword">operator</span>=(<span class="type">const</span> Value&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = other.m_type;</span><br><span class="line">    m_value = other.m_value;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::Type <span class="title">Value::type</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Value::is_null</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == V_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Value::is_bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == V_BOOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Value::is_int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == V_INT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Value::is_float</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == V_FLOAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Value::is_double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == V_DOUBLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Value::is_string</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type == V_STRING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Value::<span class="keyword">operator</span>==(<span class="type">const</span> Value&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_type != other.m_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_value == other.m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Value::<span class="keyword">operator</span>!=(<span class="type">const</span> Value&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_value == <span class="string">&quot;true&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_value == <span class="string">&quot;true&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="type">unsigned</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="type">unsigned</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; m_value;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value::<span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命令行参数解析优化">命令行参数解析优化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/option.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短参数测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Option opt;</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;a&quot;</span>, Option::OPT_NO);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;b&quot;</span>, Option::OPT_REQUIRED);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;c&quot;</span>, Option::OPT_OPTIONAL);</span><br><span class="line">    opt.<span class="built_in">parse</span>(argc, argv);</span><br><span class="line">    <span class="type">bool</span> a = opt.<span class="built_in">get_bool</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b = opt.<span class="built_in">get_int</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    string c = opt.<span class="built_in">get_string</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前在做命令行参数解析时，通过调用<code>get_bool()</code>获取<code>bool</code>类型参数值，通过调用<code>get_int()</code>获取<code>int</code>类型参数值，通过调用<code>get_string()</code>获取<code>string</code>类型参数值，这种写法不够简洁优雅，期望是优化后统一调用<code>get()</code>方法。而引入<code>Value</code>动态数据类型后就可以达到期望的优化目标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/value.cpp 部分代码已省略</span></span><br><span class="line"></span><br><span class="line"><span class="function">Value <span class="title">Option::get</span><span class="params">(<span class="type">const</span> string&amp; opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_opts.<span class="built_in">find</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (it == m_opts.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Value</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (it-&gt;second)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> OPT_NO:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Value</span>(m_args.<span class="built_in">find</span>(opt) != m_args.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> OPT_OPTIONAL:</span><br><span class="line">        <span class="keyword">case</span> OPT_REQUIRED:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Value</span>(m_args[opt]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Value</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/option.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短参数测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Option opt;</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;a&quot;</span>, Option::OPT_NO);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;b&quot;</span>, Option::OPT_REQUIRED);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;c&quot;</span>, Option::OPT_OPTIONAL);</span><br><span class="line">    opt.<span class="built_in">parse</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> a = opt.<span class="built_in">get</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b = opt.<span class="built_in">get</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    string c = opt.<span class="built_in">get</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行参数解析</title>
      <link href="/2024/01/07/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/01/07/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作为程序员，在日常开发中经常使用Linux命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回上一级目录</span></span><br><span class="line">cd ..</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nodejs版本</span></span><br><span class="line">node --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网络端口</span></span><br><span class="line">netstat -a -n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件拷贝</span></span><br><span class="line">cp -rf 源文件 目标文件</span><br></pre></td></tr></table></figure><h1 id="命令行选项参数">命令行选项参数</h1><p>命令行选项参数分为短参数和长参数。</p><h2 id="短参数">短参数</h2><p>最常用的参数形式就是一个短横线后接一个字母，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command -a</span><br></pre></td></tr></table></figure><p>如果要一次加好几个短参数，可以用空格隔开，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command -a -b -C -c</span><br></pre></td></tr></table></figure><p>多个短参数也可以合并在一起，例如上面的命令等价于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command -abCc</span><br></pre></td></tr></table></figure><p>注意：参数的字母大小写是有区别的，大写的<code>C</code>和小写的<code>c</code>通常表示不同的意思。</p><p>有一些参数还需要给它赋一个值才行，例如短参数赋值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command -p 10</span><br></pre></td></tr></table></figure><p>表示把<code>10</code>赋值给参数<code>p</code>。</p><h2 id="长参数">长参数</h2><p>短参数是以一个短横线<code>-</code>开始，而长参数是以两个短横线<code>--</code>开始的，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command --parameter</span><br></pre></td></tr></table></figure><p>如果有多个长参数，是不能像多个短参数那样合并写的。只能以空格隔开写，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command --parameter1 --parameter2</span><br></pre></td></tr></table></figure><p>长参数一般是这样赋值的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command --parameter=10</span><br><span class="line">command --parameter 10</span><br></pre></td></tr></table></figure><p>也可以组合使用短参数和长参数，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command -paTc --parameter1 --parameter2</span><br></pre></td></tr></table></figure><p>有时候，同一个意义的参数有短参数和长参数两种形式，效果是一样的，可以任选其中一种。看起来长参数的方式更加容易理解，但是不如短参数那么简洁。</p><h1 id="c库解析命令行参数">C库解析命令行参数</h1><h2 id="短参数解析：getopt">短参数解析：getopt</h2><h3 id="函数定义">函数定义</h3><p><code>getopt()</code>可以解析短参数，但它不能解析长参数，所谓短参数就是指选项前只有一个<code>-</code>（比如<code>-t</code>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数说明:</span></span><br><span class="line"><span class="comment">* argc: 通常为 main 函数中的 argc</span></span><br><span class="line"><span class="comment">* argv: 通常为 main 函数中的 argv</span></span><br><span class="line"><span class="comment">* optstring: 短参数列表 (如:&quot;ab:c::&quot;)，它由多个部分组成，表示的意义分别为：</span></span><br><span class="line"><span class="comment">* * 不带值的参数，它的定义即是参数本身，表示选项。</span></span><br><span class="line"><span class="comment">* * 必须带值的参数，它的定义是在参数本身后面再加一个冒号。</span></span><br><span class="line"><span class="comment">* * 单个字符后跟两个冒号，表示该选项后可以跟一个参数，也可以不跟。</span></span><br><span class="line"><span class="comment">* 如果跟一个参数，参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv, <span class="type">const</span> <span class="type">char</span> *optstring)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="格式说明">格式说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *optstring = <span class="string">&quot;ab:c::&quot;</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>格式</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>单个字符a</td><td>表示选项a没有参数</td><td>格式：-a即可，不加参数</td></tr><tr><td>单个字符加冒号b:</td><td>表示选项b有且必须加参数</td><td>格式：-b 100 或 -b100，但 -b=100 错</td></tr><tr><td>单字符加两个冒号c::</td><td>表示选项c可以有，也可以无</td><td>格式：-c 或 -c200，其它格式错误</td></tr></tbody></table><h3 id="返回值">返回值</h3><p>如果选项成功找到，返回选项字母（字母对应的ASCII码）；如果所有命令行选项都解析完毕，返回<code>-1</code>；</p><p>如果遇到选项字符不在<code>optstring</code>中，返回字符<code>?</code>；</p><p>如果遇到丢失参数，那么返回值依赖于<code>optstring</code>中第一个字符；</p><p>如果第一个字符是<code>:</code>则返回<code>:</code>，否则返回<code>?</code>并提示出错误信息。</p><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;, s2[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;ab:c::&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(s1, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                c = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(s2, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;option a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;option b:%s\n&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;option c:%s\n&quot;</span>, s2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>optarg</code>是一个全局变量，它定义在<code>getopt.h</code>头文件中，另外还有三个全局变量<code>optind</code>、<code>optopt</code>和<code>opterr</code>。</p><p>执行命令及输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main1 main1.cpp</span><br><span class="line">./main1 -a -b jack -c200</span><br><span class="line">option a</span><br><span class="line">option b:jack</span><br><span class="line">option c:200</span><br></pre></td></tr></table></figure><p><code>getopt</code>问题分析：</p><ol><li><p>短参数列表（如：<code>&quot;ab:c::&quot;</code>）不是标准格式，记忆不方便</p></li><li><p>全局变量乱入：<code>optarg</code>、<code>optind</code>、<code>optopt</code>、<code>opterr</code></p></li><li><p>需要分配固定大小的临时字符串数组</p></li></ol><h2 id="长参数：getopt-long">长参数：getopt_long</h2><h3 id="函数定义">函数定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getopt_long</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> agrv[], <span class="type">const</span> <span class="type">char</span> *optstring, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="keyword">struct</span> option *longopts, <span class="type">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数说明">参数说明</h3><p>可以看到比<code>getopt()</code>多了两个参数<code>longopts</code>，<code>logindex</code>。</p><p><code>longopts</code>指明了长参数的名称和属性，可以看到它是一个结构体指针，我们通常传一个结构体数组<br>进去，每个元素代表一个参数，每个参数都是由下面的结构组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">option</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 参数名称 */</span></span><br><span class="line"><span class="type">int</span> has_arg; <span class="comment">/* 指明是否带有参数 */</span></span><br><span class="line"><span class="type">int</span> *flag; <span class="comment">/* flag=NULL时,返回value;不为空时,*flag=val,返回0 */</span></span><br><span class="line"><span class="type">int</span> val; <span class="comment">/* 用于指定函数找到选项的返回值(长选项的缩写)或flag非空时指定</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure><p>如果<code>longindex</code>非空，它指向的变量将记录当前找到参数符合<code>longopts</code>里的第几个元素的描述，即是<code>longopts</code>的下标值</p><h3 id="返回值">返回值</h3><p>对于短选项，返回值同<code>getopt</code>函数；<br>对于长选项，如果<code>flag</code>是<code>NULL</code>，返回<code>val</code>，否则返回<code>0</code>；对于错误情况返回值同<code>getopt</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> opt;</span><br><span class="line"><span class="type">int</span> opt_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">option</span> long_options[] =</span><br><span class="line">    &#123;</span><br><span class="line">            &#123;<span class="string">&quot;reqarg&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;optarg&quot;</span>, optional_argument, <span class="literal">NULL</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;noarg&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> ((opt = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;&quot;</span>, long_options, &amp;opt_idx)) != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;opt = %c\t\t&quot;</span>, opt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;optarg = %s\t\t&quot;</span>, optarg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;optind = %d\t\t&quot;</span>, optind);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[optind] = %s\t\t&quot;</span>, argv[optind]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;option_index = %d\n&quot;</span>, opt_idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令及输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main2 main2.cpp</span><br><span class="line">./main2 --reqarg 100 --optarg=200 --noarg</span><br><span class="line">opt = roptarg = 100optind = 3argv[optind] = --optarg=200option_index = 0</span><br><span class="line">opt = ooptarg = 200optind = 4argv[optind] = --noargoption_index = 1</span><br><span class="line">opt = noptarg = (null)optind = 5argv[optind] = (null)option_index = 2</span><br></pre></td></tr></table></figure><p><code>getopt_long</code>问题分析：到处都是问题。</p><h1 id="实现命令行参数解析">实现命令行参数解析</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree -A</span></span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── utility</span><br><span class="line">    ├── option.cpp</span><br><span class="line">    └── option.h</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">option</span> CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 GLOB_RECURSE 递归地查找所有匹配 &quot;utility/*.cpp&quot; 模式的文件</span></span><br><span class="line"><span class="comment"># 将找到的文件列表存储在 SOURCES 变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES <span class="string">&quot;utility/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SOURCES&#125;</span> main.cpp)</span><br><span class="line"><span class="comment"># 将当前目录 (./) 添加到头文件搜索路径中</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE .)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/option.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件仅会被引入一次</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶级命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> zh</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 二级命名空间</span></span><br><span class="line">    <span class="keyword">namespace</span> utility</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// Option类专门负责命令行参数解析，支持解析短参数和长参数</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Option</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">// 定义参数类型</span></span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">            &#123;</span><br><span class="line">                OPT_UNKNOWN = <span class="number">0</span>,        <span class="comment">// 未知类型</span></span><br><span class="line">                OPT_NO,                 <span class="comment">// 无参数</span></span><br><span class="line">                OPT_REQUIRED,           <span class="comment">// 必带参数</span></span><br><span class="line">                OPT_OPTIONAL            <span class="comment">// 可选参数</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Option</span>() = <span class="keyword">default</span>;</span><br><span class="line">            ~<span class="built_in">Option</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> string&amp; opt, Type type)</span></span>;     <span class="comment">// 定义参数名称和参数类型</span></span><br><span class="line">            <span class="function">Type <span class="title">type</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span>;         <span class="comment">// 获取某个参数的类型</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>;         <span class="comment">// 命令行参数解析，argc和argv都是main函数带入的</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">has</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span>;          <span class="comment">// 命令行中有无该参数</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">get_bool</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span>;     <span class="comment">// 有没有出现这个无参的参数</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span>;</span><br><span class="line">            <span class="function">string <span class="title">get_string</span><span class="params">(<span class="type">const</span> string&amp; opt)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            std::map&lt;string, Type&gt; m_opts;          <span class="comment">// 保存参数名称和其参数类型关系</span></span><br><span class="line">            std::map&lt;string, string&gt; m_args;        <span class="comment">// 保存参数名称和其参数值</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility/option.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/option.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Option::add</span><span class="params">(<span class="type">const</span> string&amp; opt, Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_opts[opt] = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Option::Type <span class="title">Option::type</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_opts.<span class="built_in">find</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (it == m_opts.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OPT_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Option::parse</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 命令行中第0个元素是可执行文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string arg = argv[i];</span><br><span class="line">        <span class="keyword">if</span> (arg.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) != <span class="string">&quot;-&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果不是选项参数而是普通参数，则直接忽略</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arg.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>) == <span class="string">&quot;--&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 长参数解析</span></span><br><span class="line">            string str = arg.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> pos = str.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos != std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出现等号，表明参数可能是必选参数，也可能是可选参数</span></span><br><span class="line">                <span class="comment">// 提取出参数名称和参数值</span></span><br><span class="line">                string opt = str.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">                string val = str.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">type</span>(opt))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> OPT_NO:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 长参数中出现等号，但参数类型是无参数，不匹配</span></span><br><span class="line">                        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;no argument option: &quot;</span> + opt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> OPT_OPTIONAL:</span><br><span class="line">                    <span class="keyword">case</span> OPT_REQUIRED:</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_args[opt] = val;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 没有出现等号</span></span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">type</span>(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> OPT_NO:</span><br><span class="line">                    <span class="keyword">case</span> OPT_OPTIONAL:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 长参数如果是可选参数，如果有值则必须有等号，中间不可能有空格隔开</span></span><br><span class="line">                        m_args[str] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> OPT_REQUIRED:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 长参数如果是必选参数，则其后面会跟上参数值，先检查一下避免越界</span></span><br><span class="line">                        <span class="keyword">if</span> (i + <span class="number">1</span> &gt; argc)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;option required argument: &quot;</span> + str);</span><br><span class="line">                        &#125;</span><br><span class="line">                        string val = argv[i + <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (val.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 如果表示参数值的字符串中出现&#x27;-&#x27;，则说明其为另一个参数的名称，逻辑出错</span></span><br><span class="line">                            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;option missing argument: &quot;</span> + str);</span><br><span class="line">                        &#125;</span><br><span class="line">                        m_args[str] = val;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 短参数解析</span></span><br><span class="line">            <span class="comment">// 将短参数提取出来</span></span><br><span class="line">            string opt = arg.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">type</span>(opt))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> OPT_NO:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arg.<span class="built_in">length</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="comment">// 出现多个短参数合并(-ab)</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; arg.<span class="built_in">length</span>(); k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="function">string <span class="title">o</span><span class="params">(<span class="number">1</span>, arg[k])</span></span>;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">type</span>(o) != OPT_NO)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            m_args[o] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> OPT_OPTIONAL:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果长度大于2则该短参数可选参数值是带有值的(-cjack)，长度等于2则该短参数是不带参数值的</span></span><br><span class="line">                    <span class="keyword">if</span> (arg.<span class="built_in">length</span>() &gt; <span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_args[opt] = arg.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        m_args[opt] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> OPT_REQUIRED:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 先检查下一个参数是否会数组越界</span></span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= argc)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;option required argument: &quot;</span> + opt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    string val = argv[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (val.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;option missing argument: &quot;</span> + opt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    m_args[opt] = val;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Option::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : m_args)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Option::has</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_opts.<span class="built_in">find</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (it == m_opts.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_args.<span class="built_in">find</span>(opt) != m_args.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Option::get_bool</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_args.<span class="built_in">find</span>(opt) != m_args.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Option::get_int</span><span class="params">(<span class="type">const</span> string&amp; opt)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_args.<span class="built_in">find</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (it == m_args.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; it-&gt;second;</span><br><span class="line">    ss &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Option::get_string</span><span class="params">(<span class="type">const</span> string&amp; opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_args.<span class="built_in">find</span>(opt);</span><br><span class="line">    <span class="keyword">if</span> (it == m_args.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility/option.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zh::utility;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Option opt;</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;a&quot;</span>, Option::OPT_NO);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;b&quot;</span>, Option::OPT_REQUIRED);</span><br><span class="line">    opt.<span class="built_in">add</span>(<span class="string">&quot;c&quot;</span>, Option::OPT_OPTIONAL);</span><br><span class="line"></span><br><span class="line">    opt.<span class="built_in">parse</span>(argc, argv);</span><br><span class="line">    opt.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> a = opt.<span class="built_in">get_bool</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b = opt.<span class="built_in">get_int</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    string c = opt.<span class="built_in">get_string</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./build/main -a -b 123 -cjack</span></span><br><span class="line">a:</span><br><span class="line">b:123</span><br><span class="line">c:jack</span><br><span class="line">a = 1, b = 123, c = jack</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 3 资源管理</title>
      <link href="/2023/03/13/Effective-C-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/13/Effective-C-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>C++程序中最常使用的资源就是动态内存（如果分配内存却从来不曾归还它，会导致内存泄露），但内存只是程序员必须管理的众多资源之一。其它常见的资源还包括文件描述符、互斥锁、图形界面中的字型和笔刷、数据库连接以及网络套接字<code>socket</code>。不论哪一种资源，重要的是当你不再使用它时，必须将它归还系统。</p><h2 id="条款13：以对象管理资源">条款13：以对象管理资源</h2><p>以对象管理资源的两个关键点：</p><ol><li><p>获得资源后立刻放进管理对象内</p><p>“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”(<em>Resource Acquisition Is Initialization, RAII</em>)，因为程序员几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象。有时获得的资源被拿来赋值（而非初始化）某个管理对象，但不论哪一种做法，每一笔资源都在获得的同时立刻被放进管理对象中。</p></li><li><p>管理对象运用析构函数确保资源被释放</p><p>不论控制流如何离开区块，一旦对象被销毁（例如当对象离开作用域）其析构函数自然会被自动调用，于是资源被释放。</p></li></ol><p>一句话概括就是：为防止资源泄露，请使用<em>RAII</em>对象，它们在构造函数中获得资源并在析构函数中释放资源。</p><h2 id="条款14：在资源管理类中小心拷贝行为">条款14：在资源管理类中小心拷贝行为</h2><p>当一个<em>RAII</em>对象被复制时，程序员一般有两种策略可供选择：</p><ol><li><p><strong>禁止复制</strong></p><p>许多时候允许<em>RAII</em>对象被复制并不合理，如果复制动作对<em>RAII</em>类并不合理，程序员便应该禁止它。将拷贝操作声明为<code>private</code>但故意不实现它，或者将拷贝操作声明为<code>=delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> UnCopyable&#123;<span class="comment">// 禁止复制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对底层资源使用引用计数法</strong></p><p>有时程序员希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制<em>RAII</em>对象时，应将该资源的“被引用数”递增。</p></li></ol><h2 id="条款15：在资源管理类中提供对原始资源的访问">条款15：在资源管理类中提供对原始资源的访问</h2><p>APIs往往要求访问原始资源，所以每一个RAII类应该提供一个“取得其所管理之资源”的方法。对原始资源的访问可能经由显示转换<code>get()</code>或隐式转换（类型转换运算符），一般而言显示转换比较安全，但隐式转换对客户比较方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> f;&#125;<span class="comment">// 显示转换函数</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">// 隐式转换函数</span></span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款16：成对使用new和delete时要采用相同形式">条款16：成对使用new和delete时要采用相同形式</h2><p>当程序员使用<code>new</code>，也就是通过<code>new</code>动态生成一个对象时，有两件事发生：第一，内存被分配出来（通过<code>operator new</code>函数）；第二，针对此内存会有一个或多个构造函数被调用。</p><p>当使用<code>delete</code>时，也有两件事发生：针对此内存会有一个或更多析构函数被调用，然后内存才被释放（通过<code>operator delete</code>函数）。<code>delete</code>的最大问题在于：即将被删除的内存之内究竟有多少个对象？这个问题的答案决定了有多少个析构函数必须被调用起来。</p><p>这个问题的本质在于：即将被删除的那个指针，所指的是单一对象或对象数组？单一对象的内存布局一般而言不同于数组的内存布局，因为数组所用的内存通常还包括“数组大小”的记录，以便<code>delete</code>知道需要调用多少次析构函数；而单一对象的内存则没有这笔记录。</p><p>当程序员对着一个指针使用<code>delete</code>，唯一能让<code>delete</code>知道内存中是否存在一个“数组大小记录”的办法就是由程序员告诉它。如果使用<code>delete</code>时加上方括号，<code>delete</code>便认定指针指向一个数组，否则它便认定指针指向单一对象。</p><p>因此：如果在<code>new</code>表达式中使用<code>[]</code>，必须在相应的<code>delete</code>表达式中也使用<code>[]</code>。如果在<code>new</code>表达式中不使用<code>[]</code>，一定不要在相应的<code>delete</code>表达式中使用<code>[]</code>。</p><h2 id="条款17：以独立语句将newed对象置入智能指针">条款17：以独立语句将newed对象置入智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>编译器产出一个<code>processWidget</code>调用码之前，必须首先核算即将被传递的实参。上述第二实参只是单纯地对<code>priority</code>函数的调用，但第一实参<code>std::shared_ptr&lt;Widget&gt;(new Widget)</code>由两部分组成：</p><ol><li>执行<code>new Widget</code>表达式</li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>于是在调用<code>processWidget</code>之前，编译器必须创建代码来做以下三件事：</p><ol><li>调用<code>priority</code></li><li>执行<code>new Widget</code></li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>但是C++编译器可以以非常弹性的次序完成这些事情，可以确定是<code>new Widget</code>一定执行于<code>std::shared_ptr</code>构造函数调用之前，因为这个表达式的结果还要被传递作为<code>std::shared_ptr</code>构造函数的一个实参，但对<code>priority</code>的调用可以排在第一或第二或第三执行。如果编译器因为生成了更高效的代码而以第二顺位执行它，最终获得这样的操作序列：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority</code></li><li>调用<code>std::shared_ptr</code>构造函数</li></ol><p>此时，一旦对<code>priority</code>的调用发生异常，那么<code>new Widget</code>返回的指针将会遗失，因为它还尚未被置入<code>std::shared_ptr</code>内！即在对<code>processWidget</code>的调用过程中可能引发资源泄露，因为在“资源创建（<code>new Widget</code>）”和“资源被转换为资源管理对象”两个时间点之间可能发生异常干扰。</p><p>由于编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度），避免这类问题的方法很简单：使用分离语句分别写出1.创建<code>Widget</code>；2.将它置入一个智能指针内，然后再把那个智能指针传给<code>processWidget</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><p>在上述修订后的代码内，“<code>new Widget</code>”表达式以及“对<code>std::shared_ptr</code>构造函数的调用”这两个动作，和“对<code>priority</code>的调用”是分隔开的，位于不同语句内，所以编译器不得在它们之间任意选择执行次序。</p><p>因此，以独立语句将<code>newed</code>对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 2.构造、析构和赋值运算</title>
      <link href="/2023/03/07/Effective-C-2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
      <url>/2023/03/07/Effective-C-2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="条款05：-了解c-默默编写并调用哪些函数">条款05： 了解C++默默编写并调用哪些函数</h2><p>如果程序员没有声明，编译器就会为它声明（编译器版本的）一个拷贝构造函数、一个拷贝赋值运算符和一个析构函数。此外，如果没有声明任何构造函数，编译器也会为你声明一个默认构造函数。所有这些函数都是<code>public</code>且<code>inline</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此，如果写下:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就好像你写下这样的代码:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>()&#123;...&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Empty</span>()&#123;...&#125;<span class="comment">// 析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>惟有当这些函数被需要（被调用），它们才会被编译器创建出来。</p><p>需要特别注意：编译器产出的析构函数是非<code>virtual</code>的，除非这个类的基类自身声明有<code>virtual</code>析构函数！</p><p>至于拷贝构造函数和拷贝赋值运算符，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。</p><p>如果打算在一个内含引用成员的类内支持赋值操作，那必须自己定义拷贝赋值运算符；面对内含<code>const</code>成员的类，编译器会拒绝编译那一行赋值动作，因为更改<code>const</code>成员是不合法的；如果某个基类将拷贝赋值运算符声明为<code>private</code>，那么编译器将拒绝为其派生类生成一个拷贝赋值运算符。</p><h2 id="条款06：若不想使用编译器自动生成的函数-就该明确拒绝">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>在C++ 11标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为<code>=delete</code>来阻止拷贝。删除的函数就是虽然程序员声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上<code>=delete</code>来指出希望将它定义为删除的。</p><p>为了阻止拷贝构造函数和拷贝赋值运算符被编译器自动生成，得程序员自行声明它们，可以将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>，这样阻止人们调用它。**Tips：**可以将成员函数声明为<code>private</code>而且故意不实现它们。</p><p>也可以设计一个专门阻止拷贝动作的基类，基类中将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;<span class="comment">// 允许派生类对象构造和析构</span></span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);<span class="comment">// 声明为private但故意不实现就是为了阻止拷贝 </span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了阻止HomeForSale对象被拷贝，唯一需要做的就是继承Uncopyable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款07：为多态基类声明virtual析构函数">条款07：为多态基类声明virtual析构函数</h2><p>C++明白指出，当派生类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，其结果未有定义——实际执行时通常发生的是对象的派生类成分没被销毁，即派生类的析构函数未能执行起来导致派生类成员很可能没被销毁，然后其基类成分通常会被销毁，于是造成一个诡异的“局部销毁”对象，造成内存泄露。</p><p>消除该问题的做法是：给基类一个虚析构函数，此后删除派生类对象就会正常，它会销毁整个对象，包括派生类成分。</p><p>虚表指针<em>vptr</em>指向一个由函数指针构成的数组，称为虚函数表<em>vtbl</em>：每一个带有虚函数的类都有一个相应的虚函数表。当对象调用某一虚函数时，实际被调用的函数取决于该对象的虚表指针所指的那个虚表——编译器在其中寻找适当的函数指针。</p><p>无端地将所有类的析构函数声明为<code>virtual</code>，就像从未声明它们为<code>virtual</code>一样，都是错误的。最佳工程实践是：只有当类内含至少一个虚函数，程序员才为它声明虚析构函数。</p><p>析构函数的运作方式是，最深层派生的那个类其析构函数最先被调用，然后是其每一个基类的析构函数被调用。</p><h2 id="条款08：别让异常逃离析构函数">条款08：别让异常逃离析构函数</h2><p>只要析构函数吐出异常，即使并非使用容器或<code>arrays</code>，程序也可能过早结束或出现不明确行为。C++不喜欢析构函数吐出异常！</p><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作。</p><h2 id="条款09：绝不在构造和析构过程中调用虚函数">条款09：绝不在构造和析构过程中调用虚函数</h2><p>基类构造期间虚函数绝不会下降到派生类阶层，取而代之的是，对象的行为就像隶属于基类类型一样。即在基类构造期间，虚函数不是虚函数。因此程序员应确定类的构造函数和析构函数都没有（在对象被创建和被销毁期间）调用虚函数，而它们中调用的所有函数也都服从同一约束。</p><h2 id="条款10：令operator-返回一个-this的引用">条款10：令<code>operator=</code>返回一个<code>*this</code>的引用</h2><p>为了实现“连锁赋值”，所有赋值相关的操作符必须返回一个引用指向操作符的左侧实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款11：在operator-中处理-自我赋值">条款11：在<code>operator=</code>中处理“自我赋值”</h2><p>“自我赋值”发生在对象被赋值给自己时，虽然这看起来有点愚蠢，但它合法，而且潜在的自我赋值可能不容易被一眼辨识出来。</p><p>一般而言如果某段代码操作指针或引用而它们被用来“指向多个相同类型的对象”，就需考虑这些对象是否为同一个！</p><p>为了阻止“自我赋值”的不安全性错误，传统做法是在<code>operator=</code>最前面安插一个“证同测试”来检验是否“自我赋值”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bimap* bp;<span class="comment">// 指向一个从堆分配而得的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="comment">// 如果是自我赋值，就不做任何事</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12：复制对象时勿忘其每一个成分">条款12：复制对象时勿忘其每一个成分</h2><p>当程序员编写一个拷贝函数时，要确保复制所有局部成员变量，并调用基类中合适的拷贝函数来复制所有基类成分！</p><p>不要尝试以某个拷贝函数实现另一个拷贝函数，应将相同部分放进第三个函数中，并由两个拷贝函数 共同调用。比如发现拷贝构造函数和拷贝赋值运算符有相近的代码，消除重复代码的做法是建立一个新的成员函数给两者调用。这样的函数往往是<code>private</code>而且常被命名为<code>init</code>。这个策略可以安全消除拷贝构造函数和拷贝赋值运算符之间的代码重复问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 1.让自己习惯C++</title>
      <link href="/2023/03/01/Effective-C-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/"/>
      <url>/2023/03/01/Effective-C-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/</url>
      
        <content type="html"><![CDATA[<h2 id="条款01：视c-为一个语言联邦">条款01：视C++为一个语言联邦</h2><p>将C++视为一个由相关语言组成的联邦而非单一语言，在其某个次语言中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然后当从一个次语言移往另一个次语言时，守则可能改变，C++总共有4个次语言：C语言；C++面向对象；C++模板；标准模板库STL。</p><p>因此，C++并不是一个带有一组守则的一体语言，它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言就会发现C++容易了解得多。</p><h2 id="条款02：尽量以const-enum-inline替换-define">条款02：尽量以const, enum, inline替换#define</h2><ul><li>对于单纯常量，最好以<code>const</code>对象或<code>enums</code>替换<code>#defines</code></li><li>对于形似函数的宏，最好改用<code>template inline</code>函数替换<code>#defines</code></li></ul><h2 id="条款03：尽可能使用const">条款03：尽可能使用const</h2><p>注意：如果被指物是常量，程序员可将关键字<code>const</code>写在类型之前或者类型之后星号之前，两种写法意义相同，所以下列两个函数接受的参数类型是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;<span class="comment">// f1获得一个指针，指向一个常量的(不变的)Widget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>;<span class="comment">// f2也是</span></span><br></pre></td></tr></table></figure><p>两种形式都有人用，应该试着习惯它们。</p><p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。例如将<code>operator*</code>重载函数的返回值声明为<code>const</code>可以预防“没意思的赋值动作”。</p><h3 id="const成员函数">const成员函数</h3><p><code>const</code>作用于成员函数可以使得<code>class</code>接口比较容易理解，因为这样可以得知哪个函数可以改动对象内容而哪个函数不行；它还使“操作<code>const</code>”对象成为可能。改善C++程序效率的一个根本办法是以<em>pass by reference-to-const</em>方式传递对象，此技术的前提是有<code>const</code>成员函数可用来处理取得（并经修饰而成）的<code>const</code>对象。</p><p>注意：两个成员函数如果只是常量性不同（即一个带<code>const</code>而另一个不带），可以被重载。</p><p>真实程序中<code>const</code>对象大多用于<code>passed by pointer-to-const</code>或<code>passed by reference-to-const</code>的传递结果</p><p>当程序员希望能修改类的某个数据成员，即使是在一个<code>const</code>成员函数内，可以通过在成员变量的声明中加入<code>mutable</code>关键字来做到这一点！借助<code>mutable</code>可以释放掉非静态成员变量的<code>bitwise constness</code>约束。</p><h3 id="在const和non-const成员函数中避免重复">在const和non-const成员函数中避免重复</h3><p>为了避免<code>const</code>和<code>non-const operator[]</code>产生代码重复以及伴随的编译时间、维护、代码膨胀等，应该实现<code>operator[]</code>的功能一次并使用它两次。即必须令其中一个<code>non-const operator[]</code>调用另一个<code>const</code>兄弟，这就是<strong>常量性转除</strong>。</p><p>换而言之，当<code>const</code>和非<code>const</code>成员函数有着实质等价的实现时，令非<code>const</code>版本调用<code>const</code>版本可以避免代码重复：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>&#123;<span class="comment">// 一如既往</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)&#123;</span><br><span class="line">        <span class="comment">// 先为*this加上const以调用const op[]，再将const op[]返回值的const转除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面示例代码共有两次转型：第一次用来为<code>*this</code>添加<code>const</code>，这使得接下来调用<code>operator[]</code>时得以调用<code>const</code>版本；第二次则是从<code>const operator[]</code>的返回值中移除<code>const</code>。</p><p>注意：<code>const</code>成员函数调用非<code>const</code>成员函数是一种错误行为，因为对象会因此有可能被改动！</p><h2 id="条款04：确定对象被使用前已先被初始化">条款04：确定对象被使用前已先被初始化</h2><p>读取未初始化的值会导致不明确的行为。因此，永远在使用对象之前先将它初始化。</p><p>要为内置类型对象进行手工初始化，因为C++不保证初始化它们。至于内置类型以外的任何其它东西，初始化责任落在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p><p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，即尽量在初始化列表替换赋值动作，这样通常效率更高。因为对大多数类型而言，比起先调用默认构造函数然后再调用拷贝赋值运算符，单只调用一次拷贝构造函数是比较高效的，有时甚至高效得多。初始化列表中列出的成员变量的排列次序应该和它们在<code>class</code>中声明的次序相同。并且，如果成员变量是<code>const</code>或<code>references</code>，它们就一定需要初值，不能被赋值。</p><p>C++有着十分固定的“成员初始化次序”：基类更早于其派生类被初始化，而类的成员变量总是以其声明次序被初始化，即使它们在初始化列表中以不同的次序出现也不会有任何影响。</p><p>为免除“跨编译单元之初始化次序”问题，请以<code>local static</code>对象替换<code>non-local static</code>对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 导读</title>
      <link href="/2022/12/26/Effective-C-%E5%AF%BC%E8%AF%BB/"/>
      <url>/2022/12/26/Effective-C-%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="术语-terminology">术语(Terminology)</h2><p>​所谓声明式(<em>declaration</em>)是告诉编译器某个东西的名称和类型，但略去细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;<span class="comment">// 对象声明式</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">numDigits</span><span class="params">(<span class="type">int</span> number)</span></span>;<span class="comment">// 函数声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;<span class="comment">// 类声明式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// 模板声明式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span>;<span class="comment">// &quot;typename&quot;的使用见条款42</span></span><br></pre></td></tr></table></figure><p>​<code>size_t</code>只是一个<code>typedef</code>，是C++计算个数（例如<code>char*-based</code>字符串内的字符个数或STL容器内的元素个数等等）时用的某种不带正负号（<code>unsigned</code>）类型。它也是<code>vector</code>，<code>deque</code>和<code>string</code>内的<code>operator[]</code>函数接受的参数类型。条款3阐述当我们定义自己的<code>operator[]</code>函数时应该遵循的协议。</p><hr><p>​每个函数的声明揭示其签名式(<em>signature</em>)，也就是参数和返回类型。一个函数的签名等同于该函数的类型。</p><p>​定义式(<em>definition</em>)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此对象拨发内存的地点。对于函数或函数模板而言，定义式提供了代码本体。对于类或类模板而言，定义式列出它们的成员。</p><p>​初始化(<em>initialization</em>)是“给予对象初值”的过程。对用户自定义类型的对象而言，初始化由构造函数执行。所谓默认构造函数是一个可被调用而不带任何实参者。这样的构造函数要不没有参数，要不就是每个参数都有缺省值。</p><p>​当类的构造函数被声明为<code>explicit</code>时，这可阻止它们被用来执行隐式类型转换，但它们仍可被用来进行显式类型转换。被声明为<code>explicit</code>的构造函数通常比其<code>non-explicit</code>版本更受欢迎，因为它禁止编译器执行非预期（往往也不被期望）的类型转换。除非有一个好理由允许构造函数被用于隐式类型转换，否则一般将它声明为<code>explicit</code>。</p><p>​拷贝构造函数被用来“以同型对象初始化自我对象”，拷贝赋值运算符被用来“从另一个同型对象中拷贝其值到自我对象”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1;<span class="comment">// 调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">w1 = w2;<span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：当看到赋值符号时请小心，因为<code>=</code>语法也可用来调用拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3 = w2;<span class="comment">// 调用拷贝构造函数！</span></span><br></pre></td></tr></table></figure><p>​拷贝构造很容易和拷贝赋值有所区别：如果一个新对象被定义（例如以上语句中的<code>w3</code>），一定会有个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的<code>w1 = w2</code>语句），就不会有构造函数被调用，那么当然就是赋值操作被调用。</p><p>​拷贝构造函数是一个尤其重要的函数，因为它定义一个对象如何以值传递(<em>passed by value</em>)。以值传递意味着“调用拷贝构造函数”。<strong>注意</strong>：以值传递用户自定义类型通常是个坏主意，以引用传递(<em>passed-by-reference-to-const</em>)往往是比较好的选择，详见条款20。</p><hr><p>​<strong>不明确行为</strong>(<em>undefined behavior</em>)：由于各种因素，某些C++构件的行为没有定义，程序员无法稳定预估运行期会发生什么事。下面两个代码片段就带有“不明确的行为”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="number">0</span>;<span class="comment">// p是个null指针</span></span><br><span class="line">std::cout &lt;&lt; *p;<span class="comment">// 对一个null指针取值会导致不明确行为</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[] = <span class="string">&quot;Darla&quot;</span>;<span class="comment">// name是个数组，大小为6(别忘记最尾端的null)</span></span><br><span class="line"><span class="type">char</span> c = name[<span class="number">10</span>];<span class="comment">// 指针涉及一个无效的数组索引，这将导致不明确行为</span></span><br></pre></td></tr></table></figure><p>​不明确（未定义）行为的结果是不可预期的，很可能让人不愉快！程序会有时执行正常，有时会造成崩坏，有时更产出不正确的结果。应尽量避免不明确行为！</p><p>​程序批注中提到构造函数和析构函数时，有时会使用缩写<em>ctor</em>和<em>dtor</em>。</p><h2 id="命名习惯-naming-conventions">命名习惯(Naming Conventions)</h2><p>​参数<code>lhs</code>和<code>rhs</code>它们分别代表左手端和右手端，常常以它们作为二元操作符函数如<code>operator==</code>和<code>operator*</code>的参数名称。对于成员函数，左侧实参由<code>this</code>指针表现出来，所以有时单独使用参数名称<code>rhs</code>。</p><p>​常将“指向一个<code>T</code>型对象”的指针命名为<code>pt</code>，意思是“pointer to <code>T</code>”。</p><p>​对于引用使用类似习惯：<code>rw</code>可能是个<code>Widget</code>类型的引用，<code>ra</code>则是个<code>Airplane</code>类型的引用。</p><h2 id="关于线程-threading-consideration">关于线程(Threading Consideration)</h2><p>​<strong>线程安全性</strong>(<em>thread safety</em>)是许多程序员要面对的主题！</p><h2 id="tr1和boost">TR1和Boost</h2><p>​TR1(“Technical Report 1”)是一份规范，描述加入C++标准程序库的诸多新机能。这些机能以新的class templates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有的TR1组件都被置于命名空间tr1内，后者嵌套于命名空间std内。</p><p>​Boost是个组织，亦是一个网站(<a href="http://boost.org">http://boost.org</a>)，提供可移植、同行复审、源码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言，Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何得了解它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础教程</title>
      <link href="/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/13/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="git基本概念">git基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本</li></ul><h2 id="git常用命令">git常用命令</h2><ol><li><p><code>git config --global user.name zhanghua</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p></li><li><p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中，其中<code>HEAD</code>头指针指向<code>master</code>分支的一个节点</p></li><li><p><code>git add XX</code>：将XX文件添加到暂存区</p><p><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</p></li><li><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</p></li><li><p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将暂存区的内容提交到当前分支，并将<code>HEAD</code>指针指向该分支最新版本，注意每次<code>commit</code>后暂存区会清空</p></li><li><p><code>git status</code>：查看仓库状态</p></li><li><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p></li><li><p><code>git log</code>：查看当前分支的所有版本（截止到<code>HEAD</code>指针指向的版本）</p><p><code>git log --pretty=oneline</code>：更简洁地查看当前分支的所有版本</p></li><li><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p></li><li><p><code>git reset --hard HEAD^</code> 或<code> git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p><p><code>git reset --hard 版本号</code>：回滚到某一特定版本（使用版本号的前7个字母即可）</p></li><li><p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销（注意：<code>git restore</code>并不是恢复至上一个历史版本，而是恢复至暂存区里存的内容）</p><p><code>git restore --staged XX</code>：将XX文件从暂存区中删除</p></li><li><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p></li><li><p><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p></li><li><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</p></li><li><p><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</p><p>注意：暂存区跟分支完全独立，切换分支是不会有多个暂存区的。因此不管在哪个分支上用的都是一个暂存区和工作目录</p></li><li><p><code>git branch</code>：查看所有分支和当前所处分支</p></li><li><p><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</p></li><li><p><code>git merge branch_name</code>：将分支<code>branch_name</code>快速合并到当前分支上</p></li><li><p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p></li><li><p><code>git branch branch_name</code>：创建新分支</p></li><li><p><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</p></li><li><p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><p><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</p></li><li><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</p></li><li><p><code>git checkout -t origin/branch_name</code> 将远程的<code>branch_name</code>分支拉取到本地</p></li><li><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p></li><li><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p></li><li><p><code>git stash drop</code>：删除栈顶存储的修改</p></li><li><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p></li><li><p><code>git stash list</code>：查看栈中所有元素</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-213 Data Lab</title>
      <link href="/2022/08/26/CMU15-213-Data-Lab/"/>
      <url>/2022/08/26/CMU15-213-Data-Lab/</url>
      
        <content type="html"><![CDATA[<p>Lab开始前需仔细阅读<code>bits.c</code>注释中的<code>INTEGER CODING RULES</code>内容和<code>FLOATING POINT CODING RULES</code>内容！</p><h1 id="the-puzzles">The Puzzles</h1><h2 id="bitxor">bitXor</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * bitXor - x^y using only ~ and &amp; </span><br><span class="line"> *   Example: bitXor(4, 5) = 1</span><br><span class="line"> *   Legal ops: ~ &amp;</span><br><span class="line"> *   Max ops: 14</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先介绍<strong>德摩根定律</strong>，德摩根定律在离散数学的很多场景里都出现过，它一共有两个关系：</p><ul><li><p>在命题逻辑里，可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∨</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\lor Q) \Leftrightarrow (\lnot P) \wedge (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>P</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>Q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot(P\wedge Q) \Leftrightarrow (\lnot P) \lor (\lnot Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>在集合里可以这样表示：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋃</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋂</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcup B} = \overline{A} \bigcap \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⋂</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>⋃</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A \bigcap B} = \overline{A} \bigcup \overline{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8000100000000003em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2500000000000004em;"><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-4.220000000000001em;"><span class="pstrut" style="height:3.05em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.55001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><ul><li><p>在布尔代数里可以这样表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x \cdot y} = \overline{x} + \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.71389em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x + y} = \overline{x} \cdot \overline{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9777700000000003em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7833300000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.7033300000000002em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></span></p></li></ul><p>因此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊕</mo><mi>y</mi><mo>=</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi><mo>+</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><mo>⋅</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">x \oplus y = \overline{x} \cdot y + x \cdot \overline{y} = \overline{\overline{\overline{x} \cdot y} \cdot \overline{x \cdot \overline{y}}} = \overline{(x + \overline{y}) \cdot (\overline{x} + y)} = \overline{x \cdot y + \overline{x} \cdot \overline{y}} = \overline{x \cdot y} \cdot \overline{\overline{x} \cdot \overline{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63056em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.225em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.9505600000000003em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9500000000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-3.87em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388899999999999em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64445em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.56445em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0250000000000001em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8305600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-3.75056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin">tmin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 4</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>将最高有效位（即符号位）置为1且其余位置为0时为补码表示下的最小整数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="istmax">isTmax</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="line"> *     and 0 otherwise </span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="line"> *   Max ops: 10</span><br><span class="line"> *   Rating: 1</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的符号位为0且其余位全为1时为补码表示的最大值，此时观察可以发现对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>加1并取反等于自己。但同时需要注意-1（补码表示为全1）加1取反后也等于自己，这种情况需要排除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alloddbits">allOddBits</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>先做一个32位的掩码<code>t32</code>，并使其每个字节均为<code>0xAA</code>，即所有奇数位bit均为1。然后先通过<code>x &amp; t32</code>取出<code>x</code>的所有奇数bit位，然后与<code>t32</code>进行异或来判断取出来的结果是否等同<code>t32</code>，等同则说明<code>x</code>的所有奇数位bit均为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t8 = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">int</span> t16 = (t8 &lt;&lt; <span class="number">8</span>) | t8;</span><br><span class="line">    <span class="type">int</span> t32 = (t16 &lt;&lt; <span class="number">16</span>) | t16;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; t32) ^ t32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate">negate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="line"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="line"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>在C语言中，对于任意整数值<code>x</code>，计算表达式<code>-x</code>和<code>~x+1</code>得到的结果完全一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isasciidigit">isAsciiDigit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="line"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="line"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="line"> *            isAsciiDigit(0x05) = 0.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 15</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>首先<code>0x30</code>的二进制表示为<code>0b11 0000</code>，<code>0x39</code>的二进制表示为<code>0b11 1001 </code>。</p><p>用<code>cond1</code>判断<code>x</code>的高28位是否为<code>0x0000003</code>，同时也排除掉负数情况；再用<code>cond2</code>判断将<code>x</code>加6（<code>0b0110</code>）之后第5位bit是否会因为进位由1变为0，即判断<code>x</code>的最低4位是否小于等于<code>0b1001</code>。当且仅当<code>cond1</code>和<code>cond2</code>均为1时<code>isAsciiDigit</code>返回1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0x3</span>);</span><br><span class="line">    <span class="type">int</span> cond2 = ((x + <span class="number">0x6</span>) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 &amp; cond2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="conditional">conditional</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * conditional - same as x ? y : z </span><br><span class="line"> *   Example: conditional(2,4,5) = 4</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 16</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>可以想到<code>y + z + a + b</code>的形式，当<code>x</code>为真时让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">b=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>；当<code>x</code>为假时，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">a=-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。由于不用<code>-</code>负号，因此可以用<code>~y + 1</code>代替<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，剩下的问题在于如何根据<code>x</code>的真假（即最低bit位为0或1）将所有bit位置为全1或全0。第一种方法是借助算术右移的机制，此时需要先将最低bit位左移至最高符号位，但是这种方式的移位数取决于整型类型具体有多少bit位，不具有普适性。另一种方法则更巧妙，<code>!x</code>的值只有0或1两种取值，再对它取负（即按位取反再加1）后就得到0和-1，而0和-1的补码表示不正是全0和全1嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mask1 = (!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> mask2 = (!!x &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">int</span> a = (~y + <span class="number">1</span>) &amp; mask1;</span><br><span class="line">    <span class="type">int</span> b = (~z + <span class="number">1</span>) &amp; mask2;</span><br><span class="line">    <span class="keyword">return</span> y + z + a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = (~y + <span class="number">1</span>) &amp; b;</span><br><span class="line">    <span class="type">int</span> d = (~z + <span class="number">1</span>) &amp; ~b;</span><br><span class="line">    <span class="keyword">return</span>  y + z + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于允许使用<code>|</code>位或运算操作，因此还有简洁的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = !x;</span><br><span class="line">    <span class="type">int</span> b = ~a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>  (y &amp; ~b) | (z &amp; b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="islessorequal">isLessOrEqual</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="line"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 24</span><br><span class="line"> *   Rating: 3</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ol><li>首先判断<code>x</code>与<code>y</code>是否相等，它们若相等则可以直接返回1，若<code>x</code>与<code>y</code>不等，则分别取<code>x</code>和<code>y</code>的符号位<code>signX</code>和<code>signY</code>；</li><li>若<code>x</code>正且<code>y</code>负，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定不成立，因此返回0；</li><li>若<code>x</code>负且<code>y</code>正，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>一定成立，因此返回1；</li><li>若<code>x</code>与<code>y</code>同号，则当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>结果为负（符号位为1）时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>成立。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cond1 = !(x ^ y);       <span class="comment">// x == y</span></span><br><span class="line">    <span class="type">int</span> signX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> signY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cond2 = (!signX) &amp; signY;       <span class="comment">// x正y负</span></span><br><span class="line">    <span class="type">int</span> cond3 = (signX) &amp; (!signY);     <span class="comment">// x负y正</span></span><br><span class="line">    <span class="type">int</span> res = x + (~y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;       <span class="comment">// x与y同号</span></span><br><span class="line">    <span class="type">int</span> flag = res &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> cond1 | (!cond2 &amp; (cond3 | flag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalneg">logicalNeg</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * logicalNeg - implement the ! operator, using all of </span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4 </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>不等于<code>0</code>的数字有正负的区别，若<code>x</code>不为0时，则<code>x</code>与<code>-x</code>的符号位必然异号；当<code>x</code>为0时，<code>x</code>与<code>-x</code>的符号位均为0。因此可将<code>x</code>与<code>-x</code>进行与运算，若<code>x</code>不为0，则结果的符号位为1，否则为0，再通过算术右移31位可得到全1或全0。最后再对结果加<code>1</code>正好可将全1的二进制表示转为<code>0b0</code>，将全0的二进制表示转为<code>0b1</code>，非常巧妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> negX = ~x +<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sign = (x | negX) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> sign + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howmanybits">howManyBits</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> CMU15-213 Introduction to Computer Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-213 </tag>
            
            <tag> Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2300 咒语和药水的成功对数</title>
      <link href="/2022/07/26/Leetcode-2300/"/>
      <url>/2022/07/26/Leetcode-2300/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="排序-二分-o-m-n-logm">（排序+二分）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>将表示药水能量强度的数组<code>potions</code>从小到大排序；</li><li>对于每个<code>spells[i]</code>，在<code>potions</code>中二分查找到第一个大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil success / spells[i] \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">⌉</span></span></span></span>的位置，然后记录答案。</li></ol><h2 id="时间复杂度">时间复杂度</h2><p>对<code>potions</code>数组排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>；对每个咒语的能量强度<code>spells[i]</code>均需要在<code>potions</code>数组中做一次二分，二分时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，故总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m+n)logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h2 id="空间复杂度">空间复杂度</h2><p><code>sort</code>排序需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的系统栈空间。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = spells.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = success / spells[i];</span><br><span class="line">            <span class="keyword">if</span> (success % spells[i]) t++;</span><br><span class="line">            res[i] = potions.<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 873 最长的斐波那契子序列的长度</title>
      <link href="/2022/07/09/Leetcode-873/"/>
      <url>/2022/07/09/Leetcode-873/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="线性dp-o-n-2">（线性DP）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><p>本题是最长上升子序列问题的变形。<br>由于斐波那契序列要求新加入的数是前两个数之和，假设新加入斐波那契数列的数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且其前两项分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，因此动态规划的状态定义仅需两维。</p><ol><li>状态定义：用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示最后一个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>且倒数第二个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的最长斐波那契式的子序列长度；</li><li>状态计算：根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k] = arr[i] - arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>可计算出斐波那契序列中倒数第三项的预期值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>已在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>之前出现过，则更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j] = max(f[i][j], f[j][k] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ol><p>注意如果最后不存在斐波那契式的子序列需要返回0。</p><p>状态定义为两维，状态转移的计算开销为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，算法总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            pos[arr[i]] = i;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> x = arr[i] - arr[j];</span><br><span class="line">                f[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; arr[j] &amp;&amp; pos.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                    <span class="type">int</span> k = pos[x];</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[j][k] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">3</span> ? res : <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1217 玩筹码</title>
      <link href="/2022/07/08/Leetcode-1217/"/>
      <url>/2022/07/08/Leetcode-1217/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/">1217. 玩筹码 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="找规律-o-n">（找规律）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4><p>筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，而筹码移动距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此可总结出三条性质：</p><ol><li>筹码在偶数位置间移动无需代价；</li><li>筹码在奇数位置间移动也无需代价；</li><li>将一个筹码在偶数位置与奇数位置间转移的代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ol><p>所以针对本题，首先需要分别统计位于奇数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>和位于偶数位置的筹码数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>，而最终只有两种情况：</p><ol><li>将所有筹码全部放置在某个偶数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">odd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>；</li><li>将所有筹码全部放置在某个奇数位置上，此时代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">even</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>。</li></ol><p>两种情况最小值即为将所有筹码移动到同一位置上所需要的最小代价。</p><p>算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : position)</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span>) odd++;</span><br><span class="line">            <span class="keyword">else</span> even++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 4 寻找两个正序数组中的中位数</title>
      <link href="/2022/05/08/Leetcode-4/"/>
      <url>/2022/05/08/Leetcode-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组中的中位数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="递归-o-log-m-n">（递归）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></h4><p>问题的本质是在两个有序数组中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>小数，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时即可找出中位数。<br>为了便于后续分析，首先假定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素的数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素的数量。分别从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中各自取出前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个元素进行比较：</p><ol><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &gt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过多，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过少，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums2[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数;</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2 - 1] &lt; nums2[k/2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>中元素取得过少，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>中元素取得过多，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素均在两正序数组中位数之前。故可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums1[k/2-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这些元素取出，问题简化为从下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列和下标为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">nums2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span>序列中找出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>小数。当出现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">nums1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span>序列中元素数量小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>的边界情况时，记得数组访问不能越界<code>si = min(i + k / 2, int(nums1.size()))</code>。</li></ol><h4 id="时间复杂度">时间复杂度</h4><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k=(m+n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>即可找出中位数，并且每次递归时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的规模都会减半，因此总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() - i &gt; nums2.<span class="built_in">size</span>() - j)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span> (i == nums1.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">        <span class="type">int</span> si = <span class="built_in">min</span>(i + k / <span class="number">2</span>, <span class="built_in">int</span>(nums1.<span class="built_in">size</span>())), sj = j + k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[si - <span class="number">1</span>] &gt; nums2[sj - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, i, nums2, sj, k - k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthNumber</span>(nums1, si, nums2, j, k - (si - i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 52 N皇后 II</title>
      <link href="/2022/05/04/Leetcode-52/"/>
      <url>/2022/05/04/Leetcode-52/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案数。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u - i + depth] &amp;&amp; !udg[u + i])&#123;</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">                res += <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                col[i] = dg[u - i + depth] = udg[u + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 51 N皇后</title>
      <link href="/2022/05/04/Leetcode-51/"/>
      <url>/2022/05/04/Leetcode-51/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">51. N皇后 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="暴力搜索-o-n">（暴力搜索）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h4><p>算法主要思想是暴力搜索所有方案，为了优化时间效率定义了布尔数组<code>col, dg, udg</code>，分别用来记录每一列、每条对角线和每条反对角线上是否有皇后存在。<br><code>dfs(u)</code>表示搜索棋盘第<code>u</code>行放置皇后的所有可行方案。若棋盘上<code>(u,i)</code>位置对应的列以及对应的对角线和反对角线上都未放置皇后时，则当前位置可以放置皇后<code>path[u][i]='Q'</code>，同时更新<code>col, dg, udg</code>后继续搜索下一行<code>dfs(u+1)</code>。回溯时记得恢复现场，重置<code>col, dg, udg, path</code>。</p><h4 id="时间复杂度">时间复杂度</h4><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个皇后不能在同行同列，所以每行恰有一个皇后，我们计算一下在不考虑对角线的情况下，方案数的上限：第一行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个位置可选，第二行有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span></span></span>个位置可选，依次类推，可得方案数最多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>。所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; col, dg, udg; </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        depth = n;</span><br><span class="line">        col = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n);</span><br><span class="line">        dg = udg = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n * <span class="number">2</span>);</span><br><span class="line">        path = <span class="built_in">vector</span>&lt;string&gt;(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == depth)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[i - u + depth] &amp;&amp; !udg[i + u])&#123;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">true</span>;</span><br><span class="line">                path[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 恢复现场</span></span><br><span class="line">                path[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                col[i] = dg[i - u + depth] = udg[i + u] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 暴力搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 59 螺旋矩阵 II</title>
      <link href="/2022/05/04/Leetcode-59/"/>
      <url>/2022/05/04/Leetcode-59/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-n-2">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>矩阵中每个位置仅遍历一次，所以总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++)&#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n || res[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 54 螺旋矩阵</title>
      <link href="/2022/05/04/Leetcode-54/"/>
      <url>/2022/05/04/Leetcode-54/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="模拟-o-nm">（模拟）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></h4><ol><li>分别定义<code>x方向</code>和<code>y方向</code>上的偏移量数组<code>dx[]=&#123;-1, 0, 1, 0&#125;</code>和<code>dy[]=&#123;0, 1, 0, -1&#125;</code>，规定<code>0</code>向上，<code>1</code>向右，<code>2</code>向下，<code>3</code>向左;</li><li>定义二维bool数组<code>st</code>表示该位置是否被访问过;</li><li>从坐标<code>(0,0)</code>开始，初始方向为<code>1</code>;</li><li>每次遍历后枚举当前方向下的下一个矩阵元素，若该矩阵元素已被访问过或者超越矩阵边界则按顺时针更换方向<code>d=(d+1)%4</code></li></ol><h4 id="时间复杂度">时间复杂度</h4><p>每个位置仅遍历一次，且寻找方向的时间复杂度是常数，故总时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度">空间复杂度</h4><p>需要额外<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的空间存储<code>st</code>数组。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || st[a][b])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span> ) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 蛇形矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 191 位1的个数</title>
      <link href="/2022/05/03/Leetcode-191/"/>
      <url>/2022/05/03/Leetcode-191/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数 - 力扣（LeetCode）</a></p><h2 id="算法">算法</h2><h4 id="位运算-o-1">（位运算）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4><p>在整数的补码表示中，<code>-x</code>等价于<code>~x+1</code>，<code>lowbit(x)=x &amp; -x </code>可以返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>二进制表示下的最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此可以每次减掉<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>二进制表示下最后一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>减到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>为止。</p><p>时间复杂度分析：总共最多进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>次操作，每次操作的计算量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h2 id="c-代码">C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)&#123;</span><br><span class="line">            n -= <span class="built_in">lowbit</span>(n);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">lowbit</span><span class="params">(<span class="type">uint32_t</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/01/hello-world/"/>
      <url>/2022/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
